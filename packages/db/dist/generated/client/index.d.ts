
/**
 * Client
**/

import * as runtime from './runtime/client.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * Sisteme giriÅŸ yapan gerÃ§ek kiÅŸi (Ã–ÄŸretmen veya Ã–ÄŸrenci olabilir).
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model UserSettings
 * KullanÄ±cÄ± gizlilik ve tercih ayarlarÄ±.
 */
export type UserSettings = $Result.DefaultSelection<Prisma.$UserSettingsPayload>
/**
 * Model Account
 * OAuth hesaplarÄ± (Google, Apple vb. ile giriÅŸ iÃ§in).
 */
export type Account = $Result.DefaultSelection<Prisma.$AccountPayload>
/**
 * Model Session
 * Oturum yÃ¶netimi.
 */
export type Session = $Result.DefaultSelection<Prisma.$SessionPayload>
/**
 * Model VerificationToken
 * E-posta doÄŸrulama tokenlarÄ±.
 */
export type VerificationToken = $Result.DefaultSelection<Prisma.$VerificationTokenPayload>
/**
 * Model PasswordResetToken
 * Åžifre sÄ±fÄ±rlama tokenlarÄ±.
 */
export type PasswordResetToken = $Result.DefaultSelection<Prisma.$PasswordResetTokenPayload>
/**
 * Model EmailChangeRequest
 * E-posta deÄŸiÅŸikliÄŸi istekleri.
 */
export type EmailChangeRequest = $Result.DefaultSelection<Prisma.$EmailChangeRequestPayload>
/**
 * Model Device
 * KullanÄ±cÄ±nÄ±n giriÅŸ yaptÄ±ÄŸÄ± cihazlar (Bildirim gÃ¶ndermek iÃ§in).
 */
export type Device = $Result.DefaultSelection<Prisma.$DevicePayload>
/**
 * Model TeacherProfile
 * Ã–ÄŸretmen profili. Dersler, sÄ±nÄ±flar ve finansal veriler buraya baÄŸlÄ±dÄ±r.
 */
export type TeacherProfile = $Result.DefaultSelection<Prisma.$TeacherProfilePayload>
/**
 * Model StudentProfile
 * Ã–ÄŸrenci profili. Hem gerÃ§ek kullanÄ±cÄ±lar hem de "GÃ¶lge Hesaplar" (User'Ä± olmayan) iÃ§in kullanÄ±lÄ±r.
 */
export type StudentProfile = $Result.DefaultSelection<Prisma.$StudentProfilePayload>
/**
 * Model StudentTeacherRelation
 * Ã–ÄŸretmen ve Ã–ÄŸrenci arasÄ±ndaki baÄŸlantÄ± tablosu (Many-to-Many).
 * Ã–ÄŸretmen, Ã¶ÄŸrenciyi kendi listesinde nasÄ±l gÃ¶rÃ¼yor?
 */
export type StudentTeacherRelation = $Result.DefaultSelection<Prisma.$StudentTeacherRelationPayload>
/**
 * Model Classroom
 * SÄ±nÄ±f veya Grup (Ã–rn: "12-A", "LGS Grubu").
 */
export type Classroom = $Result.DefaultSelection<Prisma.$ClassroomPayload>
/**
 * Model ScheduleItem
 * ðŸ“… DERS PROGRAMI ÅžABLONU (Recurring Schedule)
 * "Her Pazartesi 09:00'da Matematik var" kuralÄ±nÄ± tutar.
 */
export type ScheduleItem = $Result.DefaultSelection<Prisma.$ScheduleItemPayload>
/**
 * Model Lesson
 * ðŸ“† GERÃ‡EKLEÅžEN DERS (Event)
 * Takvimde gÃ¶rÃ¼nen, yoklamasÄ± alÄ±nan somut ders kaydÄ±.
 */
export type Lesson = $Result.DefaultSelection<Prisma.$LessonPayload>
/**
 * Model Material
 * Derse eklenen dosya veya linkler.
 */
export type Material = $Result.DefaultSelection<Prisma.$MaterialPayload>
/**
 * Model Homework
 * Verilen Ã–dev (Ana BaÅŸlÄ±k).
 */
export type Homework = $Result.DefaultSelection<Prisma.$HomeworkPayload>
/**
 * Model HomeworkTracking
 * Ã–dev Takibi (Ã–ÄŸrenci bazlÄ± durum).
 * Ã–ÄŸretmenin "YaptÄ±/YapmadÄ±" iÅŸaretlediÄŸi yer.
 */
export type HomeworkTracking = $Result.DefaultSelection<Prisma.$HomeworkTrackingPayload>
/**
 * Model HomeworkSubmission
 * Ã–ÄŸrencinin Ã¶dev teslimi (GeliÅŸmiÅŸ kullanÄ±m).
 */
export type HomeworkSubmission = $Result.DefaultSelection<Prisma.$HomeworkSubmissionPayload>
/**
 * Model SchoolExam
 * Okul SÄ±nav SonuÃ§larÄ± (YazÄ±lÄ±lar).
 */
export type SchoolExam = $Result.DefaultSelection<Prisma.$SchoolExamPayload>
/**
 * Model TrialExam
 * Deneme SÄ±navÄ± (Ana KayÄ±t).
 */
export type TrialExam = $Result.DefaultSelection<Prisma.$TrialExamPayload>
/**
 * Model TrialExamResult
 * Deneme SÄ±navÄ± DetaylarÄ± (Ders bazlÄ± netler).
 */
export type TrialExamResult = $Result.DefaultSelection<Prisma.$TrialExamResultPayload>
/**
 * Model Attendance
 * Yoklama KaydÄ±.
 */
export type Attendance = $Result.DefaultSelection<Prisma.$AttendancePayload>
/**
 * Model Payment
 * Ã–deme KayÄ±tlarÄ±.
 */
export type Payment = $Result.DefaultSelection<Prisma.$PaymentPayload>
/**
 * Model Todo
 * YapÄ±lacaklar Listesi.
 */
export type Todo = $Result.DefaultSelection<Prisma.$TodoPayload>
/**
 * Model Event
 * Genel Takvim EtkinliÄŸi (Ders dÄ±ÅŸÄ± olaylar).
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Message
 * KullanÄ±cÄ±lar arasÄ± mesajlaÅŸma.
 */
export type Message = $Result.DefaultSelection<Prisma.$MessagePayload>
/**
 * Model Notification
 * Sistem Bildirimleri.
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model File
 * 
 */
export type File = $Result.DefaultSelection<Prisma.$FilePayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Role: {
  ADMIN: 'ADMIN',
  TEACHER: 'TEACHER',
  STUDENT: 'STUDENT'
};

export type Role = (typeof Role)[keyof typeof Role]


export const DeviceType: {
  IOS: 'IOS',
  ANDROID: 'ANDROID',
  WEB: 'WEB'
};

export type DeviceType = (typeof DeviceType)[keyof typeof DeviceType]


export const RelationStatus: {
  ACTIVE: 'ACTIVE',
  ARCHIVED: 'ARCHIVED',
  PENDING: 'PENDING',
  BLOCKED: 'BLOCKED'
};

export type RelationStatus = (typeof RelationStatus)[keyof typeof RelationStatus]


export const LessonType: {
  PRIVATE: 'PRIVATE',
  GROUP: 'GROUP',
  INSTITUTION: 'INSTITUTION'
};

export type LessonType = (typeof LessonType)[keyof typeof LessonType]


export const LessonStatus: {
  SCHEDULED: 'SCHEDULED',
  COMPLETED: 'COMPLETED',
  CANCELLED: 'CANCELLED',
  MISSED: 'MISSED'
};

export type LessonStatus = (typeof LessonStatus)[keyof typeof LessonStatus]


export const LessonLocation: {
  ONLINE: 'ONLINE',
  TEACHER_HOME: 'TEACHER_HOME',
  STUDENT_HOME: 'STUDENT_HOME',
  INSTITUTION: 'INSTITUTION',
  OTHER: 'OTHER'
};

export type LessonLocation = (typeof LessonLocation)[keyof typeof LessonLocation]


export const PaymentType: {
  CASH: 'CASH',
  BANK_TRANSFER: 'BANK_TRANSFER',
  CREDIT_CARD: 'CREDIT_CARD',
  OTHER: 'OTHER'
};

export type PaymentType = (typeof PaymentType)[keyof typeof PaymentType]


export const HomeworkStatus: {
  PENDING: 'PENDING',
  COMPLETED: 'COMPLETED',
  INCOMPLETE: 'INCOMPLETE',
  MISSING: 'MISSING',
  LATE: 'LATE',
  SUBMITTED: 'SUBMITTED'
};

export type HomeworkStatus = (typeof HomeworkStatus)[keyof typeof HomeworkStatus]


export const ExamCategory: {
  TYT: 'TYT',
  AYT: 'AYT',
  YDT: 'YDT',
  LGS: 'LGS',
  KPSS: 'KPSS',
  GENERAL: 'GENERAL'
};

export type ExamCategory = (typeof ExamCategory)[keyof typeof ExamCategory]


export const AttendanceStatus: {
  PRESENT: 'PRESENT',
  ABSENT: 'ABSENT',
  EXCUSED: 'EXCUSED',
  LATE: 'LATE'
};

export type AttendanceStatus = (typeof AttendanceStatus)[keyof typeof AttendanceStatus]


export const Priority: {
  LOW: 'LOW',
  MEDIUM: 'MEDIUM',
  HIGH: 'HIGH',
  URGENT: 'URGENT'
};

export type Priority = (typeof Priority)[keyof typeof Priority]


export const NotificationType: {
  LESSON_REMINDER: 'LESSON_REMINDER',
  HOMEWORK_NEW: 'HOMEWORK_NEW',
  HOMEWORK_LATE: 'HOMEWORK_LATE',
  EXAM_RESULT: 'EXAM_RESULT',
  PAYMENT: 'PAYMENT',
  MESSAGE: 'MESSAGE',
  SYSTEM: 'SYSTEM'
};

export type NotificationType = (typeof NotificationType)[keyof typeof NotificationType]


export const FileType: {
  PDF: 'PDF',
  VIDEO: 'VIDEO',
  LINK: 'LINK',
  IMAGE: 'IMAGE',
  OTHER: 'OTHER'
};

export type FileType = (typeof FileType)[keyof typeof FileType]

}

export type Role = $Enums.Role

export const Role: typeof $Enums.Role

export type DeviceType = $Enums.DeviceType

export const DeviceType: typeof $Enums.DeviceType

export type RelationStatus = $Enums.RelationStatus

export const RelationStatus: typeof $Enums.RelationStatus

export type LessonType = $Enums.LessonType

export const LessonType: typeof $Enums.LessonType

export type LessonStatus = $Enums.LessonStatus

export const LessonStatus: typeof $Enums.LessonStatus

export type LessonLocation = $Enums.LessonLocation

export const LessonLocation: typeof $Enums.LessonLocation

export type PaymentType = $Enums.PaymentType

export const PaymentType: typeof $Enums.PaymentType

export type HomeworkStatus = $Enums.HomeworkStatus

export const HomeworkStatus: typeof $Enums.HomeworkStatus

export type ExamCategory = $Enums.ExamCategory

export const ExamCategory: typeof $Enums.ExamCategory

export type AttendanceStatus = $Enums.AttendanceStatus

export const AttendanceStatus: typeof $Enums.AttendanceStatus

export type Priority = $Enums.Priority

export const Priority: typeof $Enums.Priority

export type NotificationType = $Enums.NotificationType

export const NotificationType: typeof $Enums.NotificationType

export type FileType = $Enums.FileType

export const FileType: typeof $Enums.FileType

/**
 * ##  Prisma Client Ê²Ë¢
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://pris.ly/d/client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client Ê²Ë¢
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://pris.ly/d/client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   *
   * Read more in our [docs](https://pris.ly/d/raw-queries).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.userSettings`: Exposes CRUD operations for the **UserSettings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserSettings
    * const userSettings = await prisma.userSettings.findMany()
    * ```
    */
  get userSettings(): Prisma.UserSettingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.account`: Exposes CRUD operations for the **Account** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Accounts
    * const accounts = await prisma.account.findMany()
    * ```
    */
  get account(): Prisma.AccountDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.session`: Exposes CRUD operations for the **Session** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sessions
    * const sessions = await prisma.session.findMany()
    * ```
    */
  get session(): Prisma.SessionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.verificationToken`: Exposes CRUD operations for the **VerificationToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more VerificationTokens
    * const verificationTokens = await prisma.verificationToken.findMany()
    * ```
    */
  get verificationToken(): Prisma.VerificationTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.passwordResetToken`: Exposes CRUD operations for the **PasswordResetToken** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordResetTokens
    * const passwordResetTokens = await prisma.passwordResetToken.findMany()
    * ```
    */
  get passwordResetToken(): Prisma.PasswordResetTokenDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.emailChangeRequest`: Exposes CRUD operations for the **EmailChangeRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailChangeRequests
    * const emailChangeRequests = await prisma.emailChangeRequest.findMany()
    * ```
    */
  get emailChangeRequest(): Prisma.EmailChangeRequestDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.device`: Exposes CRUD operations for the **Device** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Devices
    * const devices = await prisma.device.findMany()
    * ```
    */
  get device(): Prisma.DeviceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.teacherProfile`: Exposes CRUD operations for the **TeacherProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeacherProfiles
    * const teacherProfiles = await prisma.teacherProfile.findMany()
    * ```
    */
  get teacherProfile(): Prisma.TeacherProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentProfile`: Exposes CRUD operations for the **StudentProfile** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentProfiles
    * const studentProfiles = await prisma.studentProfile.findMany()
    * ```
    */
  get studentProfile(): Prisma.StudentProfileDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.studentTeacherRelation`: Exposes CRUD operations for the **StudentTeacherRelation** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more StudentTeacherRelations
    * const studentTeacherRelations = await prisma.studentTeacherRelation.findMany()
    * ```
    */
  get studentTeacherRelation(): Prisma.StudentTeacherRelationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.classroom`: Exposes CRUD operations for the **Classroom** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Classrooms
    * const classrooms = await prisma.classroom.findMany()
    * ```
    */
  get classroom(): Prisma.ClassroomDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.scheduleItem`: Exposes CRUD operations for the **ScheduleItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ScheduleItems
    * const scheduleItems = await prisma.scheduleItem.findMany()
    * ```
    */
  get scheduleItem(): Prisma.ScheduleItemDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.lesson`: Exposes CRUD operations for the **Lesson** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Lessons
    * const lessons = await prisma.lesson.findMany()
    * ```
    */
  get lesson(): Prisma.LessonDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.material`: Exposes CRUD operations for the **Material** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Materials
    * const materials = await prisma.material.findMany()
    * ```
    */
  get material(): Prisma.MaterialDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.homework`: Exposes CRUD operations for the **Homework** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Homework
    * const homework = await prisma.homework.findMany()
    * ```
    */
  get homework(): Prisma.HomeworkDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.homeworkTracking`: Exposes CRUD operations for the **HomeworkTracking** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomeworkTrackings
    * const homeworkTrackings = await prisma.homeworkTracking.findMany()
    * ```
    */
  get homeworkTracking(): Prisma.HomeworkTrackingDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.homeworkSubmission`: Exposes CRUD operations for the **HomeworkSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HomeworkSubmissions
    * const homeworkSubmissions = await prisma.homeworkSubmission.findMany()
    * ```
    */
  get homeworkSubmission(): Prisma.HomeworkSubmissionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.schoolExam`: Exposes CRUD operations for the **SchoolExam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SchoolExams
    * const schoolExams = await prisma.schoolExam.findMany()
    * ```
    */
  get schoolExam(): Prisma.SchoolExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trialExam`: Exposes CRUD operations for the **TrialExam** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrialExams
    * const trialExams = await prisma.trialExam.findMany()
    * ```
    */
  get trialExam(): Prisma.TrialExamDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.trialExamResult`: Exposes CRUD operations for the **TrialExamResult** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TrialExamResults
    * const trialExamResults = await prisma.trialExamResult.findMany()
    * ```
    */
  get trialExamResult(): Prisma.TrialExamResultDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.attendance`: Exposes CRUD operations for the **Attendance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Attendances
    * const attendances = await prisma.attendance.findMany()
    * ```
    */
  get attendance(): Prisma.AttendanceDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.payment`: Exposes CRUD operations for the **Payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Payments
    * const payments = await prisma.payment.findMany()
    * ```
    */
  get payment(): Prisma.PaymentDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.todo`: Exposes CRUD operations for the **Todo** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Todos
    * const todos = await prisma.todo.findMany()
    * ```
    */
  get todo(): Prisma.TodoDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.message`: Exposes CRUD operations for the **Message** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Messages
    * const messages = await prisma.message.findMany()
    * ```
    */
  get message(): Prisma.MessageDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.file`: Exposes CRUD operations for the **File** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Files
    * const files = await prisma.file.findMany()
    * ```
    */
  get file(): Prisma.FileDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 7.2.0
   * Query Engine version: 0c8ef2ce45c83248ab3df073180d5eda9e8be7a3
   */
  export type PrismaVersion = {
    client: string
    engine: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    UserSettings: 'UserSettings',
    Account: 'Account',
    Session: 'Session',
    VerificationToken: 'VerificationToken',
    PasswordResetToken: 'PasswordResetToken',
    EmailChangeRequest: 'EmailChangeRequest',
    Device: 'Device',
    TeacherProfile: 'TeacherProfile',
    StudentProfile: 'StudentProfile',
    StudentTeacherRelation: 'StudentTeacherRelation',
    Classroom: 'Classroom',
    ScheduleItem: 'ScheduleItem',
    Lesson: 'Lesson',
    Material: 'Material',
    Homework: 'Homework',
    HomeworkTracking: 'HomeworkTracking',
    HomeworkSubmission: 'HomeworkSubmission',
    SchoolExam: 'SchoolExam',
    TrialExam: 'TrialExam',
    TrialExamResult: 'TrialExamResult',
    Attendance: 'Attendance',
    Payment: 'Payment',
    Todo: 'Todo',
    Event: 'Event',
    Message: 'Message',
    Notification: 'Notification',
    File: 'File'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]



  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "user" | "userSettings" | "account" | "session" | "verificationToken" | "passwordResetToken" | "emailChangeRequest" | "device" | "teacherProfile" | "studentProfile" | "studentTeacherRelation" | "classroom" | "scheduleItem" | "lesson" | "material" | "homework" | "homeworkTracking" | "homeworkSubmission" | "schoolExam" | "trialExam" | "trialExamResult" | "attendance" | "payment" | "todo" | "event" | "message" | "notification" | "file"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      UserSettings: {
        payload: Prisma.$UserSettingsPayload<ExtArgs>
        fields: Prisma.UserSettingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserSettingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserSettingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findFirst: {
            args: Prisma.UserSettingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserSettingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          findMany: {
            args: Prisma.UserSettingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          create: {
            args: Prisma.UserSettingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          createMany: {
            args: Prisma.UserSettingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserSettingsCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          delete: {
            args: Prisma.UserSettingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          update: {
            args: Prisma.UserSettingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          deleteMany: {
            args: Prisma.UserSettingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserSettingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.UserSettingsUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>[]
          }
          upsert: {
            args: Prisma.UserSettingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserSettingsPayload>
          }
          aggregate: {
            args: Prisma.UserSettingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserSettings>
          }
          groupBy: {
            args: Prisma.UserSettingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserSettingsCountArgs<ExtArgs>
            result: $Utils.Optional<UserSettingsCountAggregateOutputType> | number
          }
        }
      }
      Account: {
        payload: Prisma.$AccountPayload<ExtArgs>
        fields: Prisma.AccountFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AccountFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AccountFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findFirst: {
            args: Prisma.AccountFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AccountFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          findMany: {
            args: Prisma.AccountFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          create: {
            args: Prisma.AccountCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          createMany: {
            args: Prisma.AccountCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AccountCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          delete: {
            args: Prisma.AccountDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          update: {
            args: Prisma.AccountUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          deleteMany: {
            args: Prisma.AccountDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AccountUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AccountUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>[]
          }
          upsert: {
            args: Prisma.AccountUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AccountPayload>
          }
          aggregate: {
            args: Prisma.AccountAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAccount>
          }
          groupBy: {
            args: Prisma.AccountGroupByArgs<ExtArgs>
            result: $Utils.Optional<AccountGroupByOutputType>[]
          }
          count: {
            args: Prisma.AccountCountArgs<ExtArgs>
            result: $Utils.Optional<AccountCountAggregateOutputType> | number
          }
        }
      }
      Session: {
        payload: Prisma.$SessionPayload<ExtArgs>
        fields: Prisma.SessionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SessionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SessionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findFirst: {
            args: Prisma.SessionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SessionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          findMany: {
            args: Prisma.SessionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          create: {
            args: Prisma.SessionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          createMany: {
            args: Prisma.SessionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SessionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          delete: {
            args: Prisma.SessionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          update: {
            args: Prisma.SessionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          deleteMany: {
            args: Prisma.SessionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SessionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SessionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>[]
          }
          upsert: {
            args: Prisma.SessionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SessionPayload>
          }
          aggregate: {
            args: Prisma.SessionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSession>
          }
          groupBy: {
            args: Prisma.SessionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SessionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SessionCountArgs<ExtArgs>
            result: $Utils.Optional<SessionCountAggregateOutputType> | number
          }
        }
      }
      VerificationToken: {
        payload: Prisma.$VerificationTokenPayload<ExtArgs>
        fields: Prisma.VerificationTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.VerificationTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.VerificationTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findFirst: {
            args: Prisma.VerificationTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.VerificationTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          findMany: {
            args: Prisma.VerificationTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          create: {
            args: Prisma.VerificationTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          createMany: {
            args: Prisma.VerificationTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.VerificationTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          delete: {
            args: Prisma.VerificationTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          update: {
            args: Prisma.VerificationTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          deleteMany: {
            args: Prisma.VerificationTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.VerificationTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.VerificationTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>[]
          }
          upsert: {
            args: Prisma.VerificationTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$VerificationTokenPayload>
          }
          aggregate: {
            args: Prisma.VerificationTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVerificationToken>
          }
          groupBy: {
            args: Prisma.VerificationTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.VerificationTokenCountArgs<ExtArgs>
            result: $Utils.Optional<VerificationTokenCountAggregateOutputType> | number
          }
        }
      }
      PasswordResetToken: {
        payload: Prisma.$PasswordResetTokenPayload<ExtArgs>
        fields: Prisma.PasswordResetTokenFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordResetTokenFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findFirst: {
            args: Prisma.PasswordResetTokenFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          findMany: {
            args: Prisma.PasswordResetTokenFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          create: {
            args: Prisma.PasswordResetTokenCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          createMany: {
            args: Prisma.PasswordResetTokenCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          delete: {
            args: Prisma.PasswordResetTokenDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          update: {
            args: Prisma.PasswordResetTokenUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          deleteMany: {
            args: Prisma.PasswordResetTokenDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordResetTokenUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>[]
          }
          upsert: {
            args: Prisma.PasswordResetTokenUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordResetTokenPayload>
          }
          aggregate: {
            args: Prisma.PasswordResetTokenAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordResetToken>
          }
          groupBy: {
            args: Prisma.PasswordResetTokenGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordResetTokenCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordResetTokenCountAggregateOutputType> | number
          }
        }
      }
      EmailChangeRequest: {
        payload: Prisma.$EmailChangeRequestPayload<ExtArgs>
        fields: Prisma.EmailChangeRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailChangeRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailChangeRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeRequestPayload>
          }
          findFirst: {
            args: Prisma.EmailChangeRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailChangeRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeRequestPayload>
          }
          findMany: {
            args: Prisma.EmailChangeRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeRequestPayload>[]
          }
          create: {
            args: Prisma.EmailChangeRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeRequestPayload>
          }
          createMany: {
            args: Prisma.EmailChangeRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmailChangeRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeRequestPayload>[]
          }
          delete: {
            args: Prisma.EmailChangeRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeRequestPayload>
          }
          update: {
            args: Prisma.EmailChangeRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeRequestPayload>
          }
          deleteMany: {
            args: Prisma.EmailChangeRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailChangeRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EmailChangeRequestUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeRequestPayload>[]
          }
          upsert: {
            args: Prisma.EmailChangeRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailChangeRequestPayload>
          }
          aggregate: {
            args: Prisma.EmailChangeRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailChangeRequest>
          }
          groupBy: {
            args: Prisma.EmailChangeRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailChangeRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailChangeRequestCountArgs<ExtArgs>
            result: $Utils.Optional<EmailChangeRequestCountAggregateOutputType> | number
          }
        }
      }
      Device: {
        payload: Prisma.$DevicePayload<ExtArgs>
        fields: Prisma.DeviceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DeviceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DeviceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findFirst: {
            args: Prisma.DeviceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DeviceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          findMany: {
            args: Prisma.DeviceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          create: {
            args: Prisma.DeviceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          createMany: {
            args: Prisma.DeviceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DeviceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          delete: {
            args: Prisma.DeviceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          update: {
            args: Prisma.DeviceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          deleteMany: {
            args: Prisma.DeviceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DeviceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.DeviceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>[]
          }
          upsert: {
            args: Prisma.DeviceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DevicePayload>
          }
          aggregate: {
            args: Prisma.DeviceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDevice>
          }
          groupBy: {
            args: Prisma.DeviceGroupByArgs<ExtArgs>
            result: $Utils.Optional<DeviceGroupByOutputType>[]
          }
          count: {
            args: Prisma.DeviceCountArgs<ExtArgs>
            result: $Utils.Optional<DeviceCountAggregateOutputType> | number
          }
        }
      }
      TeacherProfile: {
        payload: Prisma.$TeacherProfilePayload<ExtArgs>
        fields: Prisma.TeacherProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeacherProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeacherProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          findFirst: {
            args: Prisma.TeacherProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeacherProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          findMany: {
            args: Prisma.TeacherProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>[]
          }
          create: {
            args: Prisma.TeacherProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          createMany: {
            args: Prisma.TeacherProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TeacherProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>[]
          }
          delete: {
            args: Prisma.TeacherProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          update: {
            args: Prisma.TeacherProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          deleteMany: {
            args: Prisma.TeacherProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeacherProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TeacherProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>[]
          }
          upsert: {
            args: Prisma.TeacherProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeacherProfilePayload>
          }
          aggregate: {
            args: Prisma.TeacherProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeacherProfile>
          }
          groupBy: {
            args: Prisma.TeacherProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeacherProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeacherProfileCountArgs<ExtArgs>
            result: $Utils.Optional<TeacherProfileCountAggregateOutputType> | number
          }
        }
      }
      StudentProfile: {
        payload: Prisma.$StudentProfilePayload<ExtArgs>
        fields: Prisma.StudentProfileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentProfileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentProfileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          findFirst: {
            args: Prisma.StudentProfileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentProfileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          findMany: {
            args: Prisma.StudentProfileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>[]
          }
          create: {
            args: Prisma.StudentProfileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          createMany: {
            args: Prisma.StudentProfileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentProfileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>[]
          }
          delete: {
            args: Prisma.StudentProfileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          update: {
            args: Prisma.StudentProfileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          deleteMany: {
            args: Prisma.StudentProfileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentProfileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentProfileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>[]
          }
          upsert: {
            args: Prisma.StudentProfileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentProfilePayload>
          }
          aggregate: {
            args: Prisma.StudentProfileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentProfile>
          }
          groupBy: {
            args: Prisma.StudentProfileGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentProfileGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentProfileCountArgs<ExtArgs>
            result: $Utils.Optional<StudentProfileCountAggregateOutputType> | number
          }
        }
      }
      StudentTeacherRelation: {
        payload: Prisma.$StudentTeacherRelationPayload<ExtArgs>
        fields: Prisma.StudentTeacherRelationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.StudentTeacherRelationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTeacherRelationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.StudentTeacherRelationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTeacherRelationPayload>
          }
          findFirst: {
            args: Prisma.StudentTeacherRelationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTeacherRelationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.StudentTeacherRelationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTeacherRelationPayload>
          }
          findMany: {
            args: Prisma.StudentTeacherRelationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTeacherRelationPayload>[]
          }
          create: {
            args: Prisma.StudentTeacherRelationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTeacherRelationPayload>
          }
          createMany: {
            args: Prisma.StudentTeacherRelationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.StudentTeacherRelationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTeacherRelationPayload>[]
          }
          delete: {
            args: Prisma.StudentTeacherRelationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTeacherRelationPayload>
          }
          update: {
            args: Prisma.StudentTeacherRelationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTeacherRelationPayload>
          }
          deleteMany: {
            args: Prisma.StudentTeacherRelationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.StudentTeacherRelationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.StudentTeacherRelationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTeacherRelationPayload>[]
          }
          upsert: {
            args: Prisma.StudentTeacherRelationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$StudentTeacherRelationPayload>
          }
          aggregate: {
            args: Prisma.StudentTeacherRelationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStudentTeacherRelation>
          }
          groupBy: {
            args: Prisma.StudentTeacherRelationGroupByArgs<ExtArgs>
            result: $Utils.Optional<StudentTeacherRelationGroupByOutputType>[]
          }
          count: {
            args: Prisma.StudentTeacherRelationCountArgs<ExtArgs>
            result: $Utils.Optional<StudentTeacherRelationCountAggregateOutputType> | number
          }
        }
      }
      Classroom: {
        payload: Prisma.$ClassroomPayload<ExtArgs>
        fields: Prisma.ClassroomFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ClassroomFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ClassroomFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          findFirst: {
            args: Prisma.ClassroomFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ClassroomFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          findMany: {
            args: Prisma.ClassroomFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>[]
          }
          create: {
            args: Prisma.ClassroomCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          createMany: {
            args: Prisma.ClassroomCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ClassroomCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>[]
          }
          delete: {
            args: Prisma.ClassroomDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          update: {
            args: Prisma.ClassroomUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          deleteMany: {
            args: Prisma.ClassroomDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ClassroomUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ClassroomUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>[]
          }
          upsert: {
            args: Prisma.ClassroomUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ClassroomPayload>
          }
          aggregate: {
            args: Prisma.ClassroomAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateClassroom>
          }
          groupBy: {
            args: Prisma.ClassroomGroupByArgs<ExtArgs>
            result: $Utils.Optional<ClassroomGroupByOutputType>[]
          }
          count: {
            args: Prisma.ClassroomCountArgs<ExtArgs>
            result: $Utils.Optional<ClassroomCountAggregateOutputType> | number
          }
        }
      }
      ScheduleItem: {
        payload: Prisma.$ScheduleItemPayload<ExtArgs>
        fields: Prisma.ScheduleItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ScheduleItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ScheduleItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          findFirst: {
            args: Prisma.ScheduleItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ScheduleItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          findMany: {
            args: Prisma.ScheduleItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>[]
          }
          create: {
            args: Prisma.ScheduleItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          createMany: {
            args: Prisma.ScheduleItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ScheduleItemCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>[]
          }
          delete: {
            args: Prisma.ScheduleItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          update: {
            args: Prisma.ScheduleItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          deleteMany: {
            args: Prisma.ScheduleItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ScheduleItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.ScheduleItemUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>[]
          }
          upsert: {
            args: Prisma.ScheduleItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ScheduleItemPayload>
          }
          aggregate: {
            args: Prisma.ScheduleItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateScheduleItem>
          }
          groupBy: {
            args: Prisma.ScheduleItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<ScheduleItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.ScheduleItemCountArgs<ExtArgs>
            result: $Utils.Optional<ScheduleItemCountAggregateOutputType> | number
          }
        }
      }
      Lesson: {
        payload: Prisma.$LessonPayload<ExtArgs>
        fields: Prisma.LessonFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LessonFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LessonFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findFirst: {
            args: Prisma.LessonFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LessonFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          findMany: {
            args: Prisma.LessonFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          create: {
            args: Prisma.LessonCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          createMany: {
            args: Prisma.LessonCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LessonCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          delete: {
            args: Prisma.LessonDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          update: {
            args: Prisma.LessonUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          deleteMany: {
            args: Prisma.LessonDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LessonUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.LessonUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>[]
          }
          upsert: {
            args: Prisma.LessonUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LessonPayload>
          }
          aggregate: {
            args: Prisma.LessonAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLesson>
          }
          groupBy: {
            args: Prisma.LessonGroupByArgs<ExtArgs>
            result: $Utils.Optional<LessonGroupByOutputType>[]
          }
          count: {
            args: Prisma.LessonCountArgs<ExtArgs>
            result: $Utils.Optional<LessonCountAggregateOutputType> | number
          }
        }
      }
      Material: {
        payload: Prisma.$MaterialPayload<ExtArgs>
        fields: Prisma.MaterialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MaterialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MaterialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findFirst: {
            args: Prisma.MaterialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MaterialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          findMany: {
            args: Prisma.MaterialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          create: {
            args: Prisma.MaterialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          createMany: {
            args: Prisma.MaterialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MaterialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          delete: {
            args: Prisma.MaterialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          update: {
            args: Prisma.MaterialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          deleteMany: {
            args: Prisma.MaterialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MaterialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MaterialUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>[]
          }
          upsert: {
            args: Prisma.MaterialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MaterialPayload>
          }
          aggregate: {
            args: Prisma.MaterialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMaterial>
          }
          groupBy: {
            args: Prisma.MaterialGroupByArgs<ExtArgs>
            result: $Utils.Optional<MaterialGroupByOutputType>[]
          }
          count: {
            args: Prisma.MaterialCountArgs<ExtArgs>
            result: $Utils.Optional<MaterialCountAggregateOutputType> | number
          }
        }
      }
      Homework: {
        payload: Prisma.$HomeworkPayload<ExtArgs>
        fields: Prisma.HomeworkFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HomeworkFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HomeworkFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkPayload>
          }
          findFirst: {
            args: Prisma.HomeworkFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HomeworkFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkPayload>
          }
          findMany: {
            args: Prisma.HomeworkFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkPayload>[]
          }
          create: {
            args: Prisma.HomeworkCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkPayload>
          }
          createMany: {
            args: Prisma.HomeworkCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HomeworkCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkPayload>[]
          }
          delete: {
            args: Prisma.HomeworkDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkPayload>
          }
          update: {
            args: Prisma.HomeworkUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkPayload>
          }
          deleteMany: {
            args: Prisma.HomeworkDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HomeworkUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HomeworkUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkPayload>[]
          }
          upsert: {
            args: Prisma.HomeworkUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkPayload>
          }
          aggregate: {
            args: Prisma.HomeworkAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHomework>
          }
          groupBy: {
            args: Prisma.HomeworkGroupByArgs<ExtArgs>
            result: $Utils.Optional<HomeworkGroupByOutputType>[]
          }
          count: {
            args: Prisma.HomeworkCountArgs<ExtArgs>
            result: $Utils.Optional<HomeworkCountAggregateOutputType> | number
          }
        }
      }
      HomeworkTracking: {
        payload: Prisma.$HomeworkTrackingPayload<ExtArgs>
        fields: Prisma.HomeworkTrackingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HomeworkTrackingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkTrackingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HomeworkTrackingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkTrackingPayload>
          }
          findFirst: {
            args: Prisma.HomeworkTrackingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkTrackingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HomeworkTrackingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkTrackingPayload>
          }
          findMany: {
            args: Prisma.HomeworkTrackingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkTrackingPayload>[]
          }
          create: {
            args: Prisma.HomeworkTrackingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkTrackingPayload>
          }
          createMany: {
            args: Prisma.HomeworkTrackingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HomeworkTrackingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkTrackingPayload>[]
          }
          delete: {
            args: Prisma.HomeworkTrackingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkTrackingPayload>
          }
          update: {
            args: Prisma.HomeworkTrackingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkTrackingPayload>
          }
          deleteMany: {
            args: Prisma.HomeworkTrackingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HomeworkTrackingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HomeworkTrackingUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkTrackingPayload>[]
          }
          upsert: {
            args: Prisma.HomeworkTrackingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkTrackingPayload>
          }
          aggregate: {
            args: Prisma.HomeworkTrackingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHomeworkTracking>
          }
          groupBy: {
            args: Prisma.HomeworkTrackingGroupByArgs<ExtArgs>
            result: $Utils.Optional<HomeworkTrackingGroupByOutputType>[]
          }
          count: {
            args: Prisma.HomeworkTrackingCountArgs<ExtArgs>
            result: $Utils.Optional<HomeworkTrackingCountAggregateOutputType> | number
          }
        }
      }
      HomeworkSubmission: {
        payload: Prisma.$HomeworkSubmissionPayload<ExtArgs>
        fields: Prisma.HomeworkSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HomeworkSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HomeworkSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkSubmissionPayload>
          }
          findFirst: {
            args: Prisma.HomeworkSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HomeworkSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkSubmissionPayload>
          }
          findMany: {
            args: Prisma.HomeworkSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkSubmissionPayload>[]
          }
          create: {
            args: Prisma.HomeworkSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkSubmissionPayload>
          }
          createMany: {
            args: Prisma.HomeworkSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HomeworkSubmissionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkSubmissionPayload>[]
          }
          delete: {
            args: Prisma.HomeworkSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkSubmissionPayload>
          }
          update: {
            args: Prisma.HomeworkSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.HomeworkSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HomeworkSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.HomeworkSubmissionUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkSubmissionPayload>[]
          }
          upsert: {
            args: Prisma.HomeworkSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HomeworkSubmissionPayload>
          }
          aggregate: {
            args: Prisma.HomeworkSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHomeworkSubmission>
          }
          groupBy: {
            args: Prisma.HomeworkSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<HomeworkSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.HomeworkSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<HomeworkSubmissionCountAggregateOutputType> | number
          }
        }
      }
      SchoolExam: {
        payload: Prisma.$SchoolExamPayload<ExtArgs>
        fields: Prisma.SchoolExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SchoolExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SchoolExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolExamPayload>
          }
          findFirst: {
            args: Prisma.SchoolExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SchoolExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolExamPayload>
          }
          findMany: {
            args: Prisma.SchoolExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolExamPayload>[]
          }
          create: {
            args: Prisma.SchoolExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolExamPayload>
          }
          createMany: {
            args: Prisma.SchoolExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SchoolExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolExamPayload>[]
          }
          delete: {
            args: Prisma.SchoolExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolExamPayload>
          }
          update: {
            args: Prisma.SchoolExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolExamPayload>
          }
          deleteMany: {
            args: Prisma.SchoolExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SchoolExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.SchoolExamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolExamPayload>[]
          }
          upsert: {
            args: Prisma.SchoolExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SchoolExamPayload>
          }
          aggregate: {
            args: Prisma.SchoolExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSchoolExam>
          }
          groupBy: {
            args: Prisma.SchoolExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<SchoolExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.SchoolExamCountArgs<ExtArgs>
            result: $Utils.Optional<SchoolExamCountAggregateOutputType> | number
          }
        }
      }
      TrialExam: {
        payload: Prisma.$TrialExamPayload<ExtArgs>
        fields: Prisma.TrialExamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrialExamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrialExamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamPayload>
          }
          findFirst: {
            args: Prisma.TrialExamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrialExamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamPayload>
          }
          findMany: {
            args: Prisma.TrialExamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamPayload>[]
          }
          create: {
            args: Prisma.TrialExamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamPayload>
          }
          createMany: {
            args: Prisma.TrialExamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrialExamCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamPayload>[]
          }
          delete: {
            args: Prisma.TrialExamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamPayload>
          }
          update: {
            args: Prisma.TrialExamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamPayload>
          }
          deleteMany: {
            args: Prisma.TrialExamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrialExamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrialExamUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamPayload>[]
          }
          upsert: {
            args: Prisma.TrialExamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamPayload>
          }
          aggregate: {
            args: Prisma.TrialExamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrialExam>
          }
          groupBy: {
            args: Prisma.TrialExamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrialExamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrialExamCountArgs<ExtArgs>
            result: $Utils.Optional<TrialExamCountAggregateOutputType> | number
          }
        }
      }
      TrialExamResult: {
        payload: Prisma.$TrialExamResultPayload<ExtArgs>
        fields: Prisma.TrialExamResultFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TrialExamResultFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamResultPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TrialExamResultFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamResultPayload>
          }
          findFirst: {
            args: Prisma.TrialExamResultFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamResultPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TrialExamResultFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamResultPayload>
          }
          findMany: {
            args: Prisma.TrialExamResultFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamResultPayload>[]
          }
          create: {
            args: Prisma.TrialExamResultCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamResultPayload>
          }
          createMany: {
            args: Prisma.TrialExamResultCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TrialExamResultCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamResultPayload>[]
          }
          delete: {
            args: Prisma.TrialExamResultDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamResultPayload>
          }
          update: {
            args: Prisma.TrialExamResultUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamResultPayload>
          }
          deleteMany: {
            args: Prisma.TrialExamResultDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TrialExamResultUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TrialExamResultUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamResultPayload>[]
          }
          upsert: {
            args: Prisma.TrialExamResultUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TrialExamResultPayload>
          }
          aggregate: {
            args: Prisma.TrialExamResultAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTrialExamResult>
          }
          groupBy: {
            args: Prisma.TrialExamResultGroupByArgs<ExtArgs>
            result: $Utils.Optional<TrialExamResultGroupByOutputType>[]
          }
          count: {
            args: Prisma.TrialExamResultCountArgs<ExtArgs>
            result: $Utils.Optional<TrialExamResultCountAggregateOutputType> | number
          }
        }
      }
      Attendance: {
        payload: Prisma.$AttendancePayload<ExtArgs>
        fields: Prisma.AttendanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findFirst: {
            args: Prisma.AttendanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          findMany: {
            args: Prisma.AttendanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          create: {
            args: Prisma.AttendanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          createMany: {
            args: Prisma.AttendanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          delete: {
            args: Prisma.AttendanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          update: {
            args: Prisma.AttendanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          deleteMany: {
            args: Prisma.AttendanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.AttendanceUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>[]
          }
          upsert: {
            args: Prisma.AttendanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendancePayload>
          }
          aggregate: {
            args: Prisma.AttendanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendance>
          }
          groupBy: {
            args: Prisma.AttendanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceCountAggregateOutputType> | number
          }
        }
      }
      Payment: {
        payload: Prisma.$PaymentPayload<ExtArgs>
        fields: Prisma.PaymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PaymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PaymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findFirst: {
            args: Prisma.PaymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PaymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          findMany: {
            args: Prisma.PaymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          create: {
            args: Prisma.PaymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          createMany: {
            args: Prisma.PaymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PaymentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          delete: {
            args: Prisma.PaymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          update: {
            args: Prisma.PaymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          deleteMany: {
            args: Prisma.PaymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PaymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.PaymentUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>[]
          }
          upsert: {
            args: Prisma.PaymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PaymentPayload>
          }
          aggregate: {
            args: Prisma.PaymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayment>
          }
          groupBy: {
            args: Prisma.PaymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<PaymentGroupByOutputType>[]
          }
          count: {
            args: Prisma.PaymentCountArgs<ExtArgs>
            result: $Utils.Optional<PaymentCountAggregateOutputType> | number
          }
        }
      }
      Todo: {
        payload: Prisma.$TodoPayload<ExtArgs>
        fields: Prisma.TodoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TodoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TodoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>
          }
          findFirst: {
            args: Prisma.TodoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TodoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>
          }
          findMany: {
            args: Prisma.TodoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>[]
          }
          create: {
            args: Prisma.TodoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>
          }
          createMany: {
            args: Prisma.TodoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TodoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>[]
          }
          delete: {
            args: Prisma.TodoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>
          }
          update: {
            args: Prisma.TodoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>
          }
          deleteMany: {
            args: Prisma.TodoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TodoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.TodoUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>[]
          }
          upsert: {
            args: Prisma.TodoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TodoPayload>
          }
          aggregate: {
            args: Prisma.TodoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTodo>
          }
          groupBy: {
            args: Prisma.TodoGroupByArgs<ExtArgs>
            result: $Utils.Optional<TodoGroupByOutputType>[]
          }
          count: {
            args: Prisma.TodoCountArgs<ExtArgs>
            result: $Utils.Optional<TodoCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.EventUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Message: {
        payload: Prisma.$MessagePayload<ExtArgs>
        fields: Prisma.MessageFieldRefs
        operations: {
          findUnique: {
            args: Prisma.MessageFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.MessageFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findFirst: {
            args: Prisma.MessageFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.MessageFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          findMany: {
            args: Prisma.MessageFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          create: {
            args: Prisma.MessageCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          createMany: {
            args: Prisma.MessageCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.MessageCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          delete: {
            args: Prisma.MessageDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          update: {
            args: Prisma.MessageUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          deleteMany: {
            args: Prisma.MessageDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.MessageUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.MessageUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>[]
          }
          upsert: {
            args: Prisma.MessageUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$MessagePayload>
          }
          aggregate: {
            args: Prisma.MessageAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateMessage>
          }
          groupBy: {
            args: Prisma.MessageGroupByArgs<ExtArgs>
            result: $Utils.Optional<MessageGroupByOutputType>[]
          }
          count: {
            args: Prisma.MessageCountArgs<ExtArgs>
            result: $Utils.Optional<MessageCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.NotificationUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      File: {
        payload: Prisma.$FilePayload<ExtArgs>
        fields: Prisma.FileFieldRefs
        operations: {
          findUnique: {
            args: Prisma.FileFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.FileFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findFirst: {
            args: Prisma.FileFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.FileFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          findMany: {
            args: Prisma.FileFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          create: {
            args: Prisma.FileCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          createMany: {
            args: Prisma.FileCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.FileCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          delete: {
            args: Prisma.FileDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          update: {
            args: Prisma.FileUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          deleteMany: {
            args: Prisma.FileDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.FileUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateManyAndReturn: {
            args: Prisma.FileUpdateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>[]
          }
          upsert: {
            args: Prisma.FileUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$FilePayload>
          }
          aggregate: {
            args: Prisma.FileAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateFile>
          }
          groupBy: {
            args: Prisma.FileGroupByArgs<ExtArgs>
            result: $Utils.Optional<FileGroupByOutputType>[]
          }
          count: {
            args: Prisma.FileCountArgs<ExtArgs>
            result: $Utils.Optional<FileCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://pris.ly/d/logging).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
    /**
     * Instance of a Driver Adapter, e.g., like one provided by `@prisma/adapter-planetscale`
     */
    adapter?: runtime.SqlDriverAdapterFactory
    /**
     * Prisma Accelerate URL allowing the client to connect through Accelerate instead of a direct database.
     */
    accelerateUrl?: string
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
    /**
     * SQL commenter plugins that add metadata to SQL queries as comments.
     * Comments follow the sqlcommenter format: https://google.github.io/sqlcommenter/
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   adapter,
     *   comments: [
     *     traceContext(),
     *     queryInsights(),
     *   ],
     * })
     * ```
     */
    comments?: runtime.SqlCommenterPlugin[]
  }
  export type GlobalOmitConfig = {
    user?: UserOmit
    userSettings?: UserSettingsOmit
    account?: AccountOmit
    session?: SessionOmit
    verificationToken?: VerificationTokenOmit
    passwordResetToken?: PasswordResetTokenOmit
    emailChangeRequest?: EmailChangeRequestOmit
    device?: DeviceOmit
    teacherProfile?: TeacherProfileOmit
    studentProfile?: StudentProfileOmit
    studentTeacherRelation?: StudentTeacherRelationOmit
    classroom?: ClassroomOmit
    scheduleItem?: ScheduleItemOmit
    lesson?: LessonOmit
    material?: MaterialOmit
    homework?: HomeworkOmit
    homeworkTracking?: HomeworkTrackingOmit
    homeworkSubmission?: HomeworkSubmissionOmit
    schoolExam?: SchoolExamOmit
    trialExam?: TrialExamOmit
    trialExamResult?: TrialExamResultOmit
    attendance?: AttendanceOmit
    payment?: PaymentOmit
    todo?: TodoOmit
    event?: EventOmit
    message?: MessageOmit
    notification?: NotificationOmit
    file?: FileOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    accounts: number
    sessions: number
    emailChangeRequests: number
    devices: number
    notifications: number
    sentMessages: number
    receivedMessages: number
    todos: number
    calendarEvents: number
    files: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    accounts?: boolean | UserCountOutputTypeCountAccountsArgs
    sessions?: boolean | UserCountOutputTypeCountSessionsArgs
    emailChangeRequests?: boolean | UserCountOutputTypeCountEmailChangeRequestsArgs
    devices?: boolean | UserCountOutputTypeCountDevicesArgs
    notifications?: boolean | UserCountOutputTypeCountNotificationsArgs
    sentMessages?: boolean | UserCountOutputTypeCountSentMessagesArgs
    receivedMessages?: boolean | UserCountOutputTypeCountReceivedMessagesArgs
    todos?: boolean | UserCountOutputTypeCountTodosArgs
    calendarEvents?: boolean | UserCountOutputTypeCountCalendarEventsArgs
    files?: boolean | UserCountOutputTypeCountFilesArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAccountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailChangeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailChangeRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDevicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountNotificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountReceivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTodosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TodoWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCalendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountFilesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
  }


  /**
   * Count Type TeacherProfileCountOutputType
   */

  export type TeacherProfileCountOutputType = {
    studentRelations: number
    classes: number
    lessons: number
    payments: number
    scheduleItems: number
  }

  export type TeacherProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    studentRelations?: boolean | TeacherProfileCountOutputTypeCountStudentRelationsArgs
    classes?: boolean | TeacherProfileCountOutputTypeCountClassesArgs
    lessons?: boolean | TeacherProfileCountOutputTypeCountLessonsArgs
    payments?: boolean | TeacherProfileCountOutputTypeCountPaymentsArgs
    scheduleItems?: boolean | TeacherProfileCountOutputTypeCountScheduleItemsArgs
  }

  // Custom InputTypes
  /**
   * TeacherProfileCountOutputType without action
   */
  export type TeacherProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfileCountOutputType
     */
    select?: TeacherProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeacherProfileCountOutputType without action
   */
  export type TeacherProfileCountOutputTypeCountStudentRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTeacherRelationWhereInput
  }

  /**
   * TeacherProfileCountOutputType without action
   */
  export type TeacherProfileCountOutputTypeCountClassesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomWhereInput
  }

  /**
   * TeacherProfileCountOutputType without action
   */
  export type TeacherProfileCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * TeacherProfileCountOutputType without action
   */
  export type TeacherProfileCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * TeacherProfileCountOutputType without action
   */
  export type TeacherProfileCountOutputTypeCountScheduleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleItemWhereInput
  }


  /**
   * Count Type StudentProfileCountOutputType
   */

  export type StudentProfileCountOutputType = {
    teacherRelations: number
    classrooms: number
    recurringSchedules: number
    lessons: number
    homeworkTrackings: number
    submissions: number
    payments: number
    grades: number
    trialExams: number
    attendances: number
  }

  export type StudentProfileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacherRelations?: boolean | StudentProfileCountOutputTypeCountTeacherRelationsArgs
    classrooms?: boolean | StudentProfileCountOutputTypeCountClassroomsArgs
    recurringSchedules?: boolean | StudentProfileCountOutputTypeCountRecurringSchedulesArgs
    lessons?: boolean | StudentProfileCountOutputTypeCountLessonsArgs
    homeworkTrackings?: boolean | StudentProfileCountOutputTypeCountHomeworkTrackingsArgs
    submissions?: boolean | StudentProfileCountOutputTypeCountSubmissionsArgs
    payments?: boolean | StudentProfileCountOutputTypeCountPaymentsArgs
    grades?: boolean | StudentProfileCountOutputTypeCountGradesArgs
    trialExams?: boolean | StudentProfileCountOutputTypeCountTrialExamsArgs
    attendances?: boolean | StudentProfileCountOutputTypeCountAttendancesArgs
  }

  // Custom InputTypes
  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfileCountOutputType
     */
    select?: StudentProfileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountTeacherRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTeacherRelationWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountClassroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountRecurringSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleItemWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountHomeworkTrackingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeworkTrackingWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeworkSubmissionWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountGradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolExamWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountTrialExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrialExamWhereInput
  }

  /**
   * StudentProfileCountOutputType without action
   */
  export type StudentProfileCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }


  /**
   * Count Type ClassroomCountOutputType
   */

  export type ClassroomCountOutputType = {
    students: number
    schedule: number
    lessons: number
  }

  export type ClassroomCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | ClassroomCountOutputTypeCountStudentsArgs
    schedule?: boolean | ClassroomCountOutputTypeCountScheduleArgs
    lessons?: boolean | ClassroomCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ClassroomCountOutputType
     */
    select?: ClassroomCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentProfileWhereInput
  }

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountScheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleItemWhereInput
  }

  /**
   * ClassroomCountOutputType without action
   */
  export type ClassroomCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }


  /**
   * Count Type ScheduleItemCountOutputType
   */

  export type ScheduleItemCountOutputType = {
    lessons: number
  }

  export type ScheduleItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | ScheduleItemCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * ScheduleItemCountOutputType without action
   */
  export type ScheduleItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItemCountOutputType
     */
    select?: ScheduleItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ScheduleItemCountOutputType without action
   */
  export type ScheduleItemCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }


  /**
   * Count Type LessonCountOutputType
   */

  export type LessonCountOutputType = {
    students: number
    attendances: number
    homeworks: number
    materials: number
    payments: number
  }

  export type LessonCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    students?: boolean | LessonCountOutputTypeCountStudentsArgs
    attendances?: boolean | LessonCountOutputTypeCountAttendancesArgs
    homeworks?: boolean | LessonCountOutputTypeCountHomeworksArgs
    materials?: boolean | LessonCountOutputTypeCountMaterialsArgs
    payments?: boolean | LessonCountOutputTypeCountPaymentsArgs
  }

  // Custom InputTypes
  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LessonCountOutputType
     */
    select?: LessonCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountStudentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentProfileWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountAttendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountHomeworksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeworkWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * LessonCountOutputType without action
   */
  export type LessonCountOutputTypeCountPaymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
  }


  /**
   * Count Type HomeworkCountOutputType
   */

  export type HomeworkCountOutputType = {
    trackings: number
  }

  export type HomeworkCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trackings?: boolean | HomeworkCountOutputTypeCountTrackingsArgs
  }

  // Custom InputTypes
  /**
   * HomeworkCountOutputType without action
   */
  export type HomeworkCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkCountOutputType
     */
    select?: HomeworkCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * HomeworkCountOutputType without action
   */
  export type HomeworkCountOutputTypeCountTrackingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeworkTrackingWhereInput
  }


  /**
   * Count Type TrialExamCountOutputType
   */

  export type TrialExamCountOutputType = {
    results: number
  }

  export type TrialExamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    results?: boolean | TrialExamCountOutputTypeCountResultsArgs
  }

  // Custom InputTypes
  /**
   * TrialExamCountOutputType without action
   */
  export type TrialExamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamCountOutputType
     */
    select?: TrialExamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TrialExamCountOutputType without action
   */
  export type TrialExamCountOutputTypeCountResultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrialExamResultWhereInput
  }


  /**
   * Count Type PaymentCountOutputType
   */

  export type PaymentCountOutputType = {
    lessons: number
  }

  export type PaymentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lessons?: boolean | PaymentCountOutputTypeCountLessonsArgs
  }

  // Custom InputTypes
  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PaymentCountOutputType
     */
    select?: PaymentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PaymentCountOutputType without action
   */
  export type PaymentCountOutputTypeCountLessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
  }


  /**
   * Count Type FileCountOutputType
   */

  export type FileCountOutputType = {
    materials: number
    messages: number
    homeworkTrackings: number
    homeworkSubmissions: number
  }

  export type FileCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    materials?: boolean | FileCountOutputTypeCountMaterialsArgs
    messages?: boolean | FileCountOutputTypeCountMessagesArgs
    homeworkTrackings?: boolean | FileCountOutputTypeCountHomeworkTrackingsArgs
    homeworkSubmissions?: boolean | FileCountOutputTypeCountHomeworkSubmissionsArgs
  }

  // Custom InputTypes
  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the FileCountOutputType
     */
    select?: FileCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountMaterialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountHomeworkTrackingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeworkTrackingWhereInput
  }

  /**
   * FileCountOutputType without action
   */
  export type FileCountOutputTypeCountHomeworkSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeworkSubmissionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    avatarVersion: number | null
  }

  export type UserSumAggregateOutputType = {
    avatarVersion: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    name: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    avatarVersion: number | null
    password: string | null
    phoneNumber: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    role: $Enums.Role | null
    isActive: boolean | null
    isOnboardingCompleted: boolean | null
    notificationEmailEnabled: boolean | null
    notificationInAppEnabled: boolean | null
    preferredCountry: string | null
    preferredTimezone: string | null
    cookieAnalyticsEnabled: boolean | null
    isMarketingConsent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    name: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    avatarVersion: number | null
    password: string | null
    phoneNumber: string | null
    isDeleted: boolean | null
    deletedAt: Date | null
    role: $Enums.Role | null
    isActive: boolean | null
    isOnboardingCompleted: boolean | null
    notificationEmailEnabled: boolean | null
    notificationInAppEnabled: boolean | null
    preferredCountry: string | null
    preferredTimezone: string | null
    cookieAnalyticsEnabled: boolean | null
    isMarketingConsent: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    name: number
    firstName: number
    lastName: number
    username: number
    email: number
    emailVerified: number
    image: number
    avatarVersion: number
    password: number
    phoneNumber: number
    isDeleted: number
    deletedAt: number
    role: number
    isActive: number
    isOnboardingCompleted: number
    notificationEmailEnabled: number
    notificationInAppEnabled: number
    preferredCountry: number
    preferredTimezone: number
    cookieAnalyticsEnabled: number
    isMarketingConsent: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    avatarVersion?: true
  }

  export type UserSumAggregateInputType = {
    avatarVersion?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    username?: true
    email?: true
    emailVerified?: true
    image?: true
    avatarVersion?: true
    password?: true
    phoneNumber?: true
    isDeleted?: true
    deletedAt?: true
    role?: true
    isActive?: true
    isOnboardingCompleted?: true
    notificationEmailEnabled?: true
    notificationInAppEnabled?: true
    preferredCountry?: true
    preferredTimezone?: true
    cookieAnalyticsEnabled?: true
    isMarketingConsent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    username?: true
    email?: true
    emailVerified?: true
    image?: true
    avatarVersion?: true
    password?: true
    phoneNumber?: true
    isDeleted?: true
    deletedAt?: true
    role?: true
    isActive?: true
    isOnboardingCompleted?: true
    notificationEmailEnabled?: true
    notificationInAppEnabled?: true
    preferredCountry?: true
    preferredTimezone?: true
    cookieAnalyticsEnabled?: true
    isMarketingConsent?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    name?: true
    firstName?: true
    lastName?: true
    username?: true
    email?: true
    emailVerified?: true
    image?: true
    avatarVersion?: true
    password?: true
    phoneNumber?: true
    isDeleted?: true
    deletedAt?: true
    role?: true
    isActive?: true
    isOnboardingCompleted?: true
    notificationEmailEnabled?: true
    notificationInAppEnabled?: true
    preferredCountry?: true
    preferredTimezone?: true
    cookieAnalyticsEnabled?: true
    isMarketingConsent?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    name: string | null
    firstName: string | null
    lastName: string | null
    username: string | null
    email: string | null
    emailVerified: Date | null
    image: string | null
    avatarVersion: number
    password: string | null
    phoneNumber: string | null
    isDeleted: boolean
    deletedAt: Date | null
    role: $Enums.Role | null
    isActive: boolean
    isOnboardingCompleted: boolean
    notificationEmailEnabled: boolean
    notificationInAppEnabled: boolean
    preferredCountry: string | null
    preferredTimezone: string | null
    cookieAnalyticsEnabled: boolean
    isMarketingConsent: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    avatarVersion?: boolean
    password?: boolean
    phoneNumber?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    role?: boolean
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: boolean
    preferredTimezone?: boolean
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    settings?: boolean | User$settingsArgs<ExtArgs>
    teacherProfile?: boolean | User$teacherProfileArgs<ExtArgs>
    studentProfile?: boolean | User$studentProfileArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    emailChangeRequests?: boolean | User$emailChangeRequestsArgs<ExtArgs>
    devices?: boolean | User$devicesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    todos?: boolean | User$todosArgs<ExtArgs>
    calendarEvents?: boolean | User$calendarEventsArgs<ExtArgs>
    files?: boolean | User$filesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    avatarVersion?: boolean
    password?: boolean
    phoneNumber?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    role?: boolean
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: boolean
    preferredTimezone?: boolean
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    avatarVersion?: boolean
    password?: boolean
    phoneNumber?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    role?: boolean
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: boolean
    preferredTimezone?: boolean
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    name?: boolean
    firstName?: boolean
    lastName?: boolean
    username?: boolean
    email?: boolean
    emailVerified?: boolean
    image?: boolean
    avatarVersion?: boolean
    password?: boolean
    phoneNumber?: boolean
    isDeleted?: boolean
    deletedAt?: boolean
    role?: boolean
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: boolean
    preferredTimezone?: boolean
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "firstName" | "lastName" | "username" | "email" | "emailVerified" | "image" | "avatarVersion" | "password" | "phoneNumber" | "isDeleted" | "deletedAt" | "role" | "isActive" | "isOnboardingCompleted" | "notificationEmailEnabled" | "notificationInAppEnabled" | "preferredCountry" | "preferredTimezone" | "cookieAnalyticsEnabled" | "isMarketingConsent" | "createdAt" | "updatedAt", ExtArgs["result"]["user"]>
  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    settings?: boolean | User$settingsArgs<ExtArgs>
    teacherProfile?: boolean | User$teacherProfileArgs<ExtArgs>
    studentProfile?: boolean | User$studentProfileArgs<ExtArgs>
    accounts?: boolean | User$accountsArgs<ExtArgs>
    sessions?: boolean | User$sessionsArgs<ExtArgs>
    emailChangeRequests?: boolean | User$emailChangeRequestsArgs<ExtArgs>
    devices?: boolean | User$devicesArgs<ExtArgs>
    notifications?: boolean | User$notificationsArgs<ExtArgs>
    sentMessages?: boolean | User$sentMessagesArgs<ExtArgs>
    receivedMessages?: boolean | User$receivedMessagesArgs<ExtArgs>
    todos?: boolean | User$todosArgs<ExtArgs>
    calendarEvents?: boolean | User$calendarEventsArgs<ExtArgs>
    files?: boolean | User$filesArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}
  export type UserIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      settings: Prisma.$UserSettingsPayload<ExtArgs> | null
      teacherProfile: Prisma.$TeacherProfilePayload<ExtArgs> | null
      studentProfile: Prisma.$StudentProfilePayload<ExtArgs> | null
      accounts: Prisma.$AccountPayload<ExtArgs>[]
      sessions: Prisma.$SessionPayload<ExtArgs>[]
      emailChangeRequests: Prisma.$EmailChangeRequestPayload<ExtArgs>[]
      devices: Prisma.$DevicePayload<ExtArgs>[]
      notifications: Prisma.$NotificationPayload<ExtArgs>[]
      sentMessages: Prisma.$MessagePayload<ExtArgs>[]
      receivedMessages: Prisma.$MessagePayload<ExtArgs>[]
      todos: Prisma.$TodoPayload<ExtArgs>[]
      calendarEvents: Prisma.$EventPayload<ExtArgs>[]
      files: Prisma.$FilePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string | null
      firstName: string | null
      lastName: string | null
      username: string | null
      email: string | null
      emailVerified: Date | null
      image: string | null
      avatarVersion: number
      password: string | null
      phoneNumber: string | null
      isDeleted: boolean
      deletedAt: Date | null
      role: $Enums.Role | null
      isActive: boolean
      isOnboardingCompleted: boolean
      notificationEmailEnabled: boolean
      notificationInAppEnabled: boolean
      preferredCountry: string | null
      preferredTimezone: string | null
      cookieAnalyticsEnabled: boolean
      isMarketingConsent: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users and returns the data updated in the database.
     * @param {UserUpdateManyAndReturnArgs} args - Arguments to update many Users.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Users and only return the `id`
     * const userWithIdOnly = await prisma.user.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserUpdateManyAndReturnArgs>(args: SelectSubset<T, UserUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    settings<T extends User$settingsArgs<ExtArgs> = {}>(args?: Subset<T, User$settingsArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacherProfile<T extends User$teacherProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$teacherProfileArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    studentProfile<T extends User$studentProfileArgs<ExtArgs> = {}>(args?: Subset<T, User$studentProfileArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    accounts<T extends User$accountsArgs<ExtArgs> = {}>(args?: Subset<T, User$accountsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sessions<T extends User$sessionsArgs<ExtArgs> = {}>(args?: Subset<T, User$sessionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    emailChangeRequests<T extends User$emailChangeRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$emailChangeRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailChangeRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    devices<T extends User$devicesArgs<ExtArgs> = {}>(args?: Subset<T, User$devicesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    notifications<T extends User$notificationsArgs<ExtArgs> = {}>(args?: Subset<T, User$notificationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    sentMessages<T extends User$sentMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$sentMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    receivedMessages<T extends User$receivedMessagesArgs<ExtArgs> = {}>(args?: Subset<T, User$receivedMessagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    todos<T extends User$todosArgs<ExtArgs> = {}>(args?: Subset<T, User$todosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    calendarEvents<T extends User$calendarEventsArgs<ExtArgs> = {}>(args?: Subset<T, User$calendarEventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    files<T extends User$filesArgs<ExtArgs> = {}>(args?: Subset<T, User$filesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly name: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly username: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly emailVerified: FieldRef<"User", 'DateTime'>
    readonly image: FieldRef<"User", 'String'>
    readonly avatarVersion: FieldRef<"User", 'Int'>
    readonly password: FieldRef<"User", 'String'>
    readonly phoneNumber: FieldRef<"User", 'String'>
    readonly isDeleted: FieldRef<"User", 'Boolean'>
    readonly deletedAt: FieldRef<"User", 'DateTime'>
    readonly role: FieldRef<"User", 'Role'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly isOnboardingCompleted: FieldRef<"User", 'Boolean'>
    readonly notificationEmailEnabled: FieldRef<"User", 'Boolean'>
    readonly notificationInAppEnabled: FieldRef<"User", 'Boolean'>
    readonly preferredCountry: FieldRef<"User", 'String'>
    readonly preferredTimezone: FieldRef<"User", 'String'>
    readonly cookieAnalyticsEnabled: FieldRef<"User", 'Boolean'>
    readonly isMarketingConsent: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User updateManyAndReturn
   */
  export type UserUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to update.
     */
    limit?: number
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
    /**
     * Limit how many Users to delete.
     */
    limit?: number
  }

  /**
   * User.settings
   */
  export type User$settingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    where?: UserSettingsWhereInput
  }

  /**
   * User.teacherProfile
   */
  export type User$teacherProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    where?: TeacherProfileWhereInput
  }

  /**
   * User.studentProfile
   */
  export type User$studentProfileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    where?: StudentProfileWhereInput
  }

  /**
   * User.accounts
   */
  export type User$accountsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    cursor?: AccountWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * User.sessions
   */
  export type User$sessionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    cursor?: SessionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * User.emailChangeRequests
   */
  export type User$emailChangeRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestInclude<ExtArgs> | null
    where?: EmailChangeRequestWhereInput
    orderBy?: EmailChangeRequestOrderByWithRelationInput | EmailChangeRequestOrderByWithRelationInput[]
    cursor?: EmailChangeRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailChangeRequestScalarFieldEnum | EmailChangeRequestScalarFieldEnum[]
  }

  /**
   * User.devices
   */
  export type User$devicesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    cursor?: DeviceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * User.notifications
   */
  export type User$notificationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * User.sentMessages
   */
  export type User$sentMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.receivedMessages
   */
  export type User$receivedMessagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * User.todos
   */
  export type User$todosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    where?: TodoWhereInput
    orderBy?: TodoOrderByWithRelationInput | TodoOrderByWithRelationInput[]
    cursor?: TodoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TodoScalarFieldEnum | TodoScalarFieldEnum[]
  }

  /**
   * User.calendarEvents
   */
  export type User$calendarEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User.files
   */
  export type User$filesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    cursor?: FileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model UserSettings
   */

  export type AggregateUserSettings = {
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  export type UserSettingsMinAggregateOutputType = {
    id: string | null
    userId: string | null
    profileVisibility: string | null
    showAvatar: boolean | null
    showEmail: boolean | null
    showPhone: boolean | null
    allowMessages: boolean | null
    showCourses: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    profileVisibility: string | null
    showAvatar: boolean | null
    showEmail: boolean | null
    showPhone: boolean | null
    allowMessages: boolean | null
    showCourses: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserSettingsCountAggregateOutputType = {
    id: number
    userId: number
    profileVisibility: number
    showAvatar: number
    showEmail: number
    showPhone: number
    allowMessages: number
    showCourses: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserSettingsMinAggregateInputType = {
    id?: true
    userId?: true
    profileVisibility?: true
    showAvatar?: true
    showEmail?: true
    showPhone?: true
    allowMessages?: true
    showCourses?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsMaxAggregateInputType = {
    id?: true
    userId?: true
    profileVisibility?: true
    showAvatar?: true
    showEmail?: true
    showPhone?: true
    allowMessages?: true
    showCourses?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserSettingsCountAggregateInputType = {
    id?: true
    userId?: true
    profileVisibility?: true
    showAvatar?: true
    showEmail?: true
    showPhone?: true
    allowMessages?: true
    showCourses?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserSettingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to aggregate.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserSettings
    **/
    _count?: true | UserSettingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserSettingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserSettingsMaxAggregateInputType
  }

  export type GetUserSettingsAggregateType<T extends UserSettingsAggregateArgs> = {
        [P in keyof T & keyof AggregateUserSettings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserSettings[P]>
      : GetScalarType<T[P], AggregateUserSettings[P]>
  }




  export type UserSettingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserSettingsWhereInput
    orderBy?: UserSettingsOrderByWithAggregationInput | UserSettingsOrderByWithAggregationInput[]
    by: UserSettingsScalarFieldEnum[] | UserSettingsScalarFieldEnum
    having?: UserSettingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserSettingsCountAggregateInputType | true
    _min?: UserSettingsMinAggregateInputType
    _max?: UserSettingsMaxAggregateInputType
  }

  export type UserSettingsGroupByOutputType = {
    id: string
    userId: string
    profileVisibility: string
    showAvatar: boolean
    showEmail: boolean
    showPhone: boolean
    allowMessages: boolean
    showCourses: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserSettingsCountAggregateOutputType | null
    _min: UserSettingsMinAggregateOutputType | null
    _max: UserSettingsMaxAggregateOutputType | null
  }

  type GetUserSettingsGroupByPayload<T extends UserSettingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserSettingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserSettingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
            : GetScalarType<T[P], UserSettingsGroupByOutputType[P]>
        }
      >
    >


  export type UserSettingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileVisibility?: boolean
    showAvatar?: boolean
    showEmail?: boolean
    showPhone?: boolean
    allowMessages?: boolean
    showCourses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileVisibility?: boolean
    showAvatar?: boolean
    showEmail?: boolean
    showPhone?: boolean
    allowMessages?: boolean
    showCourses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    profileVisibility?: boolean
    showAvatar?: boolean
    showEmail?: boolean
    showPhone?: boolean
    allowMessages?: boolean
    showCourses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userSettings"]>

  export type UserSettingsSelectScalar = {
    id?: boolean
    userId?: boolean
    profileVisibility?: boolean
    showAvatar?: boolean
    showEmail?: boolean
    showPhone?: boolean
    allowMessages?: boolean
    showCourses?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserSettingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "profileVisibility" | "showAvatar" | "showEmail" | "showPhone" | "allowMessages" | "showCourses" | "createdAt" | "updatedAt", ExtArgs["result"]["userSettings"]>
  export type UserSettingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type UserSettingsIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserSettingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserSettings"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      profileVisibility: string
      showAvatar: boolean
      showEmail: boolean
      showPhone: boolean
      allowMessages: boolean
      showCourses: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["userSettings"]>
    composites: {}
  }

  type UserSettingsGetPayload<S extends boolean | null | undefined | UserSettingsDefaultArgs> = $Result.GetResult<Prisma.$UserSettingsPayload, S>

  type UserSettingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<UserSettingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UserSettingsCountAggregateInputType | true
    }

  export interface UserSettingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserSettings'], meta: { name: 'UserSettings' } }
    /**
     * Find zero or one UserSettings that matches the filter.
     * @param {UserSettingsFindUniqueArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserSettingsFindUniqueArgs>(args: SelectSubset<T, UserSettingsFindUniqueArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one UserSettings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {UserSettingsFindUniqueOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserSettingsFindUniqueOrThrowArgs>(args: SelectSubset<T, UserSettingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserSettingsFindFirstArgs>(args?: SelectSubset<T, UserSettingsFindFirstArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first UserSettings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindFirstOrThrowArgs} args - Arguments to find a UserSettings
     * @example
     * // Get one UserSettings
     * const userSettings = await prisma.userSettings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserSettingsFindFirstOrThrowArgs>(args?: SelectSubset<T, UserSettingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more UserSettings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserSettings
     * const userSettings = await prisma.userSettings.findMany()
     * 
     * // Get first 10 UserSettings
     * const userSettings = await prisma.userSettings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserSettingsFindManyArgs>(args?: SelectSubset<T, UserSettingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a UserSettings.
     * @param {UserSettingsCreateArgs} args - Arguments to create a UserSettings.
     * @example
     * // Create one UserSettings
     * const UserSettings = await prisma.userSettings.create({
     *   data: {
     *     // ... data to create a UserSettings
     *   }
     * })
     * 
     */
    create<T extends UserSettingsCreateArgs>(args: SelectSubset<T, UserSettingsCreateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many UserSettings.
     * @param {UserSettingsCreateManyArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserSettingsCreateManyArgs>(args?: SelectSubset<T, UserSettingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many UserSettings and returns the data saved in the database.
     * @param {UserSettingsCreateManyAndReturnArgs} args - Arguments to create many UserSettings.
     * @example
     * // Create many UserSettings
     * const userSettings = await prisma.userSettings.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserSettingsCreateManyAndReturnArgs>(args?: SelectSubset<T, UserSettingsCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a UserSettings.
     * @param {UserSettingsDeleteArgs} args - Arguments to delete one UserSettings.
     * @example
     * // Delete one UserSettings
     * const UserSettings = await prisma.userSettings.delete({
     *   where: {
     *     // ... filter to delete one UserSettings
     *   }
     * })
     * 
     */
    delete<T extends UserSettingsDeleteArgs>(args: SelectSubset<T, UserSettingsDeleteArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one UserSettings.
     * @param {UserSettingsUpdateArgs} args - Arguments to update one UserSettings.
     * @example
     * // Update one UserSettings
     * const userSettings = await prisma.userSettings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserSettingsUpdateArgs>(args: SelectSubset<T, UserSettingsUpdateArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more UserSettings.
     * @param {UserSettingsDeleteManyArgs} args - Arguments to filter UserSettings to delete.
     * @example
     * // Delete a few UserSettings
     * const { count } = await prisma.userSettings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserSettingsDeleteManyArgs>(args?: SelectSubset<T, UserSettingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserSettingsUpdateManyArgs>(args: SelectSubset<T, UserSettingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserSettings and returns the data updated in the database.
     * @param {UserSettingsUpdateManyAndReturnArgs} args - Arguments to update many UserSettings.
     * @example
     * // Update many UserSettings
     * const userSettings = await prisma.userSettings.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more UserSettings and only return the `id`
     * const userSettingsWithIdOnly = await prisma.userSettings.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends UserSettingsUpdateManyAndReturnArgs>(args: SelectSubset<T, UserSettingsUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one UserSettings.
     * @param {UserSettingsUpsertArgs} args - Arguments to update or create a UserSettings.
     * @example
     * // Update or create a UserSettings
     * const userSettings = await prisma.userSettings.upsert({
     *   create: {
     *     // ... data to create a UserSettings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserSettings we want to update
     *   }
     * })
     */
    upsert<T extends UserSettingsUpsertArgs>(args: SelectSubset<T, UserSettingsUpsertArgs<ExtArgs>>): Prisma__UserSettingsClient<$Result.GetResult<Prisma.$UserSettingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsCountArgs} args - Arguments to filter UserSettings to count.
     * @example
     * // Count the number of UserSettings
     * const count = await prisma.userSettings.count({
     *   where: {
     *     // ... the filter for the UserSettings we want to count
     *   }
     * })
    **/
    count<T extends UserSettingsCountArgs>(
      args?: Subset<T, UserSettingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserSettingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserSettingsAggregateArgs>(args: Subset<T, UserSettingsAggregateArgs>): Prisma.PrismaPromise<GetUserSettingsAggregateType<T>>

    /**
     * Group by UserSettings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserSettingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserSettingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserSettingsGroupByArgs['orderBy'] }
        : { orderBy?: UserSettingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserSettingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserSettingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserSettings model
   */
  readonly fields: UserSettingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserSettings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserSettingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserSettings model
   */
  interface UserSettingsFieldRefs {
    readonly id: FieldRef<"UserSettings", 'String'>
    readonly userId: FieldRef<"UserSettings", 'String'>
    readonly profileVisibility: FieldRef<"UserSettings", 'String'>
    readonly showAvatar: FieldRef<"UserSettings", 'Boolean'>
    readonly showEmail: FieldRef<"UserSettings", 'Boolean'>
    readonly showPhone: FieldRef<"UserSettings", 'Boolean'>
    readonly allowMessages: FieldRef<"UserSettings", 'Boolean'>
    readonly showCourses: FieldRef<"UserSettings", 'Boolean'>
    readonly createdAt: FieldRef<"UserSettings", 'DateTime'>
    readonly updatedAt: FieldRef<"UserSettings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserSettings findUnique
   */
  export type UserSettingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findUniqueOrThrow
   */
  export type UserSettingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings findFirst
   */
  export type UserSettingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findFirstOrThrow
   */
  export type UserSettingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserSettings.
     */
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings findMany
   */
  export type UserSettingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter, which UserSettings to fetch.
     */
    where?: UserSettingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserSettings to fetch.
     */
    orderBy?: UserSettingsOrderByWithRelationInput | UserSettingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserSettings.
     */
    cursor?: UserSettingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` UserSettings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserSettings.
     */
    skip?: number
    distinct?: UserSettingsScalarFieldEnum | UserSettingsScalarFieldEnum[]
  }

  /**
   * UserSettings create
   */
  export type UserSettingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to create a UserSettings.
     */
    data: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
  }

  /**
   * UserSettings createMany
   */
  export type UserSettingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserSettings createManyAndReturn
   */
  export type UserSettingsCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to create many UserSettings.
     */
    data: UserSettingsCreateManyInput | UserSettingsCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings update
   */
  export type UserSettingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The data needed to update a UserSettings.
     */
    data: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
    /**
     * Choose, which UserSettings to update.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings updateMany
   */
  export type UserSettingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
  }

  /**
   * UserSettings updateManyAndReturn
   */
  export type UserSettingsUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * The data used to update UserSettings.
     */
    data: XOR<UserSettingsUpdateManyMutationInput, UserSettingsUncheckedUpdateManyInput>
    /**
     * Filter which UserSettings to update
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * UserSettings upsert
   */
  export type UserSettingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * The filter to search for the UserSettings to update in case it exists.
     */
    where: UserSettingsWhereUniqueInput
    /**
     * In case the UserSettings found by the `where` argument doesn't exist, create a new UserSettings with this data.
     */
    create: XOR<UserSettingsCreateInput, UserSettingsUncheckedCreateInput>
    /**
     * In case the UserSettings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserSettingsUpdateInput, UserSettingsUncheckedUpdateInput>
  }

  /**
   * UserSettings delete
   */
  export type UserSettingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
    /**
     * Filter which UserSettings to delete.
     */
    where: UserSettingsWhereUniqueInput
  }

  /**
   * UserSettings deleteMany
   */
  export type UserSettingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserSettings to delete
     */
    where?: UserSettingsWhereInput
    /**
     * Limit how many UserSettings to delete.
     */
    limit?: number
  }

  /**
   * UserSettings without action
   */
  export type UserSettingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserSettings
     */
    select?: UserSettingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the UserSettings
     */
    omit?: UserSettingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserSettingsInclude<ExtArgs> | null
  }


  /**
   * Model Account
   */

  export type AggregateAccount = {
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  export type AccountAvgAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountSumAggregateOutputType = {
    expires_at: number | null
  }

  export type AccountMinAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    type: string | null
    provider: string | null
    providerAccountId: string | null
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
  }

  export type AccountCountAggregateOutputType = {
    id: number
    userId: number
    type: number
    provider: number
    providerAccountId: number
    refresh_token: number
    access_token: number
    expires_at: number
    token_type: number
    scope: number
    id_token: number
    session_state: number
    _all: number
  }


  export type AccountAvgAggregateInputType = {
    expires_at?: true
  }

  export type AccountSumAggregateInputType = {
    expires_at?: true
  }

  export type AccountMinAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountMaxAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
  }

  export type AccountCountAggregateInputType = {
    id?: true
    userId?: true
    type?: true
    provider?: true
    providerAccountId?: true
    refresh_token?: true
    access_token?: true
    expires_at?: true
    token_type?: true
    scope?: true
    id_token?: true
    session_state?: true
    _all?: true
  }

  export type AccountAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Account to aggregate.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Accounts
    **/
    _count?: true | AccountCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AccountAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AccountSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AccountMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AccountMaxAggregateInputType
  }

  export type GetAccountAggregateType<T extends AccountAggregateArgs> = {
        [P in keyof T & keyof AggregateAccount]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAccount[P]>
      : GetScalarType<T[P], AggregateAccount[P]>
  }




  export type AccountGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AccountWhereInput
    orderBy?: AccountOrderByWithAggregationInput | AccountOrderByWithAggregationInput[]
    by: AccountScalarFieldEnum[] | AccountScalarFieldEnum
    having?: AccountScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AccountCountAggregateInputType | true
    _avg?: AccountAvgAggregateInputType
    _sum?: AccountSumAggregateInputType
    _min?: AccountMinAggregateInputType
    _max?: AccountMaxAggregateInputType
  }

  export type AccountGroupByOutputType = {
    id: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token: string | null
    access_token: string | null
    expires_at: number | null
    token_type: string | null
    scope: string | null
    id_token: string | null
    session_state: string | null
    _count: AccountCountAggregateOutputType | null
    _avg: AccountAvgAggregateOutputType | null
    _sum: AccountSumAggregateOutputType | null
    _min: AccountMinAggregateOutputType | null
    _max: AccountMaxAggregateOutputType | null
  }

  type GetAccountGroupByPayload<T extends AccountGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AccountGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AccountGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AccountGroupByOutputType[P]>
            : GetScalarType<T[P], AccountGroupByOutputType[P]>
        }
      >
    >


  export type AccountSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["account"]>

  export type AccountSelectScalar = {
    id?: boolean
    userId?: boolean
    type?: boolean
    provider?: boolean
    providerAccountId?: boolean
    refresh_token?: boolean
    access_token?: boolean
    expires_at?: boolean
    token_type?: boolean
    scope?: boolean
    id_token?: boolean
    session_state?: boolean
  }

  export type AccountOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "type" | "provider" | "providerAccountId" | "refresh_token" | "access_token" | "expires_at" | "token_type" | "scope" | "id_token" | "session_state", ExtArgs["result"]["account"]>
  export type AccountInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type AccountIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $AccountPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Account"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      type: string
      provider: string
      providerAccountId: string
      refresh_token: string | null
      access_token: string | null
      expires_at: number | null
      token_type: string | null
      scope: string | null
      id_token: string | null
      session_state: string | null
    }, ExtArgs["result"]["account"]>
    composites: {}
  }

  type AccountGetPayload<S extends boolean | null | undefined | AccountDefaultArgs> = $Result.GetResult<Prisma.$AccountPayload, S>

  type AccountCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AccountFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AccountCountAggregateInputType | true
    }

  export interface AccountDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Account'], meta: { name: 'Account' } }
    /**
     * Find zero or one Account that matches the filter.
     * @param {AccountFindUniqueArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AccountFindUniqueArgs>(args: SelectSubset<T, AccountFindUniqueArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Account that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AccountFindUniqueOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AccountFindUniqueOrThrowArgs>(args: SelectSubset<T, AccountFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AccountFindFirstArgs>(args?: SelectSubset<T, AccountFindFirstArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Account that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindFirstOrThrowArgs} args - Arguments to find a Account
     * @example
     * // Get one Account
     * const account = await prisma.account.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AccountFindFirstOrThrowArgs>(args?: SelectSubset<T, AccountFindFirstOrThrowArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Accounts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Accounts
     * const accounts = await prisma.account.findMany()
     * 
     * // Get first 10 Accounts
     * const accounts = await prisma.account.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const accountWithIdOnly = await prisma.account.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AccountFindManyArgs>(args?: SelectSubset<T, AccountFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Account.
     * @param {AccountCreateArgs} args - Arguments to create a Account.
     * @example
     * // Create one Account
     * const Account = await prisma.account.create({
     *   data: {
     *     // ... data to create a Account
     *   }
     * })
     * 
     */
    create<T extends AccountCreateArgs>(args: SelectSubset<T, AccountCreateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Accounts.
     * @param {AccountCreateManyArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AccountCreateManyArgs>(args?: SelectSubset<T, AccountCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Accounts and returns the data saved in the database.
     * @param {AccountCreateManyAndReturnArgs} args - Arguments to create many Accounts.
     * @example
     * // Create many Accounts
     * const account = await prisma.account.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AccountCreateManyAndReturnArgs>(args?: SelectSubset<T, AccountCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Account.
     * @param {AccountDeleteArgs} args - Arguments to delete one Account.
     * @example
     * // Delete one Account
     * const Account = await prisma.account.delete({
     *   where: {
     *     // ... filter to delete one Account
     *   }
     * })
     * 
     */
    delete<T extends AccountDeleteArgs>(args: SelectSubset<T, AccountDeleteArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Account.
     * @param {AccountUpdateArgs} args - Arguments to update one Account.
     * @example
     * // Update one Account
     * const account = await prisma.account.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AccountUpdateArgs>(args: SelectSubset<T, AccountUpdateArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Accounts.
     * @param {AccountDeleteManyArgs} args - Arguments to filter Accounts to delete.
     * @example
     * // Delete a few Accounts
     * const { count } = await prisma.account.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AccountDeleteManyArgs>(args?: SelectSubset<T, AccountDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AccountUpdateManyArgs>(args: SelectSubset<T, AccountUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Accounts and returns the data updated in the database.
     * @param {AccountUpdateManyAndReturnArgs} args - Arguments to update many Accounts.
     * @example
     * // Update many Accounts
     * const account = await prisma.account.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Accounts and only return the `id`
     * const accountWithIdOnly = await prisma.account.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AccountUpdateManyAndReturnArgs>(args: SelectSubset<T, AccountUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Account.
     * @param {AccountUpsertArgs} args - Arguments to update or create a Account.
     * @example
     * // Update or create a Account
     * const account = await prisma.account.upsert({
     *   create: {
     *     // ... data to create a Account
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Account we want to update
     *   }
     * })
     */
    upsert<T extends AccountUpsertArgs>(args: SelectSubset<T, AccountUpsertArgs<ExtArgs>>): Prisma__AccountClient<$Result.GetResult<Prisma.$AccountPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Accounts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountCountArgs} args - Arguments to filter Accounts to count.
     * @example
     * // Count the number of Accounts
     * const count = await prisma.account.count({
     *   where: {
     *     // ... the filter for the Accounts we want to count
     *   }
     * })
    **/
    count<T extends AccountCountArgs>(
      args?: Subset<T, AccountCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AccountCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AccountAggregateArgs>(args: Subset<T, AccountAggregateArgs>): Prisma.PrismaPromise<GetAccountAggregateType<T>>

    /**
     * Group by Account.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AccountGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AccountGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AccountGroupByArgs['orderBy'] }
        : { orderBy?: AccountGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AccountGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAccountGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Account model
   */
  readonly fields: AccountFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Account.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AccountClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Account model
   */
  interface AccountFieldRefs {
    readonly id: FieldRef<"Account", 'String'>
    readonly userId: FieldRef<"Account", 'String'>
    readonly type: FieldRef<"Account", 'String'>
    readonly provider: FieldRef<"Account", 'String'>
    readonly providerAccountId: FieldRef<"Account", 'String'>
    readonly refresh_token: FieldRef<"Account", 'String'>
    readonly access_token: FieldRef<"Account", 'String'>
    readonly expires_at: FieldRef<"Account", 'Int'>
    readonly token_type: FieldRef<"Account", 'String'>
    readonly scope: FieldRef<"Account", 'String'>
    readonly id_token: FieldRef<"Account", 'String'>
    readonly session_state: FieldRef<"Account", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Account findUnique
   */
  export type AccountFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findUniqueOrThrow
   */
  export type AccountFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account findFirst
   */
  export type AccountFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findFirstOrThrow
   */
  export type AccountFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Account to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Accounts.
     */
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account findMany
   */
  export type AccountFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter, which Accounts to fetch.
     */
    where?: AccountWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Accounts to fetch.
     */
    orderBy?: AccountOrderByWithRelationInput | AccountOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Accounts.
     */
    cursor?: AccountWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Accounts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Accounts.
     */
    skip?: number
    distinct?: AccountScalarFieldEnum | AccountScalarFieldEnum[]
  }

  /**
   * Account create
   */
  export type AccountCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to create a Account.
     */
    data: XOR<AccountCreateInput, AccountUncheckedCreateInput>
  }

  /**
   * Account createMany
   */
  export type AccountCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Account createManyAndReturn
   */
  export type AccountCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to create many Accounts.
     */
    data: AccountCreateManyInput | AccountCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account update
   */
  export type AccountUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The data needed to update a Account.
     */
    data: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
    /**
     * Choose, which Account to update.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account updateMany
   */
  export type AccountUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
  }

  /**
   * Account updateManyAndReturn
   */
  export type AccountUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * The data used to update Accounts.
     */
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyInput>
    /**
     * Filter which Accounts to update
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Account upsert
   */
  export type AccountUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * The filter to search for the Account to update in case it exists.
     */
    where: AccountWhereUniqueInput
    /**
     * In case the Account found by the `where` argument doesn't exist, create a new Account with this data.
     */
    create: XOR<AccountCreateInput, AccountUncheckedCreateInput>
    /**
     * In case the Account was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AccountUpdateInput, AccountUncheckedUpdateInput>
  }

  /**
   * Account delete
   */
  export type AccountDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
    /**
     * Filter which Account to delete.
     */
    where: AccountWhereUniqueInput
  }

  /**
   * Account deleteMany
   */
  export type AccountDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Accounts to delete
     */
    where?: AccountWhereInput
    /**
     * Limit how many Accounts to delete.
     */
    limit?: number
  }

  /**
   * Account without action
   */
  export type AccountDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Account
     */
    select?: AccountSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Account
     */
    omit?: AccountOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AccountInclude<ExtArgs> | null
  }


  /**
   * Model Session
   */

  export type AggregateSession = {
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  export type SessionMinAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionMaxAggregateOutputType = {
    id: string | null
    sessionToken: string | null
    userId: string | null
    expires: Date | null
  }

  export type SessionCountAggregateOutputType = {
    id: number
    sessionToken: number
    userId: number
    expires: number
    _all: number
  }


  export type SessionMinAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionMaxAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
  }

  export type SessionCountAggregateInputType = {
    id?: true
    sessionToken?: true
    userId?: true
    expires?: true
    _all?: true
  }

  export type SessionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Session to aggregate.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sessions
    **/
    _count?: true | SessionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SessionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SessionMaxAggregateInputType
  }

  export type GetSessionAggregateType<T extends SessionAggregateArgs> = {
        [P in keyof T & keyof AggregateSession]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSession[P]>
      : GetScalarType<T[P], AggregateSession[P]>
  }




  export type SessionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SessionWhereInput
    orderBy?: SessionOrderByWithAggregationInput | SessionOrderByWithAggregationInput[]
    by: SessionScalarFieldEnum[] | SessionScalarFieldEnum
    having?: SessionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SessionCountAggregateInputType | true
    _min?: SessionMinAggregateInputType
    _max?: SessionMaxAggregateInputType
  }

  export type SessionGroupByOutputType = {
    id: string
    sessionToken: string
    userId: string
    expires: Date
    _count: SessionCountAggregateOutputType | null
    _min: SessionMinAggregateOutputType | null
    _max: SessionMaxAggregateOutputType | null
  }

  type GetSessionGroupByPayload<T extends SessionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SessionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SessionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SessionGroupByOutputType[P]>
            : GetScalarType<T[P], SessionGroupByOutputType[P]>
        }
      >
    >


  export type SessionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["session"]>

  export type SessionSelectScalar = {
    id?: boolean
    sessionToken?: boolean
    userId?: boolean
    expires?: boolean
  }

  export type SessionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "sessionToken" | "userId" | "expires", ExtArgs["result"]["session"]>
  export type SessionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type SessionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $SessionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Session"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sessionToken: string
      userId: string
      expires: Date
    }, ExtArgs["result"]["session"]>
    composites: {}
  }

  type SessionGetPayload<S extends boolean | null | undefined | SessionDefaultArgs> = $Result.GetResult<Prisma.$SessionPayload, S>

  type SessionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SessionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SessionCountAggregateInputType | true
    }

  export interface SessionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Session'], meta: { name: 'Session' } }
    /**
     * Find zero or one Session that matches the filter.
     * @param {SessionFindUniqueArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SessionFindUniqueArgs>(args: SelectSubset<T, SessionFindUniqueArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Session that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SessionFindUniqueOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SessionFindUniqueOrThrowArgs>(args: SelectSubset<T, SessionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SessionFindFirstArgs>(args?: SelectSubset<T, SessionFindFirstArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Session that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindFirstOrThrowArgs} args - Arguments to find a Session
     * @example
     * // Get one Session
     * const session = await prisma.session.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SessionFindFirstOrThrowArgs>(args?: SelectSubset<T, SessionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Sessions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sessions
     * const sessions = await prisma.session.findMany()
     * 
     * // Get first 10 Sessions
     * const sessions = await prisma.session.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sessionWithIdOnly = await prisma.session.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SessionFindManyArgs>(args?: SelectSubset<T, SessionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Session.
     * @param {SessionCreateArgs} args - Arguments to create a Session.
     * @example
     * // Create one Session
     * const Session = await prisma.session.create({
     *   data: {
     *     // ... data to create a Session
     *   }
     * })
     * 
     */
    create<T extends SessionCreateArgs>(args: SelectSubset<T, SessionCreateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Sessions.
     * @param {SessionCreateManyArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SessionCreateManyArgs>(args?: SelectSubset<T, SessionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sessions and returns the data saved in the database.
     * @param {SessionCreateManyAndReturnArgs} args - Arguments to create many Sessions.
     * @example
     * // Create many Sessions
     * const session = await prisma.session.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SessionCreateManyAndReturnArgs>(args?: SelectSubset<T, SessionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Session.
     * @param {SessionDeleteArgs} args - Arguments to delete one Session.
     * @example
     * // Delete one Session
     * const Session = await prisma.session.delete({
     *   where: {
     *     // ... filter to delete one Session
     *   }
     * })
     * 
     */
    delete<T extends SessionDeleteArgs>(args: SelectSubset<T, SessionDeleteArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Session.
     * @param {SessionUpdateArgs} args - Arguments to update one Session.
     * @example
     * // Update one Session
     * const session = await prisma.session.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SessionUpdateArgs>(args: SelectSubset<T, SessionUpdateArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Sessions.
     * @param {SessionDeleteManyArgs} args - Arguments to filter Sessions to delete.
     * @example
     * // Delete a few Sessions
     * const { count } = await prisma.session.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SessionDeleteManyArgs>(args?: SelectSubset<T, SessionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SessionUpdateManyArgs>(args: SelectSubset<T, SessionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sessions and returns the data updated in the database.
     * @param {SessionUpdateManyAndReturnArgs} args - Arguments to update many Sessions.
     * @example
     * // Update many Sessions
     * const session = await prisma.session.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Sessions and only return the `id`
     * const sessionWithIdOnly = await prisma.session.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SessionUpdateManyAndReturnArgs>(args: SelectSubset<T, SessionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Session.
     * @param {SessionUpsertArgs} args - Arguments to update or create a Session.
     * @example
     * // Update or create a Session
     * const session = await prisma.session.upsert({
     *   create: {
     *     // ... data to create a Session
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Session we want to update
     *   }
     * })
     */
    upsert<T extends SessionUpsertArgs>(args: SelectSubset<T, SessionUpsertArgs<ExtArgs>>): Prisma__SessionClient<$Result.GetResult<Prisma.$SessionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Sessions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionCountArgs} args - Arguments to filter Sessions to count.
     * @example
     * // Count the number of Sessions
     * const count = await prisma.session.count({
     *   where: {
     *     // ... the filter for the Sessions we want to count
     *   }
     * })
    **/
    count<T extends SessionCountArgs>(
      args?: Subset<T, SessionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SessionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SessionAggregateArgs>(args: Subset<T, SessionAggregateArgs>): Prisma.PrismaPromise<GetSessionAggregateType<T>>

    /**
     * Group by Session.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SessionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SessionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SessionGroupByArgs['orderBy'] }
        : { orderBy?: SessionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SessionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSessionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Session model
   */
  readonly fields: SessionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Session.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SessionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Session model
   */
  interface SessionFieldRefs {
    readonly id: FieldRef<"Session", 'String'>
    readonly sessionToken: FieldRef<"Session", 'String'>
    readonly userId: FieldRef<"Session", 'String'>
    readonly expires: FieldRef<"Session", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Session findUnique
   */
  export type SessionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findUniqueOrThrow
   */
  export type SessionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session findFirst
   */
  export type SessionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findFirstOrThrow
   */
  export type SessionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Session to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sessions.
     */
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session findMany
   */
  export type SessionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter, which Sessions to fetch.
     */
    where?: SessionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sessions to fetch.
     */
    orderBy?: SessionOrderByWithRelationInput | SessionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sessions.
     */
    cursor?: SessionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Sessions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sessions.
     */
    skip?: number
    distinct?: SessionScalarFieldEnum | SessionScalarFieldEnum[]
  }

  /**
   * Session create
   */
  export type SessionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to create a Session.
     */
    data: XOR<SessionCreateInput, SessionUncheckedCreateInput>
  }

  /**
   * Session createMany
   */
  export type SessionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Session createManyAndReturn
   */
  export type SessionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to create many Sessions.
     */
    data: SessionCreateManyInput | SessionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session update
   */
  export type SessionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The data needed to update a Session.
     */
    data: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
    /**
     * Choose, which Session to update.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session updateMany
   */
  export type SessionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
  }

  /**
   * Session updateManyAndReturn
   */
  export type SessionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * The data used to update Sessions.
     */
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyInput>
    /**
     * Filter which Sessions to update
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Session upsert
   */
  export type SessionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * The filter to search for the Session to update in case it exists.
     */
    where: SessionWhereUniqueInput
    /**
     * In case the Session found by the `where` argument doesn't exist, create a new Session with this data.
     */
    create: XOR<SessionCreateInput, SessionUncheckedCreateInput>
    /**
     * In case the Session was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SessionUpdateInput, SessionUncheckedUpdateInput>
  }

  /**
   * Session delete
   */
  export type SessionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
    /**
     * Filter which Session to delete.
     */
    where: SessionWhereUniqueInput
  }

  /**
   * Session deleteMany
   */
  export type SessionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sessions to delete
     */
    where?: SessionWhereInput
    /**
     * Limit how many Sessions to delete.
     */
    limit?: number
  }

  /**
   * Session without action
   */
  export type SessionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Session
     */
    select?: SessionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Session
     */
    omit?: SessionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SessionInclude<ExtArgs> | null
  }


  /**
   * Model VerificationToken
   */

  export type AggregateVerificationToken = {
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  export type VerificationTokenMinAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenMaxAggregateOutputType = {
    identifier: string | null
    token: string | null
    expires: Date | null
  }

  export type VerificationTokenCountAggregateOutputType = {
    identifier: number
    token: number
    expires: number
    _all: number
  }


  export type VerificationTokenMinAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenMaxAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
  }

  export type VerificationTokenCountAggregateInputType = {
    identifier?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type VerificationTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationToken to aggregate.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned VerificationTokens
    **/
    _count?: true | VerificationTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VerificationTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type GetVerificationTokenAggregateType<T extends VerificationTokenAggregateArgs> = {
        [P in keyof T & keyof AggregateVerificationToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVerificationToken[P]>
      : GetScalarType<T[P], AggregateVerificationToken[P]>
  }




  export type VerificationTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: VerificationTokenWhereInput
    orderBy?: VerificationTokenOrderByWithAggregationInput | VerificationTokenOrderByWithAggregationInput[]
    by: VerificationTokenScalarFieldEnum[] | VerificationTokenScalarFieldEnum
    having?: VerificationTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VerificationTokenCountAggregateInputType | true
    _min?: VerificationTokenMinAggregateInputType
    _max?: VerificationTokenMaxAggregateInputType
  }

  export type VerificationTokenGroupByOutputType = {
    identifier: string
    token: string
    expires: Date
    _count: VerificationTokenCountAggregateOutputType | null
    _min: VerificationTokenMinAggregateOutputType | null
    _max: VerificationTokenMaxAggregateOutputType | null
  }

  type GetVerificationTokenGroupByPayload<T extends VerificationTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VerificationTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VerificationTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
            : GetScalarType<T[P], VerificationTokenGroupByOutputType[P]>
        }
      >
    >


  export type VerificationTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["verificationToken"]>

  export type VerificationTokenSelectScalar = {
    identifier?: boolean
    token?: boolean
    expires?: boolean
  }

  export type VerificationTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"identifier" | "token" | "expires", ExtArgs["result"]["verificationToken"]>

  export type $VerificationTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "VerificationToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      identifier: string
      token: string
      expires: Date
    }, ExtArgs["result"]["verificationToken"]>
    composites: {}
  }

  type VerificationTokenGetPayload<S extends boolean | null | undefined | VerificationTokenDefaultArgs> = $Result.GetResult<Prisma.$VerificationTokenPayload, S>

  type VerificationTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<VerificationTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VerificationTokenCountAggregateInputType | true
    }

  export interface VerificationTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['VerificationToken'], meta: { name: 'VerificationToken' } }
    /**
     * Find zero or one VerificationToken that matches the filter.
     * @param {VerificationTokenFindUniqueArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends VerificationTokenFindUniqueArgs>(args: SelectSubset<T, VerificationTokenFindUniqueArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one VerificationToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {VerificationTokenFindUniqueOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends VerificationTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, VerificationTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends VerificationTokenFindFirstArgs>(args?: SelectSubset<T, VerificationTokenFindFirstArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first VerificationToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindFirstOrThrowArgs} args - Arguments to find a VerificationToken
     * @example
     * // Get one VerificationToken
     * const verificationToken = await prisma.verificationToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends VerificationTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, VerificationTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more VerificationTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany()
     * 
     * // Get first 10 VerificationTokens
     * const verificationTokens = await prisma.verificationToken.findMany({ take: 10 })
     * 
     * // Only select the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.findMany({ select: { identifier: true } })
     * 
     */
    findMany<T extends VerificationTokenFindManyArgs>(args?: SelectSubset<T, VerificationTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a VerificationToken.
     * @param {VerificationTokenCreateArgs} args - Arguments to create a VerificationToken.
     * @example
     * // Create one VerificationToken
     * const VerificationToken = await prisma.verificationToken.create({
     *   data: {
     *     // ... data to create a VerificationToken
     *   }
     * })
     * 
     */
    create<T extends VerificationTokenCreateArgs>(args: SelectSubset<T, VerificationTokenCreateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many VerificationTokens.
     * @param {VerificationTokenCreateManyArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends VerificationTokenCreateManyArgs>(args?: SelectSubset<T, VerificationTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many VerificationTokens and returns the data saved in the database.
     * @param {VerificationTokenCreateManyAndReturnArgs} args - Arguments to create many VerificationTokens.
     * @example
     * // Create many VerificationTokens
     * const verificationToken = await prisma.verificationToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.createManyAndReturn({
     *   select: { identifier: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends VerificationTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, VerificationTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a VerificationToken.
     * @param {VerificationTokenDeleteArgs} args - Arguments to delete one VerificationToken.
     * @example
     * // Delete one VerificationToken
     * const VerificationToken = await prisma.verificationToken.delete({
     *   where: {
     *     // ... filter to delete one VerificationToken
     *   }
     * })
     * 
     */
    delete<T extends VerificationTokenDeleteArgs>(args: SelectSubset<T, VerificationTokenDeleteArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one VerificationToken.
     * @param {VerificationTokenUpdateArgs} args - Arguments to update one VerificationToken.
     * @example
     * // Update one VerificationToken
     * const verificationToken = await prisma.verificationToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends VerificationTokenUpdateArgs>(args: SelectSubset<T, VerificationTokenUpdateArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more VerificationTokens.
     * @param {VerificationTokenDeleteManyArgs} args - Arguments to filter VerificationTokens to delete.
     * @example
     * // Delete a few VerificationTokens
     * const { count } = await prisma.verificationToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends VerificationTokenDeleteManyArgs>(args?: SelectSubset<T, VerificationTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends VerificationTokenUpdateManyArgs>(args: SelectSubset<T, VerificationTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more VerificationTokens and returns the data updated in the database.
     * @param {VerificationTokenUpdateManyAndReturnArgs} args - Arguments to update many VerificationTokens.
     * @example
     * // Update many VerificationTokens
     * const verificationToken = await prisma.verificationToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more VerificationTokens and only return the `identifier`
     * const verificationTokenWithIdentifierOnly = await prisma.verificationToken.updateManyAndReturn({
     *   select: { identifier: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends VerificationTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, VerificationTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one VerificationToken.
     * @param {VerificationTokenUpsertArgs} args - Arguments to update or create a VerificationToken.
     * @example
     * // Update or create a VerificationToken
     * const verificationToken = await prisma.verificationToken.upsert({
     *   create: {
     *     // ... data to create a VerificationToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the VerificationToken we want to update
     *   }
     * })
     */
    upsert<T extends VerificationTokenUpsertArgs>(args: SelectSubset<T, VerificationTokenUpsertArgs<ExtArgs>>): Prisma__VerificationTokenClient<$Result.GetResult<Prisma.$VerificationTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of VerificationTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenCountArgs} args - Arguments to filter VerificationTokens to count.
     * @example
     * // Count the number of VerificationTokens
     * const count = await prisma.verificationToken.count({
     *   where: {
     *     // ... the filter for the VerificationTokens we want to count
     *   }
     * })
    **/
    count<T extends VerificationTokenCountArgs>(
      args?: Subset<T, VerificationTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VerificationTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VerificationTokenAggregateArgs>(args: Subset<T, VerificationTokenAggregateArgs>): Prisma.PrismaPromise<GetVerificationTokenAggregateType<T>>

    /**
     * Group by VerificationToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VerificationTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends VerificationTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: VerificationTokenGroupByArgs['orderBy'] }
        : { orderBy?: VerificationTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, VerificationTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVerificationTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the VerificationToken model
   */
  readonly fields: VerificationTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for VerificationToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__VerificationTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the VerificationToken model
   */
  interface VerificationTokenFieldRefs {
    readonly identifier: FieldRef<"VerificationToken", 'String'>
    readonly token: FieldRef<"VerificationToken", 'String'>
    readonly expires: FieldRef<"VerificationToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * VerificationToken findUnique
   */
  export type VerificationTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findUniqueOrThrow
   */
  export type VerificationTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken findFirst
   */
  export type VerificationTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findFirstOrThrow
   */
  export type VerificationTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationToken to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of VerificationTokens.
     */
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken findMany
   */
  export type VerificationTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter, which VerificationTokens to fetch.
     */
    where?: VerificationTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of VerificationTokens to fetch.
     */
    orderBy?: VerificationTokenOrderByWithRelationInput | VerificationTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing VerificationTokens.
     */
    cursor?: VerificationTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` VerificationTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` VerificationTokens.
     */
    skip?: number
    distinct?: VerificationTokenScalarFieldEnum | VerificationTokenScalarFieldEnum[]
  }

  /**
   * VerificationToken create
   */
  export type VerificationTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a VerificationToken.
     */
    data: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
  }

  /**
   * VerificationToken createMany
   */
  export type VerificationTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken createManyAndReturn
   */
  export type VerificationTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to create many VerificationTokens.
     */
    data: VerificationTokenCreateManyInput | VerificationTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * VerificationToken update
   */
  export type VerificationTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a VerificationToken.
     */
    data: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
    /**
     * Choose, which VerificationToken to update.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken updateMany
   */
  export type VerificationTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken updateManyAndReturn
   */
  export type VerificationTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The data used to update VerificationTokens.
     */
    data: XOR<VerificationTokenUpdateManyMutationInput, VerificationTokenUncheckedUpdateManyInput>
    /**
     * Filter which VerificationTokens to update
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to update.
     */
    limit?: number
  }

  /**
   * VerificationToken upsert
   */
  export type VerificationTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the VerificationToken to update in case it exists.
     */
    where: VerificationTokenWhereUniqueInput
    /**
     * In case the VerificationToken found by the `where` argument doesn't exist, create a new VerificationToken with this data.
     */
    create: XOR<VerificationTokenCreateInput, VerificationTokenUncheckedCreateInput>
    /**
     * In case the VerificationToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<VerificationTokenUpdateInput, VerificationTokenUncheckedUpdateInput>
  }

  /**
   * VerificationToken delete
   */
  export type VerificationTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
    /**
     * Filter which VerificationToken to delete.
     */
    where: VerificationTokenWhereUniqueInput
  }

  /**
   * VerificationToken deleteMany
   */
  export type VerificationTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which VerificationTokens to delete
     */
    where?: VerificationTokenWhereInput
    /**
     * Limit how many VerificationTokens to delete.
     */
    limit?: number
  }

  /**
   * VerificationToken without action
   */
  export type VerificationTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VerificationToken
     */
    select?: VerificationTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the VerificationToken
     */
    omit?: VerificationTokenOmit<ExtArgs> | null
  }


  /**
   * Model PasswordResetToken
   */

  export type AggregatePasswordResetToken = {
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  export type PasswordResetTokenMinAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenMaxAggregateOutputType = {
    id: string | null
    email: string | null
    token: string | null
    expires: Date | null
  }

  export type PasswordResetTokenCountAggregateOutputType = {
    id: number
    email: number
    token: number
    expires: number
    _all: number
  }


  export type PasswordResetTokenMinAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenMaxAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
  }

  export type PasswordResetTokenCountAggregateInputType = {
    id?: true
    email?: true
    token?: true
    expires?: true
    _all?: true
  }

  export type PasswordResetTokenAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetToken to aggregate.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordResetTokens
    **/
    _count?: true | PasswordResetTokenCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordResetTokenMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type GetPasswordResetTokenAggregateType<T extends PasswordResetTokenAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordResetToken]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordResetToken[P]>
      : GetScalarType<T[P], AggregatePasswordResetToken[P]>
  }




  export type PasswordResetTokenGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordResetTokenWhereInput
    orderBy?: PasswordResetTokenOrderByWithAggregationInput | PasswordResetTokenOrderByWithAggregationInput[]
    by: PasswordResetTokenScalarFieldEnum[] | PasswordResetTokenScalarFieldEnum
    having?: PasswordResetTokenScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordResetTokenCountAggregateInputType | true
    _min?: PasswordResetTokenMinAggregateInputType
    _max?: PasswordResetTokenMaxAggregateInputType
  }

  export type PasswordResetTokenGroupByOutputType = {
    id: string
    email: string
    token: string
    expires: Date
    _count: PasswordResetTokenCountAggregateOutputType | null
    _min: PasswordResetTokenMinAggregateOutputType | null
    _max: PasswordResetTokenMaxAggregateOutputType | null
  }

  type GetPasswordResetTokenGroupByPayload<T extends PasswordResetTokenGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordResetTokenGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordResetTokenGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordResetTokenGroupByOutputType[P]>
        }
      >
    >


  export type PasswordResetTokenSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }, ExtArgs["result"]["passwordResetToken"]>

  export type PasswordResetTokenSelectScalar = {
    id?: boolean
    email?: boolean
    token?: boolean
    expires?: boolean
  }

  export type PasswordResetTokenOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "email" | "token" | "expires", ExtArgs["result"]["passwordResetToken"]>

  export type $PasswordResetTokenPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordResetToken"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      token: string
      expires: Date
    }, ExtArgs["result"]["passwordResetToken"]>
    composites: {}
  }

  type PasswordResetTokenGetPayload<S extends boolean | null | undefined | PasswordResetTokenDefaultArgs> = $Result.GetResult<Prisma.$PasswordResetTokenPayload, S>

  type PasswordResetTokenCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PasswordResetTokenFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PasswordResetTokenCountAggregateInputType | true
    }

  export interface PasswordResetTokenDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordResetToken'], meta: { name: 'PasswordResetToken' } }
    /**
     * Find zero or one PasswordResetToken that matches the filter.
     * @param {PasswordResetTokenFindUniqueArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordResetTokenFindUniqueArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one PasswordResetToken that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PasswordResetTokenFindUniqueOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordResetTokenFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordResetTokenFindFirstArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first PasswordResetToken that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindFirstOrThrowArgs} args - Arguments to find a PasswordResetToken
     * @example
     * // Get one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordResetTokenFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordResetTokenFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more PasswordResetTokens that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany()
     * 
     * // Get first 10 PasswordResetTokens
     * const passwordResetTokens = await prisma.passwordResetToken.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordResetTokenFindManyArgs>(args?: SelectSubset<T, PasswordResetTokenFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a PasswordResetToken.
     * @param {PasswordResetTokenCreateArgs} args - Arguments to create a PasswordResetToken.
     * @example
     * // Create one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.create({
     *   data: {
     *     // ... data to create a PasswordResetToken
     *   }
     * })
     * 
     */
    create<T extends PasswordResetTokenCreateArgs>(args: SelectSubset<T, PasswordResetTokenCreateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many PasswordResetTokens.
     * @param {PasswordResetTokenCreateManyArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordResetTokenCreateManyArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordResetTokens and returns the data saved in the database.
     * @param {PasswordResetTokenCreateManyAndReturnArgs} args - Arguments to create many PasswordResetTokens.
     * @example
     * // Create many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordResetTokenCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordResetTokenCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a PasswordResetToken.
     * @param {PasswordResetTokenDeleteArgs} args - Arguments to delete one PasswordResetToken.
     * @example
     * // Delete one PasswordResetToken
     * const PasswordResetToken = await prisma.passwordResetToken.delete({
     *   where: {
     *     // ... filter to delete one PasswordResetToken
     *   }
     * })
     * 
     */
    delete<T extends PasswordResetTokenDeleteArgs>(args: SelectSubset<T, PasswordResetTokenDeleteArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one PasswordResetToken.
     * @param {PasswordResetTokenUpdateArgs} args - Arguments to update one PasswordResetToken.
     * @example
     * // Update one PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordResetTokenUpdateArgs>(args: SelectSubset<T, PasswordResetTokenUpdateArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more PasswordResetTokens.
     * @param {PasswordResetTokenDeleteManyArgs} args - Arguments to filter PasswordResetTokens to delete.
     * @example
     * // Delete a few PasswordResetTokens
     * const { count } = await prisma.passwordResetToken.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordResetTokenDeleteManyArgs>(args?: SelectSubset<T, PasswordResetTokenDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordResetTokenUpdateManyArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordResetTokens and returns the data updated in the database.
     * @param {PasswordResetTokenUpdateManyAndReturnArgs} args - Arguments to update many PasswordResetTokens.
     * @example
     * // Update many PasswordResetTokens
     * const passwordResetToken = await prisma.passwordResetToken.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more PasswordResetTokens and only return the `id`
     * const passwordResetTokenWithIdOnly = await prisma.passwordResetToken.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PasswordResetTokenUpdateManyAndReturnArgs>(args: SelectSubset<T, PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one PasswordResetToken.
     * @param {PasswordResetTokenUpsertArgs} args - Arguments to update or create a PasswordResetToken.
     * @example
     * // Update or create a PasswordResetToken
     * const passwordResetToken = await prisma.passwordResetToken.upsert({
     *   create: {
     *     // ... data to create a PasswordResetToken
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordResetToken we want to update
     *   }
     * })
     */
    upsert<T extends PasswordResetTokenUpsertArgs>(args: SelectSubset<T, PasswordResetTokenUpsertArgs<ExtArgs>>): Prisma__PasswordResetTokenClient<$Result.GetResult<Prisma.$PasswordResetTokenPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of PasswordResetTokens.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenCountArgs} args - Arguments to filter PasswordResetTokens to count.
     * @example
     * // Count the number of PasswordResetTokens
     * const count = await prisma.passwordResetToken.count({
     *   where: {
     *     // ... the filter for the PasswordResetTokens we want to count
     *   }
     * })
    **/
    count<T extends PasswordResetTokenCountArgs>(
      args?: Subset<T, PasswordResetTokenCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordResetTokenCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordResetTokenAggregateArgs>(args: Subset<T, PasswordResetTokenAggregateArgs>): Prisma.PrismaPromise<GetPasswordResetTokenAggregateType<T>>

    /**
     * Group by PasswordResetToken.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordResetTokenGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordResetTokenGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordResetTokenGroupByArgs['orderBy'] }
        : { orderBy?: PasswordResetTokenGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordResetTokenGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordResetTokenGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordResetToken model
   */
  readonly fields: PasswordResetTokenFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordResetToken.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordResetTokenClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordResetToken model
   */
  interface PasswordResetTokenFieldRefs {
    readonly id: FieldRef<"PasswordResetToken", 'String'>
    readonly email: FieldRef<"PasswordResetToken", 'String'>
    readonly token: FieldRef<"PasswordResetToken", 'String'>
    readonly expires: FieldRef<"PasswordResetToken", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordResetToken findUnique
   */
  export type PasswordResetTokenFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findUniqueOrThrow
   */
  export type PasswordResetTokenFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken findFirst
   */
  export type PasswordResetTokenFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findFirstOrThrow
   */
  export type PasswordResetTokenFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetToken to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordResetTokens.
     */
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken findMany
   */
  export type PasswordResetTokenFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter, which PasswordResetTokens to fetch.
     */
    where?: PasswordResetTokenWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordResetTokens to fetch.
     */
    orderBy?: PasswordResetTokenOrderByWithRelationInput | PasswordResetTokenOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordResetTokens.
     */
    cursor?: PasswordResetTokenWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` PasswordResetTokens from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordResetTokens.
     */
    skip?: number
    distinct?: PasswordResetTokenScalarFieldEnum | PasswordResetTokenScalarFieldEnum[]
  }

  /**
   * PasswordResetToken create
   */
  export type PasswordResetTokenCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to create a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
  }

  /**
   * PasswordResetToken createMany
   */
  export type PasswordResetTokenCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken createManyAndReturn
   */
  export type PasswordResetTokenCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to create many PasswordResetTokens.
     */
    data: PasswordResetTokenCreateManyInput | PasswordResetTokenCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordResetToken update
   */
  export type PasswordResetTokenUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data needed to update a PasswordResetToken.
     */
    data: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
    /**
     * Choose, which PasswordResetToken to update.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken updateMany
   */
  export type PasswordResetTokenUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken updateManyAndReturn
   */
  export type PasswordResetTokenUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The data used to update PasswordResetTokens.
     */
    data: XOR<PasswordResetTokenUpdateManyMutationInput, PasswordResetTokenUncheckedUpdateManyInput>
    /**
     * Filter which PasswordResetTokens to update
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to update.
     */
    limit?: number
  }

  /**
   * PasswordResetToken upsert
   */
  export type PasswordResetTokenUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * The filter to search for the PasswordResetToken to update in case it exists.
     */
    where: PasswordResetTokenWhereUniqueInput
    /**
     * In case the PasswordResetToken found by the `where` argument doesn't exist, create a new PasswordResetToken with this data.
     */
    create: XOR<PasswordResetTokenCreateInput, PasswordResetTokenUncheckedCreateInput>
    /**
     * In case the PasswordResetToken was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordResetTokenUpdateInput, PasswordResetTokenUncheckedUpdateInput>
  }

  /**
   * PasswordResetToken delete
   */
  export type PasswordResetTokenDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
    /**
     * Filter which PasswordResetToken to delete.
     */
    where: PasswordResetTokenWhereUniqueInput
  }

  /**
   * PasswordResetToken deleteMany
   */
  export type PasswordResetTokenDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordResetTokens to delete
     */
    where?: PasswordResetTokenWhereInput
    /**
     * Limit how many PasswordResetTokens to delete.
     */
    limit?: number
  }

  /**
   * PasswordResetToken without action
   */
  export type PasswordResetTokenDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordResetToken
     */
    select?: PasswordResetTokenSelect<ExtArgs> | null
    /**
     * Omit specific fields from the PasswordResetToken
     */
    omit?: PasswordResetTokenOmit<ExtArgs> | null
  }


  /**
   * Model EmailChangeRequest
   */

  export type AggregateEmailChangeRequest = {
    _count: EmailChangeRequestCountAggregateOutputType | null
    _min: EmailChangeRequestMinAggregateOutputType | null
    _max: EmailChangeRequestMaxAggregateOutputType | null
  }

  export type EmailChangeRequestMinAggregateOutputType = {
    id: string | null
    userId: string | null
    newEmail: string | null
    token: string | null
    expires: Date | null
    usedAt: Date | null
  }

  export type EmailChangeRequestMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    newEmail: string | null
    token: string | null
    expires: Date | null
    usedAt: Date | null
  }

  export type EmailChangeRequestCountAggregateOutputType = {
    id: number
    userId: number
    newEmail: number
    token: number
    expires: number
    usedAt: number
    _all: number
  }


  export type EmailChangeRequestMinAggregateInputType = {
    id?: true
    userId?: true
    newEmail?: true
    token?: true
    expires?: true
    usedAt?: true
  }

  export type EmailChangeRequestMaxAggregateInputType = {
    id?: true
    userId?: true
    newEmail?: true
    token?: true
    expires?: true
    usedAt?: true
  }

  export type EmailChangeRequestCountAggregateInputType = {
    id?: true
    userId?: true
    newEmail?: true
    token?: true
    expires?: true
    usedAt?: true
    _all?: true
  }

  export type EmailChangeRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailChangeRequest to aggregate.
     */
    where?: EmailChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailChangeRequests to fetch.
     */
    orderBy?: EmailChangeRequestOrderByWithRelationInput | EmailChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` EmailChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailChangeRequests
    **/
    _count?: true | EmailChangeRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailChangeRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailChangeRequestMaxAggregateInputType
  }

  export type GetEmailChangeRequestAggregateType<T extends EmailChangeRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailChangeRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailChangeRequest[P]>
      : GetScalarType<T[P], AggregateEmailChangeRequest[P]>
  }




  export type EmailChangeRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailChangeRequestWhereInput
    orderBy?: EmailChangeRequestOrderByWithAggregationInput | EmailChangeRequestOrderByWithAggregationInput[]
    by: EmailChangeRequestScalarFieldEnum[] | EmailChangeRequestScalarFieldEnum
    having?: EmailChangeRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailChangeRequestCountAggregateInputType | true
    _min?: EmailChangeRequestMinAggregateInputType
    _max?: EmailChangeRequestMaxAggregateInputType
  }

  export type EmailChangeRequestGroupByOutputType = {
    id: string
    userId: string
    newEmail: string
    token: string
    expires: Date
    usedAt: Date | null
    _count: EmailChangeRequestCountAggregateOutputType | null
    _min: EmailChangeRequestMinAggregateOutputType | null
    _max: EmailChangeRequestMaxAggregateOutputType | null
  }

  type GetEmailChangeRequestGroupByPayload<T extends EmailChangeRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailChangeRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailChangeRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailChangeRequestGroupByOutputType[P]>
            : GetScalarType<T[P], EmailChangeRequestGroupByOutputType[P]>
        }
      >
    >


  export type EmailChangeRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    newEmail?: boolean
    token?: boolean
    expires?: boolean
    usedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailChangeRequest"]>

  export type EmailChangeRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    newEmail?: boolean
    token?: boolean
    expires?: boolean
    usedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailChangeRequest"]>

  export type EmailChangeRequestSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    newEmail?: boolean
    token?: boolean
    expires?: boolean
    usedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailChangeRequest"]>

  export type EmailChangeRequestSelectScalar = {
    id?: boolean
    userId?: boolean
    newEmail?: boolean
    token?: boolean
    expires?: boolean
    usedAt?: boolean
  }

  export type EmailChangeRequestOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "newEmail" | "token" | "expires" | "usedAt", ExtArgs["result"]["emailChangeRequest"]>
  export type EmailChangeRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailChangeRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EmailChangeRequestIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailChangeRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailChangeRequest"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      newEmail: string
      token: string
      expires: Date
      usedAt: Date | null
    }, ExtArgs["result"]["emailChangeRequest"]>
    composites: {}
  }

  type EmailChangeRequestGetPayload<S extends boolean | null | undefined | EmailChangeRequestDefaultArgs> = $Result.GetResult<Prisma.$EmailChangeRequestPayload, S>

  type EmailChangeRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EmailChangeRequestFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EmailChangeRequestCountAggregateInputType | true
    }

  export interface EmailChangeRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailChangeRequest'], meta: { name: 'EmailChangeRequest' } }
    /**
     * Find zero or one EmailChangeRequest that matches the filter.
     * @param {EmailChangeRequestFindUniqueArgs} args - Arguments to find a EmailChangeRequest
     * @example
     * // Get one EmailChangeRequest
     * const emailChangeRequest = await prisma.emailChangeRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailChangeRequestFindUniqueArgs>(args: SelectSubset<T, EmailChangeRequestFindUniqueArgs<ExtArgs>>): Prisma__EmailChangeRequestClient<$Result.GetResult<Prisma.$EmailChangeRequestPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one EmailChangeRequest that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EmailChangeRequestFindUniqueOrThrowArgs} args - Arguments to find a EmailChangeRequest
     * @example
     * // Get one EmailChangeRequest
     * const emailChangeRequest = await prisma.emailChangeRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailChangeRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailChangeRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailChangeRequestClient<$Result.GetResult<Prisma.$EmailChangeRequestPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailChangeRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeRequestFindFirstArgs} args - Arguments to find a EmailChangeRequest
     * @example
     * // Get one EmailChangeRequest
     * const emailChangeRequest = await prisma.emailChangeRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailChangeRequestFindFirstArgs>(args?: SelectSubset<T, EmailChangeRequestFindFirstArgs<ExtArgs>>): Prisma__EmailChangeRequestClient<$Result.GetResult<Prisma.$EmailChangeRequestPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first EmailChangeRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeRequestFindFirstOrThrowArgs} args - Arguments to find a EmailChangeRequest
     * @example
     * // Get one EmailChangeRequest
     * const emailChangeRequest = await prisma.emailChangeRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailChangeRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailChangeRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailChangeRequestClient<$Result.GetResult<Prisma.$EmailChangeRequestPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more EmailChangeRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailChangeRequests
     * const emailChangeRequests = await prisma.emailChangeRequest.findMany()
     * 
     * // Get first 10 EmailChangeRequests
     * const emailChangeRequests = await prisma.emailChangeRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailChangeRequestWithIdOnly = await prisma.emailChangeRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailChangeRequestFindManyArgs>(args?: SelectSubset<T, EmailChangeRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailChangeRequestPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a EmailChangeRequest.
     * @param {EmailChangeRequestCreateArgs} args - Arguments to create a EmailChangeRequest.
     * @example
     * // Create one EmailChangeRequest
     * const EmailChangeRequest = await prisma.emailChangeRequest.create({
     *   data: {
     *     // ... data to create a EmailChangeRequest
     *   }
     * })
     * 
     */
    create<T extends EmailChangeRequestCreateArgs>(args: SelectSubset<T, EmailChangeRequestCreateArgs<ExtArgs>>): Prisma__EmailChangeRequestClient<$Result.GetResult<Prisma.$EmailChangeRequestPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many EmailChangeRequests.
     * @param {EmailChangeRequestCreateManyArgs} args - Arguments to create many EmailChangeRequests.
     * @example
     * // Create many EmailChangeRequests
     * const emailChangeRequest = await prisma.emailChangeRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailChangeRequestCreateManyArgs>(args?: SelectSubset<T, EmailChangeRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmailChangeRequests and returns the data saved in the database.
     * @param {EmailChangeRequestCreateManyAndReturnArgs} args - Arguments to create many EmailChangeRequests.
     * @example
     * // Create many EmailChangeRequests
     * const emailChangeRequest = await prisma.emailChangeRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmailChangeRequests and only return the `id`
     * const emailChangeRequestWithIdOnly = await prisma.emailChangeRequest.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmailChangeRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, EmailChangeRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailChangeRequestPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a EmailChangeRequest.
     * @param {EmailChangeRequestDeleteArgs} args - Arguments to delete one EmailChangeRequest.
     * @example
     * // Delete one EmailChangeRequest
     * const EmailChangeRequest = await prisma.emailChangeRequest.delete({
     *   where: {
     *     // ... filter to delete one EmailChangeRequest
     *   }
     * })
     * 
     */
    delete<T extends EmailChangeRequestDeleteArgs>(args: SelectSubset<T, EmailChangeRequestDeleteArgs<ExtArgs>>): Prisma__EmailChangeRequestClient<$Result.GetResult<Prisma.$EmailChangeRequestPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one EmailChangeRequest.
     * @param {EmailChangeRequestUpdateArgs} args - Arguments to update one EmailChangeRequest.
     * @example
     * // Update one EmailChangeRequest
     * const emailChangeRequest = await prisma.emailChangeRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailChangeRequestUpdateArgs>(args: SelectSubset<T, EmailChangeRequestUpdateArgs<ExtArgs>>): Prisma__EmailChangeRequestClient<$Result.GetResult<Prisma.$EmailChangeRequestPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more EmailChangeRequests.
     * @param {EmailChangeRequestDeleteManyArgs} args - Arguments to filter EmailChangeRequests to delete.
     * @example
     * // Delete a few EmailChangeRequests
     * const { count } = await prisma.emailChangeRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailChangeRequestDeleteManyArgs>(args?: SelectSubset<T, EmailChangeRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailChangeRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailChangeRequests
     * const emailChangeRequest = await prisma.emailChangeRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailChangeRequestUpdateManyArgs>(args: SelectSubset<T, EmailChangeRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailChangeRequests and returns the data updated in the database.
     * @param {EmailChangeRequestUpdateManyAndReturnArgs} args - Arguments to update many EmailChangeRequests.
     * @example
     * // Update many EmailChangeRequests
     * const emailChangeRequest = await prisma.emailChangeRequest.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more EmailChangeRequests and only return the `id`
     * const emailChangeRequestWithIdOnly = await prisma.emailChangeRequest.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EmailChangeRequestUpdateManyAndReturnArgs>(args: SelectSubset<T, EmailChangeRequestUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailChangeRequestPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one EmailChangeRequest.
     * @param {EmailChangeRequestUpsertArgs} args - Arguments to update or create a EmailChangeRequest.
     * @example
     * // Update or create a EmailChangeRequest
     * const emailChangeRequest = await prisma.emailChangeRequest.upsert({
     *   create: {
     *     // ... data to create a EmailChangeRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailChangeRequest we want to update
     *   }
     * })
     */
    upsert<T extends EmailChangeRequestUpsertArgs>(args: SelectSubset<T, EmailChangeRequestUpsertArgs<ExtArgs>>): Prisma__EmailChangeRequestClient<$Result.GetResult<Prisma.$EmailChangeRequestPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of EmailChangeRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeRequestCountArgs} args - Arguments to filter EmailChangeRequests to count.
     * @example
     * // Count the number of EmailChangeRequests
     * const count = await prisma.emailChangeRequest.count({
     *   where: {
     *     // ... the filter for the EmailChangeRequests we want to count
     *   }
     * })
    **/
    count<T extends EmailChangeRequestCountArgs>(
      args?: Subset<T, EmailChangeRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailChangeRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailChangeRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailChangeRequestAggregateArgs>(args: Subset<T, EmailChangeRequestAggregateArgs>): Prisma.PrismaPromise<GetEmailChangeRequestAggregateType<T>>

    /**
     * Group by EmailChangeRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailChangeRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailChangeRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailChangeRequestGroupByArgs['orderBy'] }
        : { orderBy?: EmailChangeRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailChangeRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailChangeRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailChangeRequest model
   */
  readonly fields: EmailChangeRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailChangeRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailChangeRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailChangeRequest model
   */
  interface EmailChangeRequestFieldRefs {
    readonly id: FieldRef<"EmailChangeRequest", 'String'>
    readonly userId: FieldRef<"EmailChangeRequest", 'String'>
    readonly newEmail: FieldRef<"EmailChangeRequest", 'String'>
    readonly token: FieldRef<"EmailChangeRequest", 'String'>
    readonly expires: FieldRef<"EmailChangeRequest", 'DateTime'>
    readonly usedAt: FieldRef<"EmailChangeRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailChangeRequest findUnique
   */
  export type EmailChangeRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which EmailChangeRequest to fetch.
     */
    where: EmailChangeRequestWhereUniqueInput
  }

  /**
   * EmailChangeRequest findUniqueOrThrow
   */
  export type EmailChangeRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which EmailChangeRequest to fetch.
     */
    where: EmailChangeRequestWhereUniqueInput
  }

  /**
   * EmailChangeRequest findFirst
   */
  export type EmailChangeRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which EmailChangeRequest to fetch.
     */
    where?: EmailChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailChangeRequests to fetch.
     */
    orderBy?: EmailChangeRequestOrderByWithRelationInput | EmailChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailChangeRequests.
     */
    cursor?: EmailChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` EmailChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailChangeRequests.
     */
    distinct?: EmailChangeRequestScalarFieldEnum | EmailChangeRequestScalarFieldEnum[]
  }

  /**
   * EmailChangeRequest findFirstOrThrow
   */
  export type EmailChangeRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which EmailChangeRequest to fetch.
     */
    where?: EmailChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailChangeRequests to fetch.
     */
    orderBy?: EmailChangeRequestOrderByWithRelationInput | EmailChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailChangeRequests.
     */
    cursor?: EmailChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` EmailChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailChangeRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailChangeRequests.
     */
    distinct?: EmailChangeRequestScalarFieldEnum | EmailChangeRequestScalarFieldEnum[]
  }

  /**
   * EmailChangeRequest findMany
   */
  export type EmailChangeRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestInclude<ExtArgs> | null
    /**
     * Filter, which EmailChangeRequests to fetch.
     */
    where?: EmailChangeRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailChangeRequests to fetch.
     */
    orderBy?: EmailChangeRequestOrderByWithRelationInput | EmailChangeRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailChangeRequests.
     */
    cursor?: EmailChangeRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` EmailChangeRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailChangeRequests.
     */
    skip?: number
    distinct?: EmailChangeRequestScalarFieldEnum | EmailChangeRequestScalarFieldEnum[]
  }

  /**
   * EmailChangeRequest create
   */
  export type EmailChangeRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailChangeRequest.
     */
    data: XOR<EmailChangeRequestCreateInput, EmailChangeRequestUncheckedCreateInput>
  }

  /**
   * EmailChangeRequest createMany
   */
  export type EmailChangeRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailChangeRequests.
     */
    data: EmailChangeRequestCreateManyInput | EmailChangeRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailChangeRequest createManyAndReturn
   */
  export type EmailChangeRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * The data used to create many EmailChangeRequests.
     */
    data: EmailChangeRequestCreateManyInput | EmailChangeRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailChangeRequest update
   */
  export type EmailChangeRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailChangeRequest.
     */
    data: XOR<EmailChangeRequestUpdateInput, EmailChangeRequestUncheckedUpdateInput>
    /**
     * Choose, which EmailChangeRequest to update.
     */
    where: EmailChangeRequestWhereUniqueInput
  }

  /**
   * EmailChangeRequest updateMany
   */
  export type EmailChangeRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailChangeRequests.
     */
    data: XOR<EmailChangeRequestUpdateManyMutationInput, EmailChangeRequestUncheckedUpdateManyInput>
    /**
     * Filter which EmailChangeRequests to update
     */
    where?: EmailChangeRequestWhereInput
    /**
     * Limit how many EmailChangeRequests to update.
     */
    limit?: number
  }

  /**
   * EmailChangeRequest updateManyAndReturn
   */
  export type EmailChangeRequestUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * The data used to update EmailChangeRequests.
     */
    data: XOR<EmailChangeRequestUpdateManyMutationInput, EmailChangeRequestUncheckedUpdateManyInput>
    /**
     * Filter which EmailChangeRequests to update
     */
    where?: EmailChangeRequestWhereInput
    /**
     * Limit how many EmailChangeRequests to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmailChangeRequest upsert
   */
  export type EmailChangeRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailChangeRequest to update in case it exists.
     */
    where: EmailChangeRequestWhereUniqueInput
    /**
     * In case the EmailChangeRequest found by the `where` argument doesn't exist, create a new EmailChangeRequest with this data.
     */
    create: XOR<EmailChangeRequestCreateInput, EmailChangeRequestUncheckedCreateInput>
    /**
     * In case the EmailChangeRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailChangeRequestUpdateInput, EmailChangeRequestUncheckedUpdateInput>
  }

  /**
   * EmailChangeRequest delete
   */
  export type EmailChangeRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestInclude<ExtArgs> | null
    /**
     * Filter which EmailChangeRequest to delete.
     */
    where: EmailChangeRequestWhereUniqueInput
  }

  /**
   * EmailChangeRequest deleteMany
   */
  export type EmailChangeRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailChangeRequests to delete
     */
    where?: EmailChangeRequestWhereInput
    /**
     * Limit how many EmailChangeRequests to delete.
     */
    limit?: number
  }

  /**
   * EmailChangeRequest without action
   */
  export type EmailChangeRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailChangeRequest
     */
    select?: EmailChangeRequestSelect<ExtArgs> | null
    /**
     * Omit specific fields from the EmailChangeRequest
     */
    omit?: EmailChangeRequestOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailChangeRequestInclude<ExtArgs> | null
  }


  /**
   * Model Device
   */

  export type AggregateDevice = {
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  export type DeviceMinAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceType: $Enums.DeviceType | null
    deviceId: string | null
    model: string | null
    fcmToken: string | null
    lastActive: Date | null
  }

  export type DeviceMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    deviceType: $Enums.DeviceType | null
    deviceId: string | null
    model: string | null
    fcmToken: string | null
    lastActive: Date | null
  }

  export type DeviceCountAggregateOutputType = {
    id: number
    userId: number
    deviceType: number
    deviceId: number
    model: number
    fcmToken: number
    lastActive: number
    _all: number
  }


  export type DeviceMinAggregateInputType = {
    id?: true
    userId?: true
    deviceType?: true
    deviceId?: true
    model?: true
    fcmToken?: true
    lastActive?: true
  }

  export type DeviceMaxAggregateInputType = {
    id?: true
    userId?: true
    deviceType?: true
    deviceId?: true
    model?: true
    fcmToken?: true
    lastActive?: true
  }

  export type DeviceCountAggregateInputType = {
    id?: true
    userId?: true
    deviceType?: true
    deviceId?: true
    model?: true
    fcmToken?: true
    lastActive?: true
    _all?: true
  }

  export type DeviceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Device to aggregate.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Devices
    **/
    _count?: true | DeviceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DeviceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DeviceMaxAggregateInputType
  }

  export type GetDeviceAggregateType<T extends DeviceAggregateArgs> = {
        [P in keyof T & keyof AggregateDevice]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDevice[P]>
      : GetScalarType<T[P], AggregateDevice[P]>
  }




  export type DeviceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DeviceWhereInput
    orderBy?: DeviceOrderByWithAggregationInput | DeviceOrderByWithAggregationInput[]
    by: DeviceScalarFieldEnum[] | DeviceScalarFieldEnum
    having?: DeviceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DeviceCountAggregateInputType | true
    _min?: DeviceMinAggregateInputType
    _max?: DeviceMaxAggregateInputType
  }

  export type DeviceGroupByOutputType = {
    id: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceId: string | null
    model: string | null
    fcmToken: string | null
    lastActive: Date
    _count: DeviceCountAggregateOutputType | null
    _min: DeviceMinAggregateOutputType | null
    _max: DeviceMaxAggregateOutputType | null
  }

  type GetDeviceGroupByPayload<T extends DeviceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DeviceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DeviceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DeviceGroupByOutputType[P]>
            : GetScalarType<T[P], DeviceGroupByOutputType[P]>
        }
      >
    >


  export type DeviceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceId?: boolean
    model?: boolean
    fcmToken?: boolean
    lastActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceId?: boolean
    model?: boolean
    fcmToken?: boolean
    lastActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceId?: boolean
    model?: boolean
    fcmToken?: boolean
    lastActive?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["device"]>

  export type DeviceSelectScalar = {
    id?: boolean
    userId?: boolean
    deviceType?: boolean
    deviceId?: boolean
    model?: boolean
    fcmToken?: boolean
    lastActive?: boolean
  }

  export type DeviceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "deviceType" | "deviceId" | "model" | "fcmToken" | "lastActive", ExtArgs["result"]["device"]>
  export type DeviceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type DeviceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $DevicePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Device"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      deviceType: $Enums.DeviceType
      deviceId: string | null
      model: string | null
      fcmToken: string | null
      lastActive: Date
    }, ExtArgs["result"]["device"]>
    composites: {}
  }

  type DeviceGetPayload<S extends boolean | null | undefined | DeviceDefaultArgs> = $Result.GetResult<Prisma.$DevicePayload, S>

  type DeviceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<DeviceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: DeviceCountAggregateInputType | true
    }

  export interface DeviceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Device'], meta: { name: 'Device' } }
    /**
     * Find zero or one Device that matches the filter.
     * @param {DeviceFindUniqueArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DeviceFindUniqueArgs>(args: SelectSubset<T, DeviceFindUniqueArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Device that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {DeviceFindUniqueOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DeviceFindUniqueOrThrowArgs>(args: SelectSubset<T, DeviceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DeviceFindFirstArgs>(args?: SelectSubset<T, DeviceFindFirstArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Device that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindFirstOrThrowArgs} args - Arguments to find a Device
     * @example
     * // Get one Device
     * const device = await prisma.device.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DeviceFindFirstOrThrowArgs>(args?: SelectSubset<T, DeviceFindFirstOrThrowArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Devices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Devices
     * const devices = await prisma.device.findMany()
     * 
     * // Get first 10 Devices
     * const devices = await prisma.device.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const deviceWithIdOnly = await prisma.device.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DeviceFindManyArgs>(args?: SelectSubset<T, DeviceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Device.
     * @param {DeviceCreateArgs} args - Arguments to create a Device.
     * @example
     * // Create one Device
     * const Device = await prisma.device.create({
     *   data: {
     *     // ... data to create a Device
     *   }
     * })
     * 
     */
    create<T extends DeviceCreateArgs>(args: SelectSubset<T, DeviceCreateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Devices.
     * @param {DeviceCreateManyArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DeviceCreateManyArgs>(args?: SelectSubset<T, DeviceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Devices and returns the data saved in the database.
     * @param {DeviceCreateManyAndReturnArgs} args - Arguments to create many Devices.
     * @example
     * // Create many Devices
     * const device = await prisma.device.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DeviceCreateManyAndReturnArgs>(args?: SelectSubset<T, DeviceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Device.
     * @param {DeviceDeleteArgs} args - Arguments to delete one Device.
     * @example
     * // Delete one Device
     * const Device = await prisma.device.delete({
     *   where: {
     *     // ... filter to delete one Device
     *   }
     * })
     * 
     */
    delete<T extends DeviceDeleteArgs>(args: SelectSubset<T, DeviceDeleteArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Device.
     * @param {DeviceUpdateArgs} args - Arguments to update one Device.
     * @example
     * // Update one Device
     * const device = await prisma.device.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DeviceUpdateArgs>(args: SelectSubset<T, DeviceUpdateArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Devices.
     * @param {DeviceDeleteManyArgs} args - Arguments to filter Devices to delete.
     * @example
     * // Delete a few Devices
     * const { count } = await prisma.device.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DeviceDeleteManyArgs>(args?: SelectSubset<T, DeviceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DeviceUpdateManyArgs>(args: SelectSubset<T, DeviceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Devices and returns the data updated in the database.
     * @param {DeviceUpdateManyAndReturnArgs} args - Arguments to update many Devices.
     * @example
     * // Update many Devices
     * const device = await prisma.device.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Devices and only return the `id`
     * const deviceWithIdOnly = await prisma.device.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends DeviceUpdateManyAndReturnArgs>(args: SelectSubset<T, DeviceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Device.
     * @param {DeviceUpsertArgs} args - Arguments to update or create a Device.
     * @example
     * // Update or create a Device
     * const device = await prisma.device.upsert({
     *   create: {
     *     // ... data to create a Device
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Device we want to update
     *   }
     * })
     */
    upsert<T extends DeviceUpsertArgs>(args: SelectSubset<T, DeviceUpsertArgs<ExtArgs>>): Prisma__DeviceClient<$Result.GetResult<Prisma.$DevicePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Devices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceCountArgs} args - Arguments to filter Devices to count.
     * @example
     * // Count the number of Devices
     * const count = await prisma.device.count({
     *   where: {
     *     // ... the filter for the Devices we want to count
     *   }
     * })
    **/
    count<T extends DeviceCountArgs>(
      args?: Subset<T, DeviceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DeviceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DeviceAggregateArgs>(args: Subset<T, DeviceAggregateArgs>): Prisma.PrismaPromise<GetDeviceAggregateType<T>>

    /**
     * Group by Device.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DeviceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DeviceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DeviceGroupByArgs['orderBy'] }
        : { orderBy?: DeviceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DeviceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDeviceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Device model
   */
  readonly fields: DeviceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Device.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DeviceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Device model
   */
  interface DeviceFieldRefs {
    readonly id: FieldRef<"Device", 'String'>
    readonly userId: FieldRef<"Device", 'String'>
    readonly deviceType: FieldRef<"Device", 'DeviceType'>
    readonly deviceId: FieldRef<"Device", 'String'>
    readonly model: FieldRef<"Device", 'String'>
    readonly fcmToken: FieldRef<"Device", 'String'>
    readonly lastActive: FieldRef<"Device", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Device findUnique
   */
  export type DeviceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findUniqueOrThrow
   */
  export type DeviceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device findFirst
   */
  export type DeviceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findFirstOrThrow
   */
  export type DeviceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Device to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Devices.
     */
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device findMany
   */
  export type DeviceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter, which Devices to fetch.
     */
    where?: DeviceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Devices to fetch.
     */
    orderBy?: DeviceOrderByWithRelationInput | DeviceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Devices.
     */
    cursor?: DeviceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Devices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Devices.
     */
    skip?: number
    distinct?: DeviceScalarFieldEnum | DeviceScalarFieldEnum[]
  }

  /**
   * Device create
   */
  export type DeviceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to create a Device.
     */
    data: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
  }

  /**
   * Device createMany
   */
  export type DeviceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Device createManyAndReturn
   */
  export type DeviceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to create many Devices.
     */
    data: DeviceCreateManyInput | DeviceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device update
   */
  export type DeviceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The data needed to update a Device.
     */
    data: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
    /**
     * Choose, which Device to update.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device updateMany
   */
  export type DeviceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
  }

  /**
   * Device updateManyAndReturn
   */
  export type DeviceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * The data used to update Devices.
     */
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyInput>
    /**
     * Filter which Devices to update
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Device upsert
   */
  export type DeviceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * The filter to search for the Device to update in case it exists.
     */
    where: DeviceWhereUniqueInput
    /**
     * In case the Device found by the `where` argument doesn't exist, create a new Device with this data.
     */
    create: XOR<DeviceCreateInput, DeviceUncheckedCreateInput>
    /**
     * In case the Device was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DeviceUpdateInput, DeviceUncheckedUpdateInput>
  }

  /**
   * Device delete
   */
  export type DeviceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
    /**
     * Filter which Device to delete.
     */
    where: DeviceWhereUniqueInput
  }

  /**
   * Device deleteMany
   */
  export type DeviceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Devices to delete
     */
    where?: DeviceWhereInput
    /**
     * Limit how many Devices to delete.
     */
    limit?: number
  }

  /**
   * Device without action
   */
  export type DeviceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Device
     */
    select?: DeviceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Device
     */
    omit?: DeviceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DeviceInclude<ExtArgs> | null
  }


  /**
   * Model TeacherProfile
   */

  export type AggregateTeacherProfile = {
    _count: TeacherProfileCountAggregateOutputType | null
    _min: TeacherProfileMinAggregateOutputType | null
    _max: TeacherProfileMaxAggregateOutputType | null
  }

  export type TeacherProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    branch: string | null
    bio: string | null
  }

  export type TeacherProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    branch: string | null
    bio: string | null
  }

  export type TeacherProfileCountAggregateOutputType = {
    id: number
    userId: number
    branch: number
    bio: number
    _all: number
  }


  export type TeacherProfileMinAggregateInputType = {
    id?: true
    userId?: true
    branch?: true
    bio?: true
  }

  export type TeacherProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    branch?: true
    bio?: true
  }

  export type TeacherProfileCountAggregateInputType = {
    id?: true
    userId?: true
    branch?: true
    bio?: true
    _all?: true
  }

  export type TeacherProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherProfile to aggregate.
     */
    where?: TeacherProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherProfiles to fetch.
     */
    orderBy?: TeacherProfileOrderByWithRelationInput | TeacherProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeacherProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` TeacherProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeacherProfiles
    **/
    _count?: true | TeacherProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeacherProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeacherProfileMaxAggregateInputType
  }

  export type GetTeacherProfileAggregateType<T extends TeacherProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateTeacherProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeacherProfile[P]>
      : GetScalarType<T[P], AggregateTeacherProfile[P]>
  }




  export type TeacherProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeacherProfileWhereInput
    orderBy?: TeacherProfileOrderByWithAggregationInput | TeacherProfileOrderByWithAggregationInput[]
    by: TeacherProfileScalarFieldEnum[] | TeacherProfileScalarFieldEnum
    having?: TeacherProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeacherProfileCountAggregateInputType | true
    _min?: TeacherProfileMinAggregateInputType
    _max?: TeacherProfileMaxAggregateInputType
  }

  export type TeacherProfileGroupByOutputType = {
    id: string
    userId: string
    branch: string
    bio: string | null
    _count: TeacherProfileCountAggregateOutputType | null
    _min: TeacherProfileMinAggregateOutputType | null
    _max: TeacherProfileMaxAggregateOutputType | null
  }

  type GetTeacherProfileGroupByPayload<T extends TeacherProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeacherProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeacherProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeacherProfileGroupByOutputType[P]>
            : GetScalarType<T[P], TeacherProfileGroupByOutputType[P]>
        }
      >
    >


  export type TeacherProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branch?: boolean
    bio?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    studentRelations?: boolean | TeacherProfile$studentRelationsArgs<ExtArgs>
    classes?: boolean | TeacherProfile$classesArgs<ExtArgs>
    lessons?: boolean | TeacherProfile$lessonsArgs<ExtArgs>
    payments?: boolean | TeacherProfile$paymentsArgs<ExtArgs>
    scheduleItems?: boolean | TeacherProfile$scheduleItemsArgs<ExtArgs>
    _count?: boolean | TeacherProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherProfile"]>

  export type TeacherProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branch?: boolean
    bio?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherProfile"]>

  export type TeacherProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    branch?: boolean
    bio?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teacherProfile"]>

  export type TeacherProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    branch?: boolean
    bio?: boolean
  }

  export type TeacherProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "branch" | "bio", ExtArgs["result"]["teacherProfile"]>
  export type TeacherProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    studentRelations?: boolean | TeacherProfile$studentRelationsArgs<ExtArgs>
    classes?: boolean | TeacherProfile$classesArgs<ExtArgs>
    lessons?: boolean | TeacherProfile$lessonsArgs<ExtArgs>
    payments?: boolean | TeacherProfile$paymentsArgs<ExtArgs>
    scheduleItems?: boolean | TeacherProfile$scheduleItemsArgs<ExtArgs>
    _count?: boolean | TeacherProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TeacherProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TeacherProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeacherProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeacherProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      studentRelations: Prisma.$StudentTeacherRelationPayload<ExtArgs>[]
      classes: Prisma.$ClassroomPayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      scheduleItems: Prisma.$ScheduleItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      branch: string
      bio: string | null
    }, ExtArgs["result"]["teacherProfile"]>
    composites: {}
  }

  type TeacherProfileGetPayload<S extends boolean | null | undefined | TeacherProfileDefaultArgs> = $Result.GetResult<Prisma.$TeacherProfilePayload, S>

  type TeacherProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TeacherProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TeacherProfileCountAggregateInputType | true
    }

  export interface TeacherProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeacherProfile'], meta: { name: 'TeacherProfile' } }
    /**
     * Find zero or one TeacherProfile that matches the filter.
     * @param {TeacherProfileFindUniqueArgs} args - Arguments to find a TeacherProfile
     * @example
     * // Get one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeacherProfileFindUniqueArgs>(args: SelectSubset<T, TeacherProfileFindUniqueArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TeacherProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TeacherProfileFindUniqueOrThrowArgs} args - Arguments to find a TeacherProfile
     * @example
     * // Get one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeacherProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, TeacherProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileFindFirstArgs} args - Arguments to find a TeacherProfile
     * @example
     * // Get one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeacherProfileFindFirstArgs>(args?: SelectSubset<T, TeacherProfileFindFirstArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TeacherProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileFindFirstOrThrowArgs} args - Arguments to find a TeacherProfile
     * @example
     * // Get one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeacherProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, TeacherProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TeacherProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeacherProfiles
     * const teacherProfiles = await prisma.teacherProfile.findMany()
     * 
     * // Get first 10 TeacherProfiles
     * const teacherProfiles = await prisma.teacherProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teacherProfileWithIdOnly = await prisma.teacherProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeacherProfileFindManyArgs>(args?: SelectSubset<T, TeacherProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TeacherProfile.
     * @param {TeacherProfileCreateArgs} args - Arguments to create a TeacherProfile.
     * @example
     * // Create one TeacherProfile
     * const TeacherProfile = await prisma.teacherProfile.create({
     *   data: {
     *     // ... data to create a TeacherProfile
     *   }
     * })
     * 
     */
    create<T extends TeacherProfileCreateArgs>(args: SelectSubset<T, TeacherProfileCreateArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TeacherProfiles.
     * @param {TeacherProfileCreateManyArgs} args - Arguments to create many TeacherProfiles.
     * @example
     * // Create many TeacherProfiles
     * const teacherProfile = await prisma.teacherProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeacherProfileCreateManyArgs>(args?: SelectSubset<T, TeacherProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TeacherProfiles and returns the data saved in the database.
     * @param {TeacherProfileCreateManyAndReturnArgs} args - Arguments to create many TeacherProfiles.
     * @example
     * // Create many TeacherProfiles
     * const teacherProfile = await prisma.teacherProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TeacherProfiles and only return the `id`
     * const teacherProfileWithIdOnly = await prisma.teacherProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TeacherProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, TeacherProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TeacherProfile.
     * @param {TeacherProfileDeleteArgs} args - Arguments to delete one TeacherProfile.
     * @example
     * // Delete one TeacherProfile
     * const TeacherProfile = await prisma.teacherProfile.delete({
     *   where: {
     *     // ... filter to delete one TeacherProfile
     *   }
     * })
     * 
     */
    delete<T extends TeacherProfileDeleteArgs>(args: SelectSubset<T, TeacherProfileDeleteArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TeacherProfile.
     * @param {TeacherProfileUpdateArgs} args - Arguments to update one TeacherProfile.
     * @example
     * // Update one TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeacherProfileUpdateArgs>(args: SelectSubset<T, TeacherProfileUpdateArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TeacherProfiles.
     * @param {TeacherProfileDeleteManyArgs} args - Arguments to filter TeacherProfiles to delete.
     * @example
     * // Delete a few TeacherProfiles
     * const { count } = await prisma.teacherProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeacherProfileDeleteManyArgs>(args?: SelectSubset<T, TeacherProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeacherProfiles
     * const teacherProfile = await prisma.teacherProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeacherProfileUpdateManyArgs>(args: SelectSubset<T, TeacherProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeacherProfiles and returns the data updated in the database.
     * @param {TeacherProfileUpdateManyAndReturnArgs} args - Arguments to update many TeacherProfiles.
     * @example
     * // Update many TeacherProfiles
     * const teacherProfile = await prisma.teacherProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TeacherProfiles and only return the `id`
     * const teacherProfileWithIdOnly = await prisma.teacherProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TeacherProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, TeacherProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TeacherProfile.
     * @param {TeacherProfileUpsertArgs} args - Arguments to update or create a TeacherProfile.
     * @example
     * // Update or create a TeacherProfile
     * const teacherProfile = await prisma.teacherProfile.upsert({
     *   create: {
     *     // ... data to create a TeacherProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeacherProfile we want to update
     *   }
     * })
     */
    upsert<T extends TeacherProfileUpsertArgs>(args: SelectSubset<T, TeacherProfileUpsertArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TeacherProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileCountArgs} args - Arguments to filter TeacherProfiles to count.
     * @example
     * // Count the number of TeacherProfiles
     * const count = await prisma.teacherProfile.count({
     *   where: {
     *     // ... the filter for the TeacherProfiles we want to count
     *   }
     * })
    **/
    count<T extends TeacherProfileCountArgs>(
      args?: Subset<T, TeacherProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeacherProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeacherProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeacherProfileAggregateArgs>(args: Subset<T, TeacherProfileAggregateArgs>): Prisma.PrismaPromise<GetTeacherProfileAggregateType<T>>

    /**
     * Group by TeacherProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeacherProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeacherProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeacherProfileGroupByArgs['orderBy'] }
        : { orderBy?: TeacherProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeacherProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeacherProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeacherProfile model
   */
  readonly fields: TeacherProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeacherProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeacherProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    studentRelations<T extends TeacherProfile$studentRelationsArgs<ExtArgs> = {}>(args?: Subset<T, TeacherProfile$studentRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classes<T extends TeacherProfile$classesArgs<ExtArgs> = {}>(args?: Subset<T, TeacherProfile$classesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessons<T extends TeacherProfile$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, TeacherProfile$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends TeacherProfile$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, TeacherProfile$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    scheduleItems<T extends TeacherProfile$scheduleItemsArgs<ExtArgs> = {}>(args?: Subset<T, TeacherProfile$scheduleItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeacherProfile model
   */
  interface TeacherProfileFieldRefs {
    readonly id: FieldRef<"TeacherProfile", 'String'>
    readonly userId: FieldRef<"TeacherProfile", 'String'>
    readonly branch: FieldRef<"TeacherProfile", 'String'>
    readonly bio: FieldRef<"TeacherProfile", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TeacherProfile findUnique
   */
  export type TeacherProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfile to fetch.
     */
    where: TeacherProfileWhereUniqueInput
  }

  /**
   * TeacherProfile findUniqueOrThrow
   */
  export type TeacherProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfile to fetch.
     */
    where: TeacherProfileWhereUniqueInput
  }

  /**
   * TeacherProfile findFirst
   */
  export type TeacherProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfile to fetch.
     */
    where?: TeacherProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherProfiles to fetch.
     */
    orderBy?: TeacherProfileOrderByWithRelationInput | TeacherProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherProfiles.
     */
    cursor?: TeacherProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` TeacherProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherProfiles.
     */
    distinct?: TeacherProfileScalarFieldEnum | TeacherProfileScalarFieldEnum[]
  }

  /**
   * TeacherProfile findFirstOrThrow
   */
  export type TeacherProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfile to fetch.
     */
    where?: TeacherProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherProfiles to fetch.
     */
    orderBy?: TeacherProfileOrderByWithRelationInput | TeacherProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeacherProfiles.
     */
    cursor?: TeacherProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` TeacherProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeacherProfiles.
     */
    distinct?: TeacherProfileScalarFieldEnum | TeacherProfileScalarFieldEnum[]
  }

  /**
   * TeacherProfile findMany
   */
  export type TeacherProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter, which TeacherProfiles to fetch.
     */
    where?: TeacherProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeacherProfiles to fetch.
     */
    orderBy?: TeacherProfileOrderByWithRelationInput | TeacherProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeacherProfiles.
     */
    cursor?: TeacherProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` TeacherProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeacherProfiles.
     */
    skip?: number
    distinct?: TeacherProfileScalarFieldEnum | TeacherProfileScalarFieldEnum[]
  }

  /**
   * TeacherProfile create
   */
  export type TeacherProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a TeacherProfile.
     */
    data: XOR<TeacherProfileCreateInput, TeacherProfileUncheckedCreateInput>
  }

  /**
   * TeacherProfile createMany
   */
  export type TeacherProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeacherProfiles.
     */
    data: TeacherProfileCreateManyInput | TeacherProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeacherProfile createManyAndReturn
   */
  export type TeacherProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * The data used to create many TeacherProfiles.
     */
    data: TeacherProfileCreateManyInput | TeacherProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherProfile update
   */
  export type TeacherProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a TeacherProfile.
     */
    data: XOR<TeacherProfileUpdateInput, TeacherProfileUncheckedUpdateInput>
    /**
     * Choose, which TeacherProfile to update.
     */
    where: TeacherProfileWhereUniqueInput
  }

  /**
   * TeacherProfile updateMany
   */
  export type TeacherProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeacherProfiles.
     */
    data: XOR<TeacherProfileUpdateManyMutationInput, TeacherProfileUncheckedUpdateManyInput>
    /**
     * Filter which TeacherProfiles to update
     */
    where?: TeacherProfileWhereInput
    /**
     * Limit how many TeacherProfiles to update.
     */
    limit?: number
  }

  /**
   * TeacherProfile updateManyAndReturn
   */
  export type TeacherProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * The data used to update TeacherProfiles.
     */
    data: XOR<TeacherProfileUpdateManyMutationInput, TeacherProfileUncheckedUpdateManyInput>
    /**
     * Filter which TeacherProfiles to update
     */
    where?: TeacherProfileWhereInput
    /**
     * Limit how many TeacherProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TeacherProfile upsert
   */
  export type TeacherProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the TeacherProfile to update in case it exists.
     */
    where: TeacherProfileWhereUniqueInput
    /**
     * In case the TeacherProfile found by the `where` argument doesn't exist, create a new TeacherProfile with this data.
     */
    create: XOR<TeacherProfileCreateInput, TeacherProfileUncheckedCreateInput>
    /**
     * In case the TeacherProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeacherProfileUpdateInput, TeacherProfileUncheckedUpdateInput>
  }

  /**
   * TeacherProfile delete
   */
  export type TeacherProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    /**
     * Filter which TeacherProfile to delete.
     */
    where: TeacherProfileWhereUniqueInput
  }

  /**
   * TeacherProfile deleteMany
   */
  export type TeacherProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeacherProfiles to delete
     */
    where?: TeacherProfileWhereInput
    /**
     * Limit how many TeacherProfiles to delete.
     */
    limit?: number
  }

  /**
   * TeacherProfile.studentRelations
   */
  export type TeacherProfile$studentRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationInclude<ExtArgs> | null
    where?: StudentTeacherRelationWhereInput
    orderBy?: StudentTeacherRelationOrderByWithRelationInput | StudentTeacherRelationOrderByWithRelationInput[]
    cursor?: StudentTeacherRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTeacherRelationScalarFieldEnum | StudentTeacherRelationScalarFieldEnum[]
  }

  /**
   * TeacherProfile.classes
   */
  export type TeacherProfile$classesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    where?: ClassroomWhereInput
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    cursor?: ClassroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * TeacherProfile.lessons
   */
  export type TeacherProfile$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * TeacherProfile.payments
   */
  export type TeacherProfile$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * TeacherProfile.scheduleItems
   */
  export type TeacherProfile$scheduleItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    where?: ScheduleItemWhereInput
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    cursor?: ScheduleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * TeacherProfile without action
   */
  export type TeacherProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
  }


  /**
   * Model StudentProfile
   */

  export type AggregateStudentProfile = {
    _count: StudentProfileCountAggregateOutputType | null
    _min: StudentProfileMinAggregateOutputType | null
    _max: StudentProfileMaxAggregateOutputType | null
  }

  export type StudentProfileMinAggregateOutputType = {
    id: string | null
    userId: string | null
    tempFirstName: string | null
    tempLastName: string | null
    tempPhone: string | null
    tempEmail: string | null
    tempAvatarKey: string | null
    inviteToken: string | null
    inviteTokenExpires: Date | null
    isClaimed: boolean | null
    creatorTeacherId: string | null
    studentNo: string | null
    gradeLevel: string | null
    parentName: string | null
    parentPhone: string | null
    parentEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentProfileMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    tempFirstName: string | null
    tempLastName: string | null
    tempPhone: string | null
    tempEmail: string | null
    tempAvatarKey: string | null
    inviteToken: string | null
    inviteTokenExpires: Date | null
    isClaimed: boolean | null
    creatorTeacherId: string | null
    studentNo: string | null
    gradeLevel: string | null
    parentName: string | null
    parentPhone: string | null
    parentEmail: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentProfileCountAggregateOutputType = {
    id: number
    userId: number
    tempFirstName: number
    tempLastName: number
    tempPhone: number
    tempEmail: number
    tempAvatarKey: number
    inviteToken: number
    inviteTokenExpires: number
    isClaimed: number
    creatorTeacherId: number
    studentNo: number
    gradeLevel: number
    parentName: number
    parentPhone: number
    parentEmail: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentProfileMinAggregateInputType = {
    id?: true
    userId?: true
    tempFirstName?: true
    tempLastName?: true
    tempPhone?: true
    tempEmail?: true
    tempAvatarKey?: true
    inviteToken?: true
    inviteTokenExpires?: true
    isClaimed?: true
    creatorTeacherId?: true
    studentNo?: true
    gradeLevel?: true
    parentName?: true
    parentPhone?: true
    parentEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentProfileMaxAggregateInputType = {
    id?: true
    userId?: true
    tempFirstName?: true
    tempLastName?: true
    tempPhone?: true
    tempEmail?: true
    tempAvatarKey?: true
    inviteToken?: true
    inviteTokenExpires?: true
    isClaimed?: true
    creatorTeacherId?: true
    studentNo?: true
    gradeLevel?: true
    parentName?: true
    parentPhone?: true
    parentEmail?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentProfileCountAggregateInputType = {
    id?: true
    userId?: true
    tempFirstName?: true
    tempLastName?: true
    tempPhone?: true
    tempEmail?: true
    tempAvatarKey?: true
    inviteToken?: true
    inviteTokenExpires?: true
    isClaimed?: true
    creatorTeacherId?: true
    studentNo?: true
    gradeLevel?: true
    parentName?: true
    parentPhone?: true
    parentEmail?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentProfileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentProfile to aggregate.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentProfiles
    **/
    _count?: true | StudentProfileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentProfileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentProfileMaxAggregateInputType
  }

  export type GetStudentProfileAggregateType<T extends StudentProfileAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentProfile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentProfile[P]>
      : GetScalarType<T[P], AggregateStudentProfile[P]>
  }




  export type StudentProfileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentProfileWhereInput
    orderBy?: StudentProfileOrderByWithAggregationInput | StudentProfileOrderByWithAggregationInput[]
    by: StudentProfileScalarFieldEnum[] | StudentProfileScalarFieldEnum
    having?: StudentProfileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentProfileCountAggregateInputType | true
    _min?: StudentProfileMinAggregateInputType
    _max?: StudentProfileMaxAggregateInputType
  }

  export type StudentProfileGroupByOutputType = {
    id: string
    userId: string | null
    tempFirstName: string | null
    tempLastName: string | null
    tempPhone: string | null
    tempEmail: string | null
    tempAvatarKey: string | null
    inviteToken: string | null
    inviteTokenExpires: Date | null
    isClaimed: boolean
    creatorTeacherId: string | null
    studentNo: string | null
    gradeLevel: string | null
    parentName: string | null
    parentPhone: string | null
    parentEmail: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentProfileCountAggregateOutputType | null
    _min: StudentProfileMinAggregateOutputType | null
    _max: StudentProfileMaxAggregateOutputType | null
  }

  type GetStudentProfileGroupByPayload<T extends StudentProfileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentProfileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentProfileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentProfileGroupByOutputType[P]>
            : GetScalarType<T[P], StudentProfileGroupByOutputType[P]>
        }
      >
    >


  export type StudentProfileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tempFirstName?: boolean
    tempLastName?: boolean
    tempPhone?: boolean
    tempEmail?: boolean
    tempAvatarKey?: boolean
    inviteToken?: boolean
    inviteTokenExpires?: boolean
    isClaimed?: boolean
    creatorTeacherId?: boolean
    studentNo?: boolean
    gradeLevel?: boolean
    parentName?: boolean
    parentPhone?: boolean
    parentEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | StudentProfile$userArgs<ExtArgs>
    teacherRelations?: boolean | StudentProfile$teacherRelationsArgs<ExtArgs>
    classrooms?: boolean | StudentProfile$classroomsArgs<ExtArgs>
    recurringSchedules?: boolean | StudentProfile$recurringSchedulesArgs<ExtArgs>
    lessons?: boolean | StudentProfile$lessonsArgs<ExtArgs>
    homeworkTrackings?: boolean | StudentProfile$homeworkTrackingsArgs<ExtArgs>
    submissions?: boolean | StudentProfile$submissionsArgs<ExtArgs>
    payments?: boolean | StudentProfile$paymentsArgs<ExtArgs>
    grades?: boolean | StudentProfile$gradesArgs<ExtArgs>
    trialExams?: boolean | StudentProfile$trialExamsArgs<ExtArgs>
    attendances?: boolean | StudentProfile$attendancesArgs<ExtArgs>
    _count?: boolean | StudentProfileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentProfile"]>

  export type StudentProfileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tempFirstName?: boolean
    tempLastName?: boolean
    tempPhone?: boolean
    tempEmail?: boolean
    tempAvatarKey?: boolean
    inviteToken?: boolean
    inviteTokenExpires?: boolean
    isClaimed?: boolean
    creatorTeacherId?: boolean
    studentNo?: boolean
    gradeLevel?: boolean
    parentName?: boolean
    parentPhone?: boolean
    parentEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | StudentProfile$userArgs<ExtArgs>
  }, ExtArgs["result"]["studentProfile"]>

  export type StudentProfileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    tempFirstName?: boolean
    tempLastName?: boolean
    tempPhone?: boolean
    tempEmail?: boolean
    tempAvatarKey?: boolean
    inviteToken?: boolean
    inviteTokenExpires?: boolean
    isClaimed?: boolean
    creatorTeacherId?: boolean
    studentNo?: boolean
    gradeLevel?: boolean
    parentName?: boolean
    parentPhone?: boolean
    parentEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    user?: boolean | StudentProfile$userArgs<ExtArgs>
  }, ExtArgs["result"]["studentProfile"]>

  export type StudentProfileSelectScalar = {
    id?: boolean
    userId?: boolean
    tempFirstName?: boolean
    tempLastName?: boolean
    tempPhone?: boolean
    tempEmail?: boolean
    tempAvatarKey?: boolean
    inviteToken?: boolean
    inviteTokenExpires?: boolean
    isClaimed?: boolean
    creatorTeacherId?: boolean
    studentNo?: boolean
    gradeLevel?: boolean
    parentName?: boolean
    parentPhone?: boolean
    parentEmail?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentProfileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "userId" | "tempFirstName" | "tempLastName" | "tempPhone" | "tempEmail" | "tempAvatarKey" | "inviteToken" | "inviteTokenExpires" | "isClaimed" | "creatorTeacherId" | "studentNo" | "gradeLevel" | "parentName" | "parentPhone" | "parentEmail" | "createdAt" | "updatedAt", ExtArgs["result"]["studentProfile"]>
  export type StudentProfileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | StudentProfile$userArgs<ExtArgs>
    teacherRelations?: boolean | StudentProfile$teacherRelationsArgs<ExtArgs>
    classrooms?: boolean | StudentProfile$classroomsArgs<ExtArgs>
    recurringSchedules?: boolean | StudentProfile$recurringSchedulesArgs<ExtArgs>
    lessons?: boolean | StudentProfile$lessonsArgs<ExtArgs>
    homeworkTrackings?: boolean | StudentProfile$homeworkTrackingsArgs<ExtArgs>
    submissions?: boolean | StudentProfile$submissionsArgs<ExtArgs>
    payments?: boolean | StudentProfile$paymentsArgs<ExtArgs>
    grades?: boolean | StudentProfile$gradesArgs<ExtArgs>
    trialExams?: boolean | StudentProfile$trialExamsArgs<ExtArgs>
    attendances?: boolean | StudentProfile$attendancesArgs<ExtArgs>
    _count?: boolean | StudentProfileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type StudentProfileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | StudentProfile$userArgs<ExtArgs>
  }
  export type StudentProfileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | StudentProfile$userArgs<ExtArgs>
  }

  export type $StudentProfilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentProfile"
    objects: {
      user: Prisma.$UserPayload<ExtArgs> | null
      teacherRelations: Prisma.$StudentTeacherRelationPayload<ExtArgs>[]
      classrooms: Prisma.$ClassroomPayload<ExtArgs>[]
      recurringSchedules: Prisma.$ScheduleItemPayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
      homeworkTrackings: Prisma.$HomeworkTrackingPayload<ExtArgs>[]
      submissions: Prisma.$HomeworkSubmissionPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
      grades: Prisma.$SchoolExamPayload<ExtArgs>[]
      trialExams: Prisma.$TrialExamPayload<ExtArgs>[]
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      tempFirstName: string | null
      tempLastName: string | null
      tempPhone: string | null
      tempEmail: string | null
      tempAvatarKey: string | null
      inviteToken: string | null
      inviteTokenExpires: Date | null
      isClaimed: boolean
      creatorTeacherId: string | null
      studentNo: string | null
      gradeLevel: string | null
      parentName: string | null
      parentPhone: string | null
      parentEmail: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentProfile"]>
    composites: {}
  }

  type StudentProfileGetPayload<S extends boolean | null | undefined | StudentProfileDefaultArgs> = $Result.GetResult<Prisma.$StudentProfilePayload, S>

  type StudentProfileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentProfileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentProfileCountAggregateInputType | true
    }

  export interface StudentProfileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentProfile'], meta: { name: 'StudentProfile' } }
    /**
     * Find zero or one StudentProfile that matches the filter.
     * @param {StudentProfileFindUniqueArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentProfileFindUniqueArgs>(args: SelectSubset<T, StudentProfileFindUniqueArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentProfile that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentProfileFindUniqueOrThrowArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentProfileFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentProfileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentProfile that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileFindFirstArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentProfileFindFirstArgs>(args?: SelectSubset<T, StudentProfileFindFirstArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentProfile that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileFindFirstOrThrowArgs} args - Arguments to find a StudentProfile
     * @example
     * // Get one StudentProfile
     * const studentProfile = await prisma.studentProfile.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentProfileFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentProfileFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentProfiles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentProfiles
     * const studentProfiles = await prisma.studentProfile.findMany()
     * 
     * // Get first 10 StudentProfiles
     * const studentProfiles = await prisma.studentProfile.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentProfileWithIdOnly = await prisma.studentProfile.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentProfileFindManyArgs>(args?: SelectSubset<T, StudentProfileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentProfile.
     * @param {StudentProfileCreateArgs} args - Arguments to create a StudentProfile.
     * @example
     * // Create one StudentProfile
     * const StudentProfile = await prisma.studentProfile.create({
     *   data: {
     *     // ... data to create a StudentProfile
     *   }
     * })
     * 
     */
    create<T extends StudentProfileCreateArgs>(args: SelectSubset<T, StudentProfileCreateArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentProfiles.
     * @param {StudentProfileCreateManyArgs} args - Arguments to create many StudentProfiles.
     * @example
     * // Create many StudentProfiles
     * const studentProfile = await prisma.studentProfile.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentProfileCreateManyArgs>(args?: SelectSubset<T, StudentProfileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentProfiles and returns the data saved in the database.
     * @param {StudentProfileCreateManyAndReturnArgs} args - Arguments to create many StudentProfiles.
     * @example
     * // Create many StudentProfiles
     * const studentProfile = await prisma.studentProfile.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentProfiles and only return the `id`
     * const studentProfileWithIdOnly = await prisma.studentProfile.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentProfileCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentProfileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentProfile.
     * @param {StudentProfileDeleteArgs} args - Arguments to delete one StudentProfile.
     * @example
     * // Delete one StudentProfile
     * const StudentProfile = await prisma.studentProfile.delete({
     *   where: {
     *     // ... filter to delete one StudentProfile
     *   }
     * })
     * 
     */
    delete<T extends StudentProfileDeleteArgs>(args: SelectSubset<T, StudentProfileDeleteArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentProfile.
     * @param {StudentProfileUpdateArgs} args - Arguments to update one StudentProfile.
     * @example
     * // Update one StudentProfile
     * const studentProfile = await prisma.studentProfile.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentProfileUpdateArgs>(args: SelectSubset<T, StudentProfileUpdateArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentProfiles.
     * @param {StudentProfileDeleteManyArgs} args - Arguments to filter StudentProfiles to delete.
     * @example
     * // Delete a few StudentProfiles
     * const { count } = await prisma.studentProfile.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentProfileDeleteManyArgs>(args?: SelectSubset<T, StudentProfileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentProfiles
     * const studentProfile = await prisma.studentProfile.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentProfileUpdateManyArgs>(args: SelectSubset<T, StudentProfileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentProfiles and returns the data updated in the database.
     * @param {StudentProfileUpdateManyAndReturnArgs} args - Arguments to update many StudentProfiles.
     * @example
     * // Update many StudentProfiles
     * const studentProfile = await prisma.studentProfile.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentProfiles and only return the `id`
     * const studentProfileWithIdOnly = await prisma.studentProfile.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentProfileUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentProfileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentProfile.
     * @param {StudentProfileUpsertArgs} args - Arguments to update or create a StudentProfile.
     * @example
     * // Update or create a StudentProfile
     * const studentProfile = await prisma.studentProfile.upsert({
     *   create: {
     *     // ... data to create a StudentProfile
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentProfile we want to update
     *   }
     * })
     */
    upsert<T extends StudentProfileUpsertArgs>(args: SelectSubset<T, StudentProfileUpsertArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentProfiles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileCountArgs} args - Arguments to filter StudentProfiles to count.
     * @example
     * // Count the number of StudentProfiles
     * const count = await prisma.studentProfile.count({
     *   where: {
     *     // ... the filter for the StudentProfiles we want to count
     *   }
     * })
    **/
    count<T extends StudentProfileCountArgs>(
      args?: Subset<T, StudentProfileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentProfileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentProfileAggregateArgs>(args: Subset<T, StudentProfileAggregateArgs>): Prisma.PrismaPromise<GetStudentProfileAggregateType<T>>

    /**
     * Group by StudentProfile.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentProfileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentProfileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentProfileGroupByArgs['orderBy'] }
        : { orderBy?: StudentProfileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentProfileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentProfileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentProfile model
   */
  readonly fields: StudentProfileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentProfile.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentProfileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends StudentProfile$userArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$userArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacherRelations<T extends StudentProfile$teacherRelationsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$teacherRelationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classrooms<T extends StudentProfile$classroomsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$classroomsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    recurringSchedules<T extends StudentProfile$recurringSchedulesArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$recurringSchedulesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessons<T extends StudentProfile$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    homeworkTrackings<T extends StudentProfile$homeworkTrackingsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$homeworkTrackingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    submissions<T extends StudentProfile$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends StudentProfile$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    grades<T extends StudentProfile$gradesArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$gradesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    trialExams<T extends StudentProfile$trialExamsArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$trialExamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    attendances<T extends StudentProfile$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfile$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentProfile model
   */
  interface StudentProfileFieldRefs {
    readonly id: FieldRef<"StudentProfile", 'String'>
    readonly userId: FieldRef<"StudentProfile", 'String'>
    readonly tempFirstName: FieldRef<"StudentProfile", 'String'>
    readonly tempLastName: FieldRef<"StudentProfile", 'String'>
    readonly tempPhone: FieldRef<"StudentProfile", 'String'>
    readonly tempEmail: FieldRef<"StudentProfile", 'String'>
    readonly tempAvatarKey: FieldRef<"StudentProfile", 'String'>
    readonly inviteToken: FieldRef<"StudentProfile", 'String'>
    readonly inviteTokenExpires: FieldRef<"StudentProfile", 'DateTime'>
    readonly isClaimed: FieldRef<"StudentProfile", 'Boolean'>
    readonly creatorTeacherId: FieldRef<"StudentProfile", 'String'>
    readonly studentNo: FieldRef<"StudentProfile", 'String'>
    readonly gradeLevel: FieldRef<"StudentProfile", 'String'>
    readonly parentName: FieldRef<"StudentProfile", 'String'>
    readonly parentPhone: FieldRef<"StudentProfile", 'String'>
    readonly parentEmail: FieldRef<"StudentProfile", 'String'>
    readonly createdAt: FieldRef<"StudentProfile", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentProfile", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentProfile findUnique
   */
  export type StudentProfileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile findUniqueOrThrow
   */
  export type StudentProfileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile findFirst
   */
  export type StudentProfileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentProfiles.
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentProfiles.
     */
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * StudentProfile findFirstOrThrow
   */
  export type StudentProfileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfile to fetch.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentProfiles.
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentProfiles.
     */
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * StudentProfile findMany
   */
  export type StudentProfileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter, which StudentProfiles to fetch.
     */
    where?: StudentProfileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentProfiles to fetch.
     */
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentProfiles.
     */
    cursor?: StudentProfileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` StudentProfiles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentProfiles.
     */
    skip?: number
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * StudentProfile create
   */
  export type StudentProfileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentProfile.
     */
    data: XOR<StudentProfileCreateInput, StudentProfileUncheckedCreateInput>
  }

  /**
   * StudentProfile createMany
   */
  export type StudentProfileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentProfiles.
     */
    data: StudentProfileCreateManyInput | StudentProfileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentProfile createManyAndReturn
   */
  export type StudentProfileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * The data used to create many StudentProfiles.
     */
    data: StudentProfileCreateManyInput | StudentProfileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentProfile update
   */
  export type StudentProfileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentProfile.
     */
    data: XOR<StudentProfileUpdateInput, StudentProfileUncheckedUpdateInput>
    /**
     * Choose, which StudentProfile to update.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile updateMany
   */
  export type StudentProfileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentProfiles.
     */
    data: XOR<StudentProfileUpdateManyMutationInput, StudentProfileUncheckedUpdateManyInput>
    /**
     * Filter which StudentProfiles to update
     */
    where?: StudentProfileWhereInput
    /**
     * Limit how many StudentProfiles to update.
     */
    limit?: number
  }

  /**
   * StudentProfile updateManyAndReturn
   */
  export type StudentProfileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * The data used to update StudentProfiles.
     */
    data: XOR<StudentProfileUpdateManyMutationInput, StudentProfileUncheckedUpdateManyInput>
    /**
     * Filter which StudentProfiles to update
     */
    where?: StudentProfileWhereInput
    /**
     * Limit how many StudentProfiles to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentProfile upsert
   */
  export type StudentProfileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentProfile to update in case it exists.
     */
    where: StudentProfileWhereUniqueInput
    /**
     * In case the StudentProfile found by the `where` argument doesn't exist, create a new StudentProfile with this data.
     */
    create: XOR<StudentProfileCreateInput, StudentProfileUncheckedCreateInput>
    /**
     * In case the StudentProfile was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentProfileUpdateInput, StudentProfileUncheckedUpdateInput>
  }

  /**
   * StudentProfile delete
   */
  export type StudentProfileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    /**
     * Filter which StudentProfile to delete.
     */
    where: StudentProfileWhereUniqueInput
  }

  /**
   * StudentProfile deleteMany
   */
  export type StudentProfileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentProfiles to delete
     */
    where?: StudentProfileWhereInput
    /**
     * Limit how many StudentProfiles to delete.
     */
    limit?: number
  }

  /**
   * StudentProfile.user
   */
  export type StudentProfile$userArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Omit specific fields from the User
     */
    omit?: UserOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * StudentProfile.teacherRelations
   */
  export type StudentProfile$teacherRelationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationInclude<ExtArgs> | null
    where?: StudentTeacherRelationWhereInput
    orderBy?: StudentTeacherRelationOrderByWithRelationInput | StudentTeacherRelationOrderByWithRelationInput[]
    cursor?: StudentTeacherRelationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentTeacherRelationScalarFieldEnum | StudentTeacherRelationScalarFieldEnum[]
  }

  /**
   * StudentProfile.classrooms
   */
  export type StudentProfile$classroomsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    where?: ClassroomWhereInput
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    cursor?: ClassroomWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * StudentProfile.recurringSchedules
   */
  export type StudentProfile$recurringSchedulesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    where?: ScheduleItemWhereInput
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    cursor?: ScheduleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * StudentProfile.lessons
   */
  export type StudentProfile$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * StudentProfile.homeworkTrackings
   */
  export type StudentProfile$homeworkTrackingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
    where?: HomeworkTrackingWhereInput
    orderBy?: HomeworkTrackingOrderByWithRelationInput | HomeworkTrackingOrderByWithRelationInput[]
    cursor?: HomeworkTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomeworkTrackingScalarFieldEnum | HomeworkTrackingScalarFieldEnum[]
  }

  /**
   * StudentProfile.submissions
   */
  export type StudentProfile$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionInclude<ExtArgs> | null
    where?: HomeworkSubmissionWhereInput
    orderBy?: HomeworkSubmissionOrderByWithRelationInput | HomeworkSubmissionOrderByWithRelationInput[]
    cursor?: HomeworkSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomeworkSubmissionScalarFieldEnum | HomeworkSubmissionScalarFieldEnum[]
  }

  /**
   * StudentProfile.payments
   */
  export type StudentProfile$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * StudentProfile.grades
   */
  export type StudentProfile$gradesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamInclude<ExtArgs> | null
    where?: SchoolExamWhereInput
    orderBy?: SchoolExamOrderByWithRelationInput | SchoolExamOrderByWithRelationInput[]
    cursor?: SchoolExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SchoolExamScalarFieldEnum | SchoolExamScalarFieldEnum[]
  }

  /**
   * StudentProfile.trialExams
   */
  export type StudentProfile$trialExamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamInclude<ExtArgs> | null
    where?: TrialExamWhereInput
    orderBy?: TrialExamOrderByWithRelationInput | TrialExamOrderByWithRelationInput[]
    cursor?: TrialExamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrialExamScalarFieldEnum | TrialExamScalarFieldEnum[]
  }

  /**
   * StudentProfile.attendances
   */
  export type StudentProfile$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * StudentProfile without action
   */
  export type StudentProfileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
  }


  /**
   * Model StudentTeacherRelation
   */

  export type AggregateStudentTeacherRelation = {
    _count: StudentTeacherRelationCountAggregateOutputType | null
    _min: StudentTeacherRelationMinAggregateOutputType | null
    _max: StudentTeacherRelationMaxAggregateOutputType | null
  }

  export type StudentTeacherRelationMinAggregateOutputType = {
    id: string | null
    teacherId: string | null
    studentId: string | null
    status: $Enums.RelationStatus | null
    isCreator: boolean | null
    customName: string | null
    privateNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentTeacherRelationMaxAggregateOutputType = {
    id: string | null
    teacherId: string | null
    studentId: string | null
    status: $Enums.RelationStatus | null
    isCreator: boolean | null
    customName: string | null
    privateNotes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StudentTeacherRelationCountAggregateOutputType = {
    id: number
    teacherId: number
    studentId: number
    status: number
    isCreator: number
    customName: number
    privateNotes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StudentTeacherRelationMinAggregateInputType = {
    id?: true
    teacherId?: true
    studentId?: true
    status?: true
    isCreator?: true
    customName?: true
    privateNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentTeacherRelationMaxAggregateInputType = {
    id?: true
    teacherId?: true
    studentId?: true
    status?: true
    isCreator?: true
    customName?: true
    privateNotes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StudentTeacherRelationCountAggregateInputType = {
    id?: true
    teacherId?: true
    studentId?: true
    status?: true
    isCreator?: true
    customName?: true
    privateNotes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StudentTeacherRelationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTeacherRelation to aggregate.
     */
    where?: StudentTeacherRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTeacherRelations to fetch.
     */
    orderBy?: StudentTeacherRelationOrderByWithRelationInput | StudentTeacherRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: StudentTeacherRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` StudentTeacherRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTeacherRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned StudentTeacherRelations
    **/
    _count?: true | StudentTeacherRelationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StudentTeacherRelationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StudentTeacherRelationMaxAggregateInputType
  }

  export type GetStudentTeacherRelationAggregateType<T extends StudentTeacherRelationAggregateArgs> = {
        [P in keyof T & keyof AggregateStudentTeacherRelation]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStudentTeacherRelation[P]>
      : GetScalarType<T[P], AggregateStudentTeacherRelation[P]>
  }




  export type StudentTeacherRelationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: StudentTeacherRelationWhereInput
    orderBy?: StudentTeacherRelationOrderByWithAggregationInput | StudentTeacherRelationOrderByWithAggregationInput[]
    by: StudentTeacherRelationScalarFieldEnum[] | StudentTeacherRelationScalarFieldEnum
    having?: StudentTeacherRelationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StudentTeacherRelationCountAggregateInputType | true
    _min?: StudentTeacherRelationMinAggregateInputType
    _max?: StudentTeacherRelationMaxAggregateInputType
  }

  export type StudentTeacherRelationGroupByOutputType = {
    id: string
    teacherId: string
    studentId: string
    status: $Enums.RelationStatus
    isCreator: boolean
    customName: string | null
    privateNotes: string | null
    createdAt: Date
    updatedAt: Date
    _count: StudentTeacherRelationCountAggregateOutputType | null
    _min: StudentTeacherRelationMinAggregateOutputType | null
    _max: StudentTeacherRelationMaxAggregateOutputType | null
  }

  type GetStudentTeacherRelationGroupByPayload<T extends StudentTeacherRelationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StudentTeacherRelationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StudentTeacherRelationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StudentTeacherRelationGroupByOutputType[P]>
            : GetScalarType<T[P], StudentTeacherRelationGroupByOutputType[P]>
        }
      >
    >


  export type StudentTeacherRelationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    studentId?: boolean
    status?: boolean
    isCreator?: boolean
    customName?: boolean
    privateNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTeacherRelation"]>

  export type StudentTeacherRelationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    studentId?: boolean
    status?: boolean
    isCreator?: boolean
    customName?: boolean
    privateNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTeacherRelation"]>

  export type StudentTeacherRelationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teacherId?: boolean
    studentId?: boolean
    status?: boolean
    isCreator?: boolean
    customName?: boolean
    privateNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["studentTeacherRelation"]>

  export type StudentTeacherRelationSelectScalar = {
    id?: boolean
    teacherId?: boolean
    studentId?: boolean
    status?: boolean
    isCreator?: boolean
    customName?: boolean
    privateNotes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type StudentTeacherRelationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "teacherId" | "studentId" | "status" | "isCreator" | "customName" | "privateNotes" | "createdAt" | "updatedAt", ExtArgs["result"]["studentTeacherRelation"]>
  export type StudentTeacherRelationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type StudentTeacherRelationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type StudentTeacherRelationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $StudentTeacherRelationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "StudentTeacherRelation"
    objects: {
      teacher: Prisma.$TeacherProfilePayload<ExtArgs>
      student: Prisma.$StudentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teacherId: string
      studentId: string
      status: $Enums.RelationStatus
      isCreator: boolean
      customName: string | null
      privateNotes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["studentTeacherRelation"]>
    composites: {}
  }

  type StudentTeacherRelationGetPayload<S extends boolean | null | undefined | StudentTeacherRelationDefaultArgs> = $Result.GetResult<Prisma.$StudentTeacherRelationPayload, S>

  type StudentTeacherRelationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<StudentTeacherRelationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StudentTeacherRelationCountAggregateInputType | true
    }

  export interface StudentTeacherRelationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['StudentTeacherRelation'], meta: { name: 'StudentTeacherRelation' } }
    /**
     * Find zero or one StudentTeacherRelation that matches the filter.
     * @param {StudentTeacherRelationFindUniqueArgs} args - Arguments to find a StudentTeacherRelation
     * @example
     * // Get one StudentTeacherRelation
     * const studentTeacherRelation = await prisma.studentTeacherRelation.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends StudentTeacherRelationFindUniqueArgs>(args: SelectSubset<T, StudentTeacherRelationFindUniqueArgs<ExtArgs>>): Prisma__StudentTeacherRelationClient<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one StudentTeacherRelation that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {StudentTeacherRelationFindUniqueOrThrowArgs} args - Arguments to find a StudentTeacherRelation
     * @example
     * // Get one StudentTeacherRelation
     * const studentTeacherRelation = await prisma.studentTeacherRelation.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends StudentTeacherRelationFindUniqueOrThrowArgs>(args: SelectSubset<T, StudentTeacherRelationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__StudentTeacherRelationClient<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentTeacherRelation that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTeacherRelationFindFirstArgs} args - Arguments to find a StudentTeacherRelation
     * @example
     * // Get one StudentTeacherRelation
     * const studentTeacherRelation = await prisma.studentTeacherRelation.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends StudentTeacherRelationFindFirstArgs>(args?: SelectSubset<T, StudentTeacherRelationFindFirstArgs<ExtArgs>>): Prisma__StudentTeacherRelationClient<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first StudentTeacherRelation that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTeacherRelationFindFirstOrThrowArgs} args - Arguments to find a StudentTeacherRelation
     * @example
     * // Get one StudentTeacherRelation
     * const studentTeacherRelation = await prisma.studentTeacherRelation.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends StudentTeacherRelationFindFirstOrThrowArgs>(args?: SelectSubset<T, StudentTeacherRelationFindFirstOrThrowArgs<ExtArgs>>): Prisma__StudentTeacherRelationClient<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more StudentTeacherRelations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTeacherRelationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all StudentTeacherRelations
     * const studentTeacherRelations = await prisma.studentTeacherRelation.findMany()
     * 
     * // Get first 10 StudentTeacherRelations
     * const studentTeacherRelations = await prisma.studentTeacherRelation.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const studentTeacherRelationWithIdOnly = await prisma.studentTeacherRelation.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends StudentTeacherRelationFindManyArgs>(args?: SelectSubset<T, StudentTeacherRelationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a StudentTeacherRelation.
     * @param {StudentTeacherRelationCreateArgs} args - Arguments to create a StudentTeacherRelation.
     * @example
     * // Create one StudentTeacherRelation
     * const StudentTeacherRelation = await prisma.studentTeacherRelation.create({
     *   data: {
     *     // ... data to create a StudentTeacherRelation
     *   }
     * })
     * 
     */
    create<T extends StudentTeacherRelationCreateArgs>(args: SelectSubset<T, StudentTeacherRelationCreateArgs<ExtArgs>>): Prisma__StudentTeacherRelationClient<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many StudentTeacherRelations.
     * @param {StudentTeacherRelationCreateManyArgs} args - Arguments to create many StudentTeacherRelations.
     * @example
     * // Create many StudentTeacherRelations
     * const studentTeacherRelation = await prisma.studentTeacherRelation.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends StudentTeacherRelationCreateManyArgs>(args?: SelectSubset<T, StudentTeacherRelationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many StudentTeacherRelations and returns the data saved in the database.
     * @param {StudentTeacherRelationCreateManyAndReturnArgs} args - Arguments to create many StudentTeacherRelations.
     * @example
     * // Create many StudentTeacherRelations
     * const studentTeacherRelation = await prisma.studentTeacherRelation.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many StudentTeacherRelations and only return the `id`
     * const studentTeacherRelationWithIdOnly = await prisma.studentTeacherRelation.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends StudentTeacherRelationCreateManyAndReturnArgs>(args?: SelectSubset<T, StudentTeacherRelationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a StudentTeacherRelation.
     * @param {StudentTeacherRelationDeleteArgs} args - Arguments to delete one StudentTeacherRelation.
     * @example
     * // Delete one StudentTeacherRelation
     * const StudentTeacherRelation = await prisma.studentTeacherRelation.delete({
     *   where: {
     *     // ... filter to delete one StudentTeacherRelation
     *   }
     * })
     * 
     */
    delete<T extends StudentTeacherRelationDeleteArgs>(args: SelectSubset<T, StudentTeacherRelationDeleteArgs<ExtArgs>>): Prisma__StudentTeacherRelationClient<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one StudentTeacherRelation.
     * @param {StudentTeacherRelationUpdateArgs} args - Arguments to update one StudentTeacherRelation.
     * @example
     * // Update one StudentTeacherRelation
     * const studentTeacherRelation = await prisma.studentTeacherRelation.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends StudentTeacherRelationUpdateArgs>(args: SelectSubset<T, StudentTeacherRelationUpdateArgs<ExtArgs>>): Prisma__StudentTeacherRelationClient<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more StudentTeacherRelations.
     * @param {StudentTeacherRelationDeleteManyArgs} args - Arguments to filter StudentTeacherRelations to delete.
     * @example
     * // Delete a few StudentTeacherRelations
     * const { count } = await prisma.studentTeacherRelation.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends StudentTeacherRelationDeleteManyArgs>(args?: SelectSubset<T, StudentTeacherRelationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTeacherRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTeacherRelationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many StudentTeacherRelations
     * const studentTeacherRelation = await prisma.studentTeacherRelation.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends StudentTeacherRelationUpdateManyArgs>(args: SelectSubset<T, StudentTeacherRelationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more StudentTeacherRelations and returns the data updated in the database.
     * @param {StudentTeacherRelationUpdateManyAndReturnArgs} args - Arguments to update many StudentTeacherRelations.
     * @example
     * // Update many StudentTeacherRelations
     * const studentTeacherRelation = await prisma.studentTeacherRelation.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more StudentTeacherRelations and only return the `id`
     * const studentTeacherRelationWithIdOnly = await prisma.studentTeacherRelation.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends StudentTeacherRelationUpdateManyAndReturnArgs>(args: SelectSubset<T, StudentTeacherRelationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one StudentTeacherRelation.
     * @param {StudentTeacherRelationUpsertArgs} args - Arguments to update or create a StudentTeacherRelation.
     * @example
     * // Update or create a StudentTeacherRelation
     * const studentTeacherRelation = await prisma.studentTeacherRelation.upsert({
     *   create: {
     *     // ... data to create a StudentTeacherRelation
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the StudentTeacherRelation we want to update
     *   }
     * })
     */
    upsert<T extends StudentTeacherRelationUpsertArgs>(args: SelectSubset<T, StudentTeacherRelationUpsertArgs<ExtArgs>>): Prisma__StudentTeacherRelationClient<$Result.GetResult<Prisma.$StudentTeacherRelationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of StudentTeacherRelations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTeacherRelationCountArgs} args - Arguments to filter StudentTeacherRelations to count.
     * @example
     * // Count the number of StudentTeacherRelations
     * const count = await prisma.studentTeacherRelation.count({
     *   where: {
     *     // ... the filter for the StudentTeacherRelations we want to count
     *   }
     * })
    **/
    count<T extends StudentTeacherRelationCountArgs>(
      args?: Subset<T, StudentTeacherRelationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StudentTeacherRelationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a StudentTeacherRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTeacherRelationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StudentTeacherRelationAggregateArgs>(args: Subset<T, StudentTeacherRelationAggregateArgs>): Prisma.PrismaPromise<GetStudentTeacherRelationAggregateType<T>>

    /**
     * Group by StudentTeacherRelation.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StudentTeacherRelationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends StudentTeacherRelationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: StudentTeacherRelationGroupByArgs['orderBy'] }
        : { orderBy?: StudentTeacherRelationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, StudentTeacherRelationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStudentTeacherRelationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the StudentTeacherRelation model
   */
  readonly fields: StudentTeacherRelationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for StudentTeacherRelation.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__StudentTeacherRelationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherProfileDefaultArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the StudentTeacherRelation model
   */
  interface StudentTeacherRelationFieldRefs {
    readonly id: FieldRef<"StudentTeacherRelation", 'String'>
    readonly teacherId: FieldRef<"StudentTeacherRelation", 'String'>
    readonly studentId: FieldRef<"StudentTeacherRelation", 'String'>
    readonly status: FieldRef<"StudentTeacherRelation", 'RelationStatus'>
    readonly isCreator: FieldRef<"StudentTeacherRelation", 'Boolean'>
    readonly customName: FieldRef<"StudentTeacherRelation", 'String'>
    readonly privateNotes: FieldRef<"StudentTeacherRelation", 'String'>
    readonly createdAt: FieldRef<"StudentTeacherRelation", 'DateTime'>
    readonly updatedAt: FieldRef<"StudentTeacherRelation", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * StudentTeacherRelation findUnique
   */
  export type StudentTeacherRelationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationInclude<ExtArgs> | null
    /**
     * Filter, which StudentTeacherRelation to fetch.
     */
    where: StudentTeacherRelationWhereUniqueInput
  }

  /**
   * StudentTeacherRelation findUniqueOrThrow
   */
  export type StudentTeacherRelationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationInclude<ExtArgs> | null
    /**
     * Filter, which StudentTeacherRelation to fetch.
     */
    where: StudentTeacherRelationWhereUniqueInput
  }

  /**
   * StudentTeacherRelation findFirst
   */
  export type StudentTeacherRelationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationInclude<ExtArgs> | null
    /**
     * Filter, which StudentTeacherRelation to fetch.
     */
    where?: StudentTeacherRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTeacherRelations to fetch.
     */
    orderBy?: StudentTeacherRelationOrderByWithRelationInput | StudentTeacherRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTeacherRelations.
     */
    cursor?: StudentTeacherRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` StudentTeacherRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTeacherRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTeacherRelations.
     */
    distinct?: StudentTeacherRelationScalarFieldEnum | StudentTeacherRelationScalarFieldEnum[]
  }

  /**
   * StudentTeacherRelation findFirstOrThrow
   */
  export type StudentTeacherRelationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationInclude<ExtArgs> | null
    /**
     * Filter, which StudentTeacherRelation to fetch.
     */
    where?: StudentTeacherRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTeacherRelations to fetch.
     */
    orderBy?: StudentTeacherRelationOrderByWithRelationInput | StudentTeacherRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for StudentTeacherRelations.
     */
    cursor?: StudentTeacherRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` StudentTeacherRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTeacherRelations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of StudentTeacherRelations.
     */
    distinct?: StudentTeacherRelationScalarFieldEnum | StudentTeacherRelationScalarFieldEnum[]
  }

  /**
   * StudentTeacherRelation findMany
   */
  export type StudentTeacherRelationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationInclude<ExtArgs> | null
    /**
     * Filter, which StudentTeacherRelations to fetch.
     */
    where?: StudentTeacherRelationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of StudentTeacherRelations to fetch.
     */
    orderBy?: StudentTeacherRelationOrderByWithRelationInput | StudentTeacherRelationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing StudentTeacherRelations.
     */
    cursor?: StudentTeacherRelationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` StudentTeacherRelations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` StudentTeacherRelations.
     */
    skip?: number
    distinct?: StudentTeacherRelationScalarFieldEnum | StudentTeacherRelationScalarFieldEnum[]
  }

  /**
   * StudentTeacherRelation create
   */
  export type StudentTeacherRelationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationInclude<ExtArgs> | null
    /**
     * The data needed to create a StudentTeacherRelation.
     */
    data: XOR<StudentTeacherRelationCreateInput, StudentTeacherRelationUncheckedCreateInput>
  }

  /**
   * StudentTeacherRelation createMany
   */
  export type StudentTeacherRelationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many StudentTeacherRelations.
     */
    data: StudentTeacherRelationCreateManyInput | StudentTeacherRelationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * StudentTeacherRelation createManyAndReturn
   */
  export type StudentTeacherRelationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * The data used to create many StudentTeacherRelations.
     */
    data: StudentTeacherRelationCreateManyInput | StudentTeacherRelationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTeacherRelation update
   */
  export type StudentTeacherRelationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationInclude<ExtArgs> | null
    /**
     * The data needed to update a StudentTeacherRelation.
     */
    data: XOR<StudentTeacherRelationUpdateInput, StudentTeacherRelationUncheckedUpdateInput>
    /**
     * Choose, which StudentTeacherRelation to update.
     */
    where: StudentTeacherRelationWhereUniqueInput
  }

  /**
   * StudentTeacherRelation updateMany
   */
  export type StudentTeacherRelationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update StudentTeacherRelations.
     */
    data: XOR<StudentTeacherRelationUpdateManyMutationInput, StudentTeacherRelationUncheckedUpdateManyInput>
    /**
     * Filter which StudentTeacherRelations to update
     */
    where?: StudentTeacherRelationWhereInput
    /**
     * Limit how many StudentTeacherRelations to update.
     */
    limit?: number
  }

  /**
   * StudentTeacherRelation updateManyAndReturn
   */
  export type StudentTeacherRelationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * The data used to update StudentTeacherRelations.
     */
    data: XOR<StudentTeacherRelationUpdateManyMutationInput, StudentTeacherRelationUncheckedUpdateManyInput>
    /**
     * Filter which StudentTeacherRelations to update
     */
    where?: StudentTeacherRelationWhereInput
    /**
     * Limit how many StudentTeacherRelations to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * StudentTeacherRelation upsert
   */
  export type StudentTeacherRelationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationInclude<ExtArgs> | null
    /**
     * The filter to search for the StudentTeacherRelation to update in case it exists.
     */
    where: StudentTeacherRelationWhereUniqueInput
    /**
     * In case the StudentTeacherRelation found by the `where` argument doesn't exist, create a new StudentTeacherRelation with this data.
     */
    create: XOR<StudentTeacherRelationCreateInput, StudentTeacherRelationUncheckedCreateInput>
    /**
     * In case the StudentTeacherRelation was found with the provided `where` argument, update it with this data.
     */
    update: XOR<StudentTeacherRelationUpdateInput, StudentTeacherRelationUncheckedUpdateInput>
  }

  /**
   * StudentTeacherRelation delete
   */
  export type StudentTeacherRelationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationInclude<ExtArgs> | null
    /**
     * Filter which StudentTeacherRelation to delete.
     */
    where: StudentTeacherRelationWhereUniqueInput
  }

  /**
   * StudentTeacherRelation deleteMany
   */
  export type StudentTeacherRelationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which StudentTeacherRelations to delete
     */
    where?: StudentTeacherRelationWhereInput
    /**
     * Limit how many StudentTeacherRelations to delete.
     */
    limit?: number
  }

  /**
   * StudentTeacherRelation without action
   */
  export type StudentTeacherRelationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentTeacherRelation
     */
    select?: StudentTeacherRelationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentTeacherRelation
     */
    omit?: StudentTeacherRelationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentTeacherRelationInclude<ExtArgs> | null
  }


  /**
   * Model Classroom
   */

  export type AggregateClassroom = {
    _count: ClassroomCountAggregateOutputType | null
    _avg: ClassroomAvgAggregateOutputType | null
    _sum: ClassroomSumAggregateOutputType | null
    _min: ClassroomMinAggregateOutputType | null
    _max: ClassroomMaxAggregateOutputType | null
  }

  export type ClassroomAvgAggregateOutputType = {
    year: number | null
  }

  export type ClassroomSumAggregateOutputType = {
    year: number | null
  }

  export type ClassroomMinAggregateOutputType = {
    id: string | null
    name: string | null
    year: number | null
    teacherId: string | null
  }

  export type ClassroomMaxAggregateOutputType = {
    id: string | null
    name: string | null
    year: number | null
    teacherId: string | null
  }

  export type ClassroomCountAggregateOutputType = {
    id: number
    name: number
    year: number
    teacherId: number
    _all: number
  }


  export type ClassroomAvgAggregateInputType = {
    year?: true
  }

  export type ClassroomSumAggregateInputType = {
    year?: true
  }

  export type ClassroomMinAggregateInputType = {
    id?: true
    name?: true
    year?: true
    teacherId?: true
  }

  export type ClassroomMaxAggregateInputType = {
    id?: true
    name?: true
    year?: true
    teacherId?: true
  }

  export type ClassroomCountAggregateInputType = {
    id?: true
    name?: true
    year?: true
    teacherId?: true
    _all?: true
  }

  export type ClassroomAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classroom to aggregate.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Classrooms
    **/
    _count?: true | ClassroomCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ClassroomAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ClassroomSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ClassroomMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ClassroomMaxAggregateInputType
  }

  export type GetClassroomAggregateType<T extends ClassroomAggregateArgs> = {
        [P in keyof T & keyof AggregateClassroom]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateClassroom[P]>
      : GetScalarType<T[P], AggregateClassroom[P]>
  }




  export type ClassroomGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ClassroomWhereInput
    orderBy?: ClassroomOrderByWithAggregationInput | ClassroomOrderByWithAggregationInput[]
    by: ClassroomScalarFieldEnum[] | ClassroomScalarFieldEnum
    having?: ClassroomScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ClassroomCountAggregateInputType | true
    _avg?: ClassroomAvgAggregateInputType
    _sum?: ClassroomSumAggregateInputType
    _min?: ClassroomMinAggregateInputType
    _max?: ClassroomMaxAggregateInputType
  }

  export type ClassroomGroupByOutputType = {
    id: string
    name: string
    year: number
    teacherId: string | null
    _count: ClassroomCountAggregateOutputType | null
    _avg: ClassroomAvgAggregateOutputType | null
    _sum: ClassroomSumAggregateOutputType | null
    _min: ClassroomMinAggregateOutputType | null
    _max: ClassroomMaxAggregateOutputType | null
  }

  type GetClassroomGroupByPayload<T extends ClassroomGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ClassroomGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ClassroomGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ClassroomGroupByOutputType[P]>
            : GetScalarType<T[P], ClassroomGroupByOutputType[P]>
        }
      >
    >


  export type ClassroomSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    year?: boolean
    teacherId?: boolean
    teacher?: boolean | Classroom$teacherArgs<ExtArgs>
    students?: boolean | Classroom$studentsArgs<ExtArgs>
    schedule?: boolean | Classroom$scheduleArgs<ExtArgs>
    lessons?: boolean | Classroom$lessonsArgs<ExtArgs>
    _count?: boolean | ClassroomCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["classroom"]>

  export type ClassroomSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    year?: boolean
    teacherId?: boolean
    teacher?: boolean | Classroom$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["classroom"]>

  export type ClassroomSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    year?: boolean
    teacherId?: boolean
    teacher?: boolean | Classroom$teacherArgs<ExtArgs>
  }, ExtArgs["result"]["classroom"]>

  export type ClassroomSelectScalar = {
    id?: boolean
    name?: boolean
    year?: boolean
    teacherId?: boolean
  }

  export type ClassroomOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "year" | "teacherId", ExtArgs["result"]["classroom"]>
  export type ClassroomInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | Classroom$teacherArgs<ExtArgs>
    students?: boolean | Classroom$studentsArgs<ExtArgs>
    schedule?: boolean | Classroom$scheduleArgs<ExtArgs>
    lessons?: boolean | Classroom$lessonsArgs<ExtArgs>
    _count?: boolean | ClassroomCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ClassroomIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | Classroom$teacherArgs<ExtArgs>
  }
  export type ClassroomIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | Classroom$teacherArgs<ExtArgs>
  }

  export type $ClassroomPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Classroom"
    objects: {
      teacher: Prisma.$TeacherProfilePayload<ExtArgs> | null
      students: Prisma.$StudentProfilePayload<ExtArgs>[]
      schedule: Prisma.$ScheduleItemPayload<ExtArgs>[]
      lessons: Prisma.$LessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      year: number
      teacherId: string | null
    }, ExtArgs["result"]["classroom"]>
    composites: {}
  }

  type ClassroomGetPayload<S extends boolean | null | undefined | ClassroomDefaultArgs> = $Result.GetResult<Prisma.$ClassroomPayload, S>

  type ClassroomCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ClassroomFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ClassroomCountAggregateInputType | true
    }

  export interface ClassroomDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Classroom'], meta: { name: 'Classroom' } }
    /**
     * Find zero or one Classroom that matches the filter.
     * @param {ClassroomFindUniqueArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ClassroomFindUniqueArgs>(args: SelectSubset<T, ClassroomFindUniqueArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Classroom that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ClassroomFindUniqueOrThrowArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ClassroomFindUniqueOrThrowArgs>(args: SelectSubset<T, ClassroomFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classroom that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomFindFirstArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ClassroomFindFirstArgs>(args?: SelectSubset<T, ClassroomFindFirstArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Classroom that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomFindFirstOrThrowArgs} args - Arguments to find a Classroom
     * @example
     * // Get one Classroom
     * const classroom = await prisma.classroom.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ClassroomFindFirstOrThrowArgs>(args?: SelectSubset<T, ClassroomFindFirstOrThrowArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Classrooms that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Classrooms
     * const classrooms = await prisma.classroom.findMany()
     * 
     * // Get first 10 Classrooms
     * const classrooms = await prisma.classroom.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const classroomWithIdOnly = await prisma.classroom.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ClassroomFindManyArgs>(args?: SelectSubset<T, ClassroomFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Classroom.
     * @param {ClassroomCreateArgs} args - Arguments to create a Classroom.
     * @example
     * // Create one Classroom
     * const Classroom = await prisma.classroom.create({
     *   data: {
     *     // ... data to create a Classroom
     *   }
     * })
     * 
     */
    create<T extends ClassroomCreateArgs>(args: SelectSubset<T, ClassroomCreateArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Classrooms.
     * @param {ClassroomCreateManyArgs} args - Arguments to create many Classrooms.
     * @example
     * // Create many Classrooms
     * const classroom = await prisma.classroom.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ClassroomCreateManyArgs>(args?: SelectSubset<T, ClassroomCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Classrooms and returns the data saved in the database.
     * @param {ClassroomCreateManyAndReturnArgs} args - Arguments to create many Classrooms.
     * @example
     * // Create many Classrooms
     * const classroom = await prisma.classroom.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Classrooms and only return the `id`
     * const classroomWithIdOnly = await prisma.classroom.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ClassroomCreateManyAndReturnArgs>(args?: SelectSubset<T, ClassroomCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Classroom.
     * @param {ClassroomDeleteArgs} args - Arguments to delete one Classroom.
     * @example
     * // Delete one Classroom
     * const Classroom = await prisma.classroom.delete({
     *   where: {
     *     // ... filter to delete one Classroom
     *   }
     * })
     * 
     */
    delete<T extends ClassroomDeleteArgs>(args: SelectSubset<T, ClassroomDeleteArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Classroom.
     * @param {ClassroomUpdateArgs} args - Arguments to update one Classroom.
     * @example
     * // Update one Classroom
     * const classroom = await prisma.classroom.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ClassroomUpdateArgs>(args: SelectSubset<T, ClassroomUpdateArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Classrooms.
     * @param {ClassroomDeleteManyArgs} args - Arguments to filter Classrooms to delete.
     * @example
     * // Delete a few Classrooms
     * const { count } = await prisma.classroom.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ClassroomDeleteManyArgs>(args?: SelectSubset<T, ClassroomDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Classrooms
     * const classroom = await prisma.classroom.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ClassroomUpdateManyArgs>(args: SelectSubset<T, ClassroomUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Classrooms and returns the data updated in the database.
     * @param {ClassroomUpdateManyAndReturnArgs} args - Arguments to update many Classrooms.
     * @example
     * // Update many Classrooms
     * const classroom = await prisma.classroom.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Classrooms and only return the `id`
     * const classroomWithIdOnly = await prisma.classroom.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ClassroomUpdateManyAndReturnArgs>(args: SelectSubset<T, ClassroomUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Classroom.
     * @param {ClassroomUpsertArgs} args - Arguments to update or create a Classroom.
     * @example
     * // Update or create a Classroom
     * const classroom = await prisma.classroom.upsert({
     *   create: {
     *     // ... data to create a Classroom
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Classroom we want to update
     *   }
     * })
     */
    upsert<T extends ClassroomUpsertArgs>(args: SelectSubset<T, ClassroomUpsertArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Classrooms.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomCountArgs} args - Arguments to filter Classrooms to count.
     * @example
     * // Count the number of Classrooms
     * const count = await prisma.classroom.count({
     *   where: {
     *     // ... the filter for the Classrooms we want to count
     *   }
     * })
    **/
    count<T extends ClassroomCountArgs>(
      args?: Subset<T, ClassroomCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ClassroomCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ClassroomAggregateArgs>(args: Subset<T, ClassroomAggregateArgs>): Prisma.PrismaPromise<GetClassroomAggregateType<T>>

    /**
     * Group by Classroom.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ClassroomGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ClassroomGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ClassroomGroupByArgs['orderBy'] }
        : { orderBy?: ClassroomGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ClassroomGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetClassroomGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Classroom model
   */
  readonly fields: ClassroomFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Classroom.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ClassroomClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends Classroom$teacherArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$teacherArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    students<T extends Classroom$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    schedule<T extends Classroom$scheduleArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$scheduleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    lessons<T extends Classroom$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Classroom$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Classroom model
   */
  interface ClassroomFieldRefs {
    readonly id: FieldRef<"Classroom", 'String'>
    readonly name: FieldRef<"Classroom", 'String'>
    readonly year: FieldRef<"Classroom", 'Int'>
    readonly teacherId: FieldRef<"Classroom", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Classroom findUnique
   */
  export type ClassroomFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where: ClassroomWhereUniqueInput
  }

  /**
   * Classroom findUniqueOrThrow
   */
  export type ClassroomFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where: ClassroomWhereUniqueInput
  }

  /**
   * Classroom findFirst
   */
  export type ClassroomFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classrooms.
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classrooms.
     */
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * Classroom findFirstOrThrow
   */
  export type ClassroomFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classroom to fetch.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Classrooms.
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Classrooms.
     */
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * Classroom findMany
   */
  export type ClassroomFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter, which Classrooms to fetch.
     */
    where?: ClassroomWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Classrooms to fetch.
     */
    orderBy?: ClassroomOrderByWithRelationInput | ClassroomOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Classrooms.
     */
    cursor?: ClassroomWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Classrooms from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Classrooms.
     */
    skip?: number
    distinct?: ClassroomScalarFieldEnum | ClassroomScalarFieldEnum[]
  }

  /**
   * Classroom create
   */
  export type ClassroomCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * The data needed to create a Classroom.
     */
    data: XOR<ClassroomCreateInput, ClassroomUncheckedCreateInput>
  }

  /**
   * Classroom createMany
   */
  export type ClassroomCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Classrooms.
     */
    data: ClassroomCreateManyInput | ClassroomCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Classroom createManyAndReturn
   */
  export type ClassroomCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * The data used to create many Classrooms.
     */
    data: ClassroomCreateManyInput | ClassroomCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Classroom update
   */
  export type ClassroomUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * The data needed to update a Classroom.
     */
    data: XOR<ClassroomUpdateInput, ClassroomUncheckedUpdateInput>
    /**
     * Choose, which Classroom to update.
     */
    where: ClassroomWhereUniqueInput
  }

  /**
   * Classroom updateMany
   */
  export type ClassroomUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Classrooms.
     */
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyInput>
    /**
     * Filter which Classrooms to update
     */
    where?: ClassroomWhereInput
    /**
     * Limit how many Classrooms to update.
     */
    limit?: number
  }

  /**
   * Classroom updateManyAndReturn
   */
  export type ClassroomUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * The data used to update Classrooms.
     */
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyInput>
    /**
     * Filter which Classrooms to update
     */
    where?: ClassroomWhereInput
    /**
     * Limit how many Classrooms to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Classroom upsert
   */
  export type ClassroomUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * The filter to search for the Classroom to update in case it exists.
     */
    where: ClassroomWhereUniqueInput
    /**
     * In case the Classroom found by the `where` argument doesn't exist, create a new Classroom with this data.
     */
    create: XOR<ClassroomCreateInput, ClassroomUncheckedCreateInput>
    /**
     * In case the Classroom was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ClassroomUpdateInput, ClassroomUncheckedUpdateInput>
  }

  /**
   * Classroom delete
   */
  export type ClassroomDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    /**
     * Filter which Classroom to delete.
     */
    where: ClassroomWhereUniqueInput
  }

  /**
   * Classroom deleteMany
   */
  export type ClassroomDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Classrooms to delete
     */
    where?: ClassroomWhereInput
    /**
     * Limit how many Classrooms to delete.
     */
    limit?: number
  }

  /**
   * Classroom.teacher
   */
  export type Classroom$teacherArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeacherProfile
     */
    select?: TeacherProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TeacherProfile
     */
    omit?: TeacherProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeacherProfileInclude<ExtArgs> | null
    where?: TeacherProfileWhereInput
  }

  /**
   * Classroom.students
   */
  export type Classroom$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    where?: StudentProfileWhereInput
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    cursor?: StudentProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * Classroom.schedule
   */
  export type Classroom$scheduleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    where?: ScheduleItemWhereInput
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    cursor?: ScheduleItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * Classroom.lessons
   */
  export type Classroom$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Classroom without action
   */
  export type ClassroomDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
  }


  /**
   * Model ScheduleItem
   */

  export type AggregateScheduleItem = {
    _count: ScheduleItemCountAggregateOutputType | null
    _avg: ScheduleItemAvgAggregateOutputType | null
    _sum: ScheduleItemSumAggregateOutputType | null
    _min: ScheduleItemMinAggregateOutputType | null
    _max: ScheduleItemMaxAggregateOutputType | null
  }

  export type ScheduleItemAvgAggregateOutputType = {
    dayOfWeek: number | null
    price: Decimal | null
  }

  export type ScheduleItemSumAggregateOutputType = {
    dayOfWeek: number | null
    price: Decimal | null
  }

  export type ScheduleItemMinAggregateOutputType = {
    id: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    subject: string | null
    type: $Enums.LessonType | null
    location: $Enums.LessonLocation | null
    locationUrl: string | null
    address: string | null
    price: Decimal | null
    currency: string | null
    teacherId: string | null
    classroomId: string | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleItemMaxAggregateOutputType = {
    id: string | null
    dayOfWeek: number | null
    startTime: string | null
    endTime: string | null
    subject: string | null
    type: $Enums.LessonType | null
    location: $Enums.LessonLocation | null
    locationUrl: string | null
    address: string | null
    price: Decimal | null
    currency: string | null
    teacherId: string | null
    classroomId: string | null
    studentId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ScheduleItemCountAggregateOutputType = {
    id: number
    dayOfWeek: number
    startTime: number
    endTime: number
    subject: number
    type: number
    location: number
    locationUrl: number
    address: number
    price: number
    currency: number
    teacherId: number
    classroomId: number
    studentId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ScheduleItemAvgAggregateInputType = {
    dayOfWeek?: true
    price?: true
  }

  export type ScheduleItemSumAggregateInputType = {
    dayOfWeek?: true
    price?: true
  }

  export type ScheduleItemMinAggregateInputType = {
    id?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    subject?: true
    type?: true
    location?: true
    locationUrl?: true
    address?: true
    price?: true
    currency?: true
    teacherId?: true
    classroomId?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleItemMaxAggregateInputType = {
    id?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    subject?: true
    type?: true
    location?: true
    locationUrl?: true
    address?: true
    price?: true
    currency?: true
    teacherId?: true
    classroomId?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ScheduleItemCountAggregateInputType = {
    id?: true
    dayOfWeek?: true
    startTime?: true
    endTime?: true
    subject?: true
    type?: true
    location?: true
    locationUrl?: true
    address?: true
    price?: true
    currency?: true
    teacherId?: true
    classroomId?: true
    studentId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ScheduleItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleItem to aggregate.
     */
    where?: ScheduleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleItems to fetch.
     */
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ScheduleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ScheduleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ScheduleItems
    **/
    _count?: true | ScheduleItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ScheduleItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ScheduleItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ScheduleItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ScheduleItemMaxAggregateInputType
  }

  export type GetScheduleItemAggregateType<T extends ScheduleItemAggregateArgs> = {
        [P in keyof T & keyof AggregateScheduleItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateScheduleItem[P]>
      : GetScalarType<T[P], AggregateScheduleItem[P]>
  }




  export type ScheduleItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ScheduleItemWhereInput
    orderBy?: ScheduleItemOrderByWithAggregationInput | ScheduleItemOrderByWithAggregationInput[]
    by: ScheduleItemScalarFieldEnum[] | ScheduleItemScalarFieldEnum
    having?: ScheduleItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ScheduleItemCountAggregateInputType | true
    _avg?: ScheduleItemAvgAggregateInputType
    _sum?: ScheduleItemSumAggregateInputType
    _min?: ScheduleItemMinAggregateInputType
    _max?: ScheduleItemMaxAggregateInputType
  }

  export type ScheduleItemGroupByOutputType = {
    id: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject: string | null
    type: $Enums.LessonType
    location: $Enums.LessonLocation
    locationUrl: string | null
    address: string | null
    price: Decimal | null
    currency: string
    teacherId: string
    classroomId: string | null
    studentId: string | null
    createdAt: Date
    updatedAt: Date
    _count: ScheduleItemCountAggregateOutputType | null
    _avg: ScheduleItemAvgAggregateOutputType | null
    _sum: ScheduleItemSumAggregateOutputType | null
    _min: ScheduleItemMinAggregateOutputType | null
    _max: ScheduleItemMaxAggregateOutputType | null
  }

  type GetScheduleItemGroupByPayload<T extends ScheduleItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ScheduleItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ScheduleItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ScheduleItemGroupByOutputType[P]>
            : GetScalarType<T[P], ScheduleItemGroupByOutputType[P]>
        }
      >
    >


  export type ScheduleItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    subject?: boolean
    type?: boolean
    location?: boolean
    locationUrl?: boolean
    address?: boolean
    price?: boolean
    currency?: boolean
    teacherId?: boolean
    classroomId?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    classroom?: boolean | ScheduleItem$classroomArgs<ExtArgs>
    student?: boolean | ScheduleItem$studentArgs<ExtArgs>
    lessons?: boolean | ScheduleItem$lessonsArgs<ExtArgs>
    _count?: boolean | ScheduleItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleItem"]>

  export type ScheduleItemSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    subject?: boolean
    type?: boolean
    location?: boolean
    locationUrl?: boolean
    address?: boolean
    price?: boolean
    currency?: boolean
    teacherId?: boolean
    classroomId?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    classroom?: boolean | ScheduleItem$classroomArgs<ExtArgs>
    student?: boolean | ScheduleItem$studentArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleItem"]>

  export type ScheduleItemSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    subject?: boolean
    type?: boolean
    location?: boolean
    locationUrl?: boolean
    address?: boolean
    price?: boolean
    currency?: boolean
    teacherId?: boolean
    classroomId?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    classroom?: boolean | ScheduleItem$classroomArgs<ExtArgs>
    student?: boolean | ScheduleItem$studentArgs<ExtArgs>
  }, ExtArgs["result"]["scheduleItem"]>

  export type ScheduleItemSelectScalar = {
    id?: boolean
    dayOfWeek?: boolean
    startTime?: boolean
    endTime?: boolean
    subject?: boolean
    type?: boolean
    location?: boolean
    locationUrl?: boolean
    address?: boolean
    price?: boolean
    currency?: boolean
    teacherId?: boolean
    classroomId?: boolean
    studentId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ScheduleItemOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "dayOfWeek" | "startTime" | "endTime" | "subject" | "type" | "location" | "locationUrl" | "address" | "price" | "currency" | "teacherId" | "classroomId" | "studentId" | "createdAt" | "updatedAt", ExtArgs["result"]["scheduleItem"]>
  export type ScheduleItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    classroom?: boolean | ScheduleItem$classroomArgs<ExtArgs>
    student?: boolean | ScheduleItem$studentArgs<ExtArgs>
    lessons?: boolean | ScheduleItem$lessonsArgs<ExtArgs>
    _count?: boolean | ScheduleItemCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ScheduleItemIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    classroom?: boolean | ScheduleItem$classroomArgs<ExtArgs>
    student?: boolean | ScheduleItem$studentArgs<ExtArgs>
  }
  export type ScheduleItemIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    classroom?: boolean | ScheduleItem$classroomArgs<ExtArgs>
    student?: boolean | ScheduleItem$studentArgs<ExtArgs>
  }

  export type $ScheduleItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ScheduleItem"
    objects: {
      teacher: Prisma.$TeacherProfilePayload<ExtArgs>
      classroom: Prisma.$ClassroomPayload<ExtArgs> | null
      student: Prisma.$StudentProfilePayload<ExtArgs> | null
      lessons: Prisma.$LessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      dayOfWeek: number
      startTime: string
      endTime: string
      subject: string | null
      type: $Enums.LessonType
      location: $Enums.LessonLocation
      locationUrl: string | null
      address: string | null
      price: Prisma.Decimal | null
      currency: string
      teacherId: string
      classroomId: string | null
      studentId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["scheduleItem"]>
    composites: {}
  }

  type ScheduleItemGetPayload<S extends boolean | null | undefined | ScheduleItemDefaultArgs> = $Result.GetResult<Prisma.$ScheduleItemPayload, S>

  type ScheduleItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<ScheduleItemFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ScheduleItemCountAggregateInputType | true
    }

  export interface ScheduleItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ScheduleItem'], meta: { name: 'ScheduleItem' } }
    /**
     * Find zero or one ScheduleItem that matches the filter.
     * @param {ScheduleItemFindUniqueArgs} args - Arguments to find a ScheduleItem
     * @example
     * // Get one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ScheduleItemFindUniqueArgs>(args: SelectSubset<T, ScheduleItemFindUniqueArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one ScheduleItem that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {ScheduleItemFindUniqueOrThrowArgs} args - Arguments to find a ScheduleItem
     * @example
     * // Get one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ScheduleItemFindUniqueOrThrowArgs>(args: SelectSubset<T, ScheduleItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemFindFirstArgs} args - Arguments to find a ScheduleItem
     * @example
     * // Get one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ScheduleItemFindFirstArgs>(args?: SelectSubset<T, ScheduleItemFindFirstArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first ScheduleItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemFindFirstOrThrowArgs} args - Arguments to find a ScheduleItem
     * @example
     * // Get one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ScheduleItemFindFirstOrThrowArgs>(args?: SelectSubset<T, ScheduleItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more ScheduleItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ScheduleItems
     * const scheduleItems = await prisma.scheduleItem.findMany()
     * 
     * // Get first 10 ScheduleItems
     * const scheduleItems = await prisma.scheduleItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const scheduleItemWithIdOnly = await prisma.scheduleItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ScheduleItemFindManyArgs>(args?: SelectSubset<T, ScheduleItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a ScheduleItem.
     * @param {ScheduleItemCreateArgs} args - Arguments to create a ScheduleItem.
     * @example
     * // Create one ScheduleItem
     * const ScheduleItem = await prisma.scheduleItem.create({
     *   data: {
     *     // ... data to create a ScheduleItem
     *   }
     * })
     * 
     */
    create<T extends ScheduleItemCreateArgs>(args: SelectSubset<T, ScheduleItemCreateArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many ScheduleItems.
     * @param {ScheduleItemCreateManyArgs} args - Arguments to create many ScheduleItems.
     * @example
     * // Create many ScheduleItems
     * const scheduleItem = await prisma.scheduleItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ScheduleItemCreateManyArgs>(args?: SelectSubset<T, ScheduleItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ScheduleItems and returns the data saved in the database.
     * @param {ScheduleItemCreateManyAndReturnArgs} args - Arguments to create many ScheduleItems.
     * @example
     * // Create many ScheduleItems
     * const scheduleItem = await prisma.scheduleItem.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ScheduleItems and only return the `id`
     * const scheduleItemWithIdOnly = await prisma.scheduleItem.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ScheduleItemCreateManyAndReturnArgs>(args?: SelectSubset<T, ScheduleItemCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a ScheduleItem.
     * @param {ScheduleItemDeleteArgs} args - Arguments to delete one ScheduleItem.
     * @example
     * // Delete one ScheduleItem
     * const ScheduleItem = await prisma.scheduleItem.delete({
     *   where: {
     *     // ... filter to delete one ScheduleItem
     *   }
     * })
     * 
     */
    delete<T extends ScheduleItemDeleteArgs>(args: SelectSubset<T, ScheduleItemDeleteArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one ScheduleItem.
     * @param {ScheduleItemUpdateArgs} args - Arguments to update one ScheduleItem.
     * @example
     * // Update one ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ScheduleItemUpdateArgs>(args: SelectSubset<T, ScheduleItemUpdateArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more ScheduleItems.
     * @param {ScheduleItemDeleteManyArgs} args - Arguments to filter ScheduleItems to delete.
     * @example
     * // Delete a few ScheduleItems
     * const { count } = await prisma.scheduleItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ScheduleItemDeleteManyArgs>(args?: SelectSubset<T, ScheduleItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ScheduleItems
     * const scheduleItem = await prisma.scheduleItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ScheduleItemUpdateManyArgs>(args: SelectSubset<T, ScheduleItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ScheduleItems and returns the data updated in the database.
     * @param {ScheduleItemUpdateManyAndReturnArgs} args - Arguments to update many ScheduleItems.
     * @example
     * // Update many ScheduleItems
     * const scheduleItem = await prisma.scheduleItem.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more ScheduleItems and only return the `id`
     * const scheduleItemWithIdOnly = await prisma.scheduleItem.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends ScheduleItemUpdateManyAndReturnArgs>(args: SelectSubset<T, ScheduleItemUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one ScheduleItem.
     * @param {ScheduleItemUpsertArgs} args - Arguments to update or create a ScheduleItem.
     * @example
     * // Update or create a ScheduleItem
     * const scheduleItem = await prisma.scheduleItem.upsert({
     *   create: {
     *     // ... data to create a ScheduleItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ScheduleItem we want to update
     *   }
     * })
     */
    upsert<T extends ScheduleItemUpsertArgs>(args: SelectSubset<T, ScheduleItemUpsertArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of ScheduleItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemCountArgs} args - Arguments to filter ScheduleItems to count.
     * @example
     * // Count the number of ScheduleItems
     * const count = await prisma.scheduleItem.count({
     *   where: {
     *     // ... the filter for the ScheduleItems we want to count
     *   }
     * })
    **/
    count<T extends ScheduleItemCountArgs>(
      args?: Subset<T, ScheduleItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ScheduleItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ScheduleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ScheduleItemAggregateArgs>(args: Subset<T, ScheduleItemAggregateArgs>): Prisma.PrismaPromise<GetScheduleItemAggregateType<T>>

    /**
     * Group by ScheduleItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ScheduleItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ScheduleItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ScheduleItemGroupByArgs['orderBy'] }
        : { orderBy?: ScheduleItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ScheduleItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetScheduleItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ScheduleItem model
   */
  readonly fields: ScheduleItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ScheduleItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ScheduleItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    teacher<T extends TeacherProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherProfileDefaultArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    classroom<T extends ScheduleItem$classroomArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleItem$classroomArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends ScheduleItem$studentArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleItem$studentArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lessons<T extends ScheduleItem$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, ScheduleItem$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ScheduleItem model
   */
  interface ScheduleItemFieldRefs {
    readonly id: FieldRef<"ScheduleItem", 'String'>
    readonly dayOfWeek: FieldRef<"ScheduleItem", 'Int'>
    readonly startTime: FieldRef<"ScheduleItem", 'String'>
    readonly endTime: FieldRef<"ScheduleItem", 'String'>
    readonly subject: FieldRef<"ScheduleItem", 'String'>
    readonly type: FieldRef<"ScheduleItem", 'LessonType'>
    readonly location: FieldRef<"ScheduleItem", 'LessonLocation'>
    readonly locationUrl: FieldRef<"ScheduleItem", 'String'>
    readonly address: FieldRef<"ScheduleItem", 'String'>
    readonly price: FieldRef<"ScheduleItem", 'Decimal'>
    readonly currency: FieldRef<"ScheduleItem", 'String'>
    readonly teacherId: FieldRef<"ScheduleItem", 'String'>
    readonly classroomId: FieldRef<"ScheduleItem", 'String'>
    readonly studentId: FieldRef<"ScheduleItem", 'String'>
    readonly createdAt: FieldRef<"ScheduleItem", 'DateTime'>
    readonly updatedAt: FieldRef<"ScheduleItem", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ScheduleItem findUnique
   */
  export type ScheduleItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItem to fetch.
     */
    where: ScheduleItemWhereUniqueInput
  }

  /**
   * ScheduleItem findUniqueOrThrow
   */
  export type ScheduleItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItem to fetch.
     */
    where: ScheduleItemWhereUniqueInput
  }

  /**
   * ScheduleItem findFirst
   */
  export type ScheduleItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItem to fetch.
     */
    where?: ScheduleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleItems to fetch.
     */
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleItems.
     */
    cursor?: ScheduleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ScheduleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleItems.
     */
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * ScheduleItem findFirstOrThrow
   */
  export type ScheduleItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItem to fetch.
     */
    where?: ScheduleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleItems to fetch.
     */
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ScheduleItems.
     */
    cursor?: ScheduleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ScheduleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ScheduleItems.
     */
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * ScheduleItem findMany
   */
  export type ScheduleItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter, which ScheduleItems to fetch.
     */
    where?: ScheduleItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ScheduleItems to fetch.
     */
    orderBy?: ScheduleItemOrderByWithRelationInput | ScheduleItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ScheduleItems.
     */
    cursor?: ScheduleItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` ScheduleItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ScheduleItems.
     */
    skip?: number
    distinct?: ScheduleItemScalarFieldEnum | ScheduleItemScalarFieldEnum[]
  }

  /**
   * ScheduleItem create
   */
  export type ScheduleItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * The data needed to create a ScheduleItem.
     */
    data: XOR<ScheduleItemCreateInput, ScheduleItemUncheckedCreateInput>
  }

  /**
   * ScheduleItem createMany
   */
  export type ScheduleItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ScheduleItems.
     */
    data: ScheduleItemCreateManyInput | ScheduleItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ScheduleItem createManyAndReturn
   */
  export type ScheduleItemCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * The data used to create many ScheduleItems.
     */
    data: ScheduleItemCreateManyInput | ScheduleItemCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleItem update
   */
  export type ScheduleItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * The data needed to update a ScheduleItem.
     */
    data: XOR<ScheduleItemUpdateInput, ScheduleItemUncheckedUpdateInput>
    /**
     * Choose, which ScheduleItem to update.
     */
    where: ScheduleItemWhereUniqueInput
  }

  /**
   * ScheduleItem updateMany
   */
  export type ScheduleItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ScheduleItems.
     */
    data: XOR<ScheduleItemUpdateManyMutationInput, ScheduleItemUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleItems to update
     */
    where?: ScheduleItemWhereInput
    /**
     * Limit how many ScheduleItems to update.
     */
    limit?: number
  }

  /**
   * ScheduleItem updateManyAndReturn
   */
  export type ScheduleItemUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * The data used to update ScheduleItems.
     */
    data: XOR<ScheduleItemUpdateManyMutationInput, ScheduleItemUncheckedUpdateManyInput>
    /**
     * Filter which ScheduleItems to update
     */
    where?: ScheduleItemWhereInput
    /**
     * Limit how many ScheduleItems to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * ScheduleItem upsert
   */
  export type ScheduleItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * The filter to search for the ScheduleItem to update in case it exists.
     */
    where: ScheduleItemWhereUniqueInput
    /**
     * In case the ScheduleItem found by the `where` argument doesn't exist, create a new ScheduleItem with this data.
     */
    create: XOR<ScheduleItemCreateInput, ScheduleItemUncheckedCreateInput>
    /**
     * In case the ScheduleItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ScheduleItemUpdateInput, ScheduleItemUncheckedUpdateInput>
  }

  /**
   * ScheduleItem delete
   */
  export type ScheduleItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    /**
     * Filter which ScheduleItem to delete.
     */
    where: ScheduleItemWhereUniqueInput
  }

  /**
   * ScheduleItem deleteMany
   */
  export type ScheduleItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ScheduleItems to delete
     */
    where?: ScheduleItemWhereInput
    /**
     * Limit how many ScheduleItems to delete.
     */
    limit?: number
  }

  /**
   * ScheduleItem.classroom
   */
  export type ScheduleItem$classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    where?: ClassroomWhereInput
  }

  /**
   * ScheduleItem.student
   */
  export type ScheduleItem$studentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    where?: StudentProfileWhereInput
  }

  /**
   * ScheduleItem.lessons
   */
  export type ScheduleItem$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * ScheduleItem without action
   */
  export type ScheduleItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
  }


  /**
   * Model Lesson
   */

  export type AggregateLesson = {
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  export type LessonAvgAggregateOutputType = {
    price: Decimal | null
  }

  export type LessonSumAggregateOutputType = {
    price: Decimal | null
  }

  export type LessonMinAggregateOutputType = {
    id: string | null
    title: string | null
    startTime: Date | null
    endTime: Date | null
    scheduleItemId: string | null
    type: $Enums.LessonType | null
    status: $Enums.LessonStatus | null
    cancelReason: string | null
    location: $Enums.LessonLocation | null
    locationUrl: string | null
    address: string | null
    publicNote: string | null
    privateNote: string | null
    price: Decimal | null
    currency: string | null
    isPaid: boolean | null
    teacherId: string | null
    classroomId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonMaxAggregateOutputType = {
    id: string | null
    title: string | null
    startTime: Date | null
    endTime: Date | null
    scheduleItemId: string | null
    type: $Enums.LessonType | null
    status: $Enums.LessonStatus | null
    cancelReason: string | null
    location: $Enums.LessonLocation | null
    locationUrl: string | null
    address: string | null
    publicNote: string | null
    privateNote: string | null
    price: Decimal | null
    currency: string | null
    isPaid: boolean | null
    teacherId: string | null
    classroomId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LessonCountAggregateOutputType = {
    id: number
    title: number
    startTime: number
    endTime: number
    scheduleItemId: number
    type: number
    status: number
    cancelReason: number
    location: number
    locationUrl: number
    address: number
    publicNote: number
    privateNote: number
    price: number
    currency: number
    isPaid: number
    teacherId: number
    classroomId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LessonAvgAggregateInputType = {
    price?: true
  }

  export type LessonSumAggregateInputType = {
    price?: true
  }

  export type LessonMinAggregateInputType = {
    id?: true
    title?: true
    startTime?: true
    endTime?: true
    scheduleItemId?: true
    type?: true
    status?: true
    cancelReason?: true
    location?: true
    locationUrl?: true
    address?: true
    publicNote?: true
    privateNote?: true
    price?: true
    currency?: true
    isPaid?: true
    teacherId?: true
    classroomId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonMaxAggregateInputType = {
    id?: true
    title?: true
    startTime?: true
    endTime?: true
    scheduleItemId?: true
    type?: true
    status?: true
    cancelReason?: true
    location?: true
    locationUrl?: true
    address?: true
    publicNote?: true
    privateNote?: true
    price?: true
    currency?: true
    isPaid?: true
    teacherId?: true
    classroomId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LessonCountAggregateInputType = {
    id?: true
    title?: true
    startTime?: true
    endTime?: true
    scheduleItemId?: true
    type?: true
    status?: true
    cancelReason?: true
    location?: true
    locationUrl?: true
    address?: true
    publicNote?: true
    privateNote?: true
    price?: true
    currency?: true
    isPaid?: true
    teacherId?: true
    classroomId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LessonAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lesson to aggregate.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Lessons
    **/
    _count?: true | LessonCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LessonAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LessonSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LessonMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LessonMaxAggregateInputType
  }

  export type GetLessonAggregateType<T extends LessonAggregateArgs> = {
        [P in keyof T & keyof AggregateLesson]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLesson[P]>
      : GetScalarType<T[P], AggregateLesson[P]>
  }




  export type LessonGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithAggregationInput | LessonOrderByWithAggregationInput[]
    by: LessonScalarFieldEnum[] | LessonScalarFieldEnum
    having?: LessonScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LessonCountAggregateInputType | true
    _avg?: LessonAvgAggregateInputType
    _sum?: LessonSumAggregateInputType
    _min?: LessonMinAggregateInputType
    _max?: LessonMaxAggregateInputType
  }

  export type LessonGroupByOutputType = {
    id: string
    title: string
    startTime: Date
    endTime: Date
    scheduleItemId: string | null
    type: $Enums.LessonType
    status: $Enums.LessonStatus
    cancelReason: string | null
    location: $Enums.LessonLocation
    locationUrl: string | null
    address: string | null
    publicNote: string | null
    privateNote: string | null
    price: Decimal | null
    currency: string
    isPaid: boolean
    teacherId: string
    classroomId: string | null
    createdAt: Date
    updatedAt: Date
    _count: LessonCountAggregateOutputType | null
    _avg: LessonAvgAggregateOutputType | null
    _sum: LessonSumAggregateOutputType | null
    _min: LessonMinAggregateOutputType | null
    _max: LessonMaxAggregateOutputType | null
  }

  type GetLessonGroupByPayload<T extends LessonGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LessonGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LessonGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LessonGroupByOutputType[P]>
            : GetScalarType<T[P], LessonGroupByOutputType[P]>
        }
      >
    >


  export type LessonSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    startTime?: boolean
    endTime?: boolean
    scheduleItemId?: boolean
    type?: boolean
    status?: boolean
    cancelReason?: boolean
    location?: boolean
    locationUrl?: boolean
    address?: boolean
    publicNote?: boolean
    privateNote?: boolean
    price?: boolean
    currency?: boolean
    isPaid?: boolean
    teacherId?: boolean
    classroomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scheduleItem?: boolean | Lesson$scheduleItemArgs<ExtArgs>
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    students?: boolean | Lesson$studentsArgs<ExtArgs>
    classroom?: boolean | Lesson$classroomArgs<ExtArgs>
    attendances?: boolean | Lesson$attendancesArgs<ExtArgs>
    homeworks?: boolean | Lesson$homeworksArgs<ExtArgs>
    materials?: boolean | Lesson$materialsArgs<ExtArgs>
    payments?: boolean | Lesson$paymentsArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    startTime?: boolean
    endTime?: boolean
    scheduleItemId?: boolean
    type?: boolean
    status?: boolean
    cancelReason?: boolean
    location?: boolean
    locationUrl?: boolean
    address?: boolean
    publicNote?: boolean
    privateNote?: boolean
    price?: boolean
    currency?: boolean
    isPaid?: boolean
    teacherId?: boolean
    classroomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scheduleItem?: boolean | Lesson$scheduleItemArgs<ExtArgs>
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    classroom?: boolean | Lesson$classroomArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    startTime?: boolean
    endTime?: boolean
    scheduleItemId?: boolean
    type?: boolean
    status?: boolean
    cancelReason?: boolean
    location?: boolean
    locationUrl?: boolean
    address?: boolean
    publicNote?: boolean
    privateNote?: boolean
    price?: boolean
    currency?: boolean
    isPaid?: boolean
    teacherId?: boolean
    classroomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    scheduleItem?: boolean | Lesson$scheduleItemArgs<ExtArgs>
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    classroom?: boolean | Lesson$classroomArgs<ExtArgs>
  }, ExtArgs["result"]["lesson"]>

  export type LessonSelectScalar = {
    id?: boolean
    title?: boolean
    startTime?: boolean
    endTime?: boolean
    scheduleItemId?: boolean
    type?: boolean
    status?: boolean
    cancelReason?: boolean
    location?: boolean
    locationUrl?: boolean
    address?: boolean
    publicNote?: boolean
    privateNote?: boolean
    price?: boolean
    currency?: boolean
    isPaid?: boolean
    teacherId?: boolean
    classroomId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LessonOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "startTime" | "endTime" | "scheduleItemId" | "type" | "status" | "cancelReason" | "location" | "locationUrl" | "address" | "publicNote" | "privateNote" | "price" | "currency" | "isPaid" | "teacherId" | "classroomId" | "createdAt" | "updatedAt", ExtArgs["result"]["lesson"]>
  export type LessonInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduleItem?: boolean | Lesson$scheduleItemArgs<ExtArgs>
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    students?: boolean | Lesson$studentsArgs<ExtArgs>
    classroom?: boolean | Lesson$classroomArgs<ExtArgs>
    attendances?: boolean | Lesson$attendancesArgs<ExtArgs>
    homeworks?: boolean | Lesson$homeworksArgs<ExtArgs>
    materials?: boolean | Lesson$materialsArgs<ExtArgs>
    payments?: boolean | Lesson$paymentsArgs<ExtArgs>
    _count?: boolean | LessonCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type LessonIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduleItem?: boolean | Lesson$scheduleItemArgs<ExtArgs>
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    classroom?: boolean | Lesson$classroomArgs<ExtArgs>
  }
  export type LessonIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    scheduleItem?: boolean | Lesson$scheduleItemArgs<ExtArgs>
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    classroom?: boolean | Lesson$classroomArgs<ExtArgs>
  }

  export type $LessonPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Lesson"
    objects: {
      scheduleItem: Prisma.$ScheduleItemPayload<ExtArgs> | null
      teacher: Prisma.$TeacherProfilePayload<ExtArgs>
      students: Prisma.$StudentProfilePayload<ExtArgs>[]
      classroom: Prisma.$ClassroomPayload<ExtArgs> | null
      attendances: Prisma.$AttendancePayload<ExtArgs>[]
      homeworks: Prisma.$HomeworkPayload<ExtArgs>[]
      materials: Prisma.$MaterialPayload<ExtArgs>[]
      payments: Prisma.$PaymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      startTime: Date
      endTime: Date
      scheduleItemId: string | null
      type: $Enums.LessonType
      status: $Enums.LessonStatus
      cancelReason: string | null
      location: $Enums.LessonLocation
      locationUrl: string | null
      address: string | null
      publicNote: string | null
      privateNote: string | null
      price: Prisma.Decimal | null
      currency: string
      isPaid: boolean
      teacherId: string
      classroomId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["lesson"]>
    composites: {}
  }

  type LessonGetPayload<S extends boolean | null | undefined | LessonDefaultArgs> = $Result.GetResult<Prisma.$LessonPayload, S>

  type LessonCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<LessonFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: LessonCountAggregateInputType | true
    }

  export interface LessonDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Lesson'], meta: { name: 'Lesson' } }
    /**
     * Find zero or one Lesson that matches the filter.
     * @param {LessonFindUniqueArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LessonFindUniqueArgs>(args: SelectSubset<T, LessonFindUniqueArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Lesson that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {LessonFindUniqueOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LessonFindUniqueOrThrowArgs>(args: SelectSubset<T, LessonFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LessonFindFirstArgs>(args?: SelectSubset<T, LessonFindFirstArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Lesson that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindFirstOrThrowArgs} args - Arguments to find a Lesson
     * @example
     * // Get one Lesson
     * const lesson = await prisma.lesson.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LessonFindFirstOrThrowArgs>(args?: SelectSubset<T, LessonFindFirstOrThrowArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Lessons that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Lessons
     * const lessons = await prisma.lesson.findMany()
     * 
     * // Get first 10 Lessons
     * const lessons = await prisma.lesson.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const lessonWithIdOnly = await prisma.lesson.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LessonFindManyArgs>(args?: SelectSubset<T, LessonFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Lesson.
     * @param {LessonCreateArgs} args - Arguments to create a Lesson.
     * @example
     * // Create one Lesson
     * const Lesson = await prisma.lesson.create({
     *   data: {
     *     // ... data to create a Lesson
     *   }
     * })
     * 
     */
    create<T extends LessonCreateArgs>(args: SelectSubset<T, LessonCreateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Lessons.
     * @param {LessonCreateManyArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LessonCreateManyArgs>(args?: SelectSubset<T, LessonCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Lessons and returns the data saved in the database.
     * @param {LessonCreateManyAndReturnArgs} args - Arguments to create many Lessons.
     * @example
     * // Create many Lessons
     * const lesson = await prisma.lesson.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LessonCreateManyAndReturnArgs>(args?: SelectSubset<T, LessonCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Lesson.
     * @param {LessonDeleteArgs} args - Arguments to delete one Lesson.
     * @example
     * // Delete one Lesson
     * const Lesson = await prisma.lesson.delete({
     *   where: {
     *     // ... filter to delete one Lesson
     *   }
     * })
     * 
     */
    delete<T extends LessonDeleteArgs>(args: SelectSubset<T, LessonDeleteArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Lesson.
     * @param {LessonUpdateArgs} args - Arguments to update one Lesson.
     * @example
     * // Update one Lesson
     * const lesson = await prisma.lesson.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LessonUpdateArgs>(args: SelectSubset<T, LessonUpdateArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Lessons.
     * @param {LessonDeleteManyArgs} args - Arguments to filter Lessons to delete.
     * @example
     * // Delete a few Lessons
     * const { count } = await prisma.lesson.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LessonDeleteManyArgs>(args?: SelectSubset<T, LessonDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LessonUpdateManyArgs>(args: SelectSubset<T, LessonUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Lessons and returns the data updated in the database.
     * @param {LessonUpdateManyAndReturnArgs} args - Arguments to update many Lessons.
     * @example
     * // Update many Lessons
     * const lesson = await prisma.lesson.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Lessons and only return the `id`
     * const lessonWithIdOnly = await prisma.lesson.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends LessonUpdateManyAndReturnArgs>(args: SelectSubset<T, LessonUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Lesson.
     * @param {LessonUpsertArgs} args - Arguments to update or create a Lesson.
     * @example
     * // Update or create a Lesson
     * const lesson = await prisma.lesson.upsert({
     *   create: {
     *     // ... data to create a Lesson
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Lesson we want to update
     *   }
     * })
     */
    upsert<T extends LessonUpsertArgs>(args: SelectSubset<T, LessonUpsertArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Lessons.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonCountArgs} args - Arguments to filter Lessons to count.
     * @example
     * // Count the number of Lessons
     * const count = await prisma.lesson.count({
     *   where: {
     *     // ... the filter for the Lessons we want to count
     *   }
     * })
    **/
    count<T extends LessonCountArgs>(
      args?: Subset<T, LessonCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LessonCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LessonAggregateArgs>(args: Subset<T, LessonAggregateArgs>): Prisma.PrismaPromise<GetLessonAggregateType<T>>

    /**
     * Group by Lesson.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LessonGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LessonGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LessonGroupByArgs['orderBy'] }
        : { orderBy?: LessonGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LessonGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLessonGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Lesson model
   */
  readonly fields: LessonFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Lesson.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LessonClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    scheduleItem<T extends Lesson$scheduleItemArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$scheduleItemArgs<ExtArgs>>): Prisma__ScheduleItemClient<$Result.GetResult<Prisma.$ScheduleItemPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    teacher<T extends TeacherProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherProfileDefaultArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    students<T extends Lesson$studentsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$studentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    classroom<T extends Lesson$classroomArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$classroomArgs<ExtArgs>>): Prisma__ClassroomClient<$Result.GetResult<Prisma.$ClassroomPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    attendances<T extends Lesson$attendancesArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$attendancesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    homeworks<T extends Lesson$homeworksArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$homeworksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    materials<T extends Lesson$materialsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    payments<T extends Lesson$paymentsArgs<ExtArgs> = {}>(args?: Subset<T, Lesson$paymentsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Lesson model
   */
  interface LessonFieldRefs {
    readonly id: FieldRef<"Lesson", 'String'>
    readonly title: FieldRef<"Lesson", 'String'>
    readonly startTime: FieldRef<"Lesson", 'DateTime'>
    readonly endTime: FieldRef<"Lesson", 'DateTime'>
    readonly scheduleItemId: FieldRef<"Lesson", 'String'>
    readonly type: FieldRef<"Lesson", 'LessonType'>
    readonly status: FieldRef<"Lesson", 'LessonStatus'>
    readonly cancelReason: FieldRef<"Lesson", 'String'>
    readonly location: FieldRef<"Lesson", 'LessonLocation'>
    readonly locationUrl: FieldRef<"Lesson", 'String'>
    readonly address: FieldRef<"Lesson", 'String'>
    readonly publicNote: FieldRef<"Lesson", 'String'>
    readonly privateNote: FieldRef<"Lesson", 'String'>
    readonly price: FieldRef<"Lesson", 'Decimal'>
    readonly currency: FieldRef<"Lesson", 'String'>
    readonly isPaid: FieldRef<"Lesson", 'Boolean'>
    readonly teacherId: FieldRef<"Lesson", 'String'>
    readonly classroomId: FieldRef<"Lesson", 'String'>
    readonly createdAt: FieldRef<"Lesson", 'DateTime'>
    readonly updatedAt: FieldRef<"Lesson", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Lesson findUnique
   */
  export type LessonFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findUniqueOrThrow
   */
  export type LessonFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson findFirst
   */
  export type LessonFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findFirstOrThrow
   */
  export type LessonFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lesson to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Lessons.
     */
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson findMany
   */
  export type LessonFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter, which Lessons to fetch.
     */
    where?: LessonWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Lessons to fetch.
     */
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Lessons.
     */
    cursor?: LessonWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Lessons from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Lessons.
     */
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Lesson create
   */
  export type LessonCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to create a Lesson.
     */
    data: XOR<LessonCreateInput, LessonUncheckedCreateInput>
  }

  /**
   * Lesson createMany
   */
  export type LessonCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Lesson createManyAndReturn
   */
  export type LessonCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to create many Lessons.
     */
    data: LessonCreateManyInput | LessonCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson update
   */
  export type LessonUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The data needed to update a Lesson.
     */
    data: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
    /**
     * Choose, which Lesson to update.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson updateMany
   */
  export type LessonUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
  }

  /**
   * Lesson updateManyAndReturn
   */
  export type LessonUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * The data used to update Lessons.
     */
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyInput>
    /**
     * Filter which Lessons to update
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Lesson upsert
   */
  export type LessonUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * The filter to search for the Lesson to update in case it exists.
     */
    where: LessonWhereUniqueInput
    /**
     * In case the Lesson found by the `where` argument doesn't exist, create a new Lesson with this data.
     */
    create: XOR<LessonCreateInput, LessonUncheckedCreateInput>
    /**
     * In case the Lesson was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LessonUpdateInput, LessonUncheckedUpdateInput>
  }

  /**
   * Lesson delete
   */
  export type LessonDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    /**
     * Filter which Lesson to delete.
     */
    where: LessonWhereUniqueInput
  }

  /**
   * Lesson deleteMany
   */
  export type LessonDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Lessons to delete
     */
    where?: LessonWhereInput
    /**
     * Limit how many Lessons to delete.
     */
    limit?: number
  }

  /**
   * Lesson.scheduleItem
   */
  export type Lesson$scheduleItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ScheduleItem
     */
    select?: ScheduleItemSelect<ExtArgs> | null
    /**
     * Omit specific fields from the ScheduleItem
     */
    omit?: ScheduleItemOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ScheduleItemInclude<ExtArgs> | null
    where?: ScheduleItemWhereInput
  }

  /**
   * Lesson.students
   */
  export type Lesson$studentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StudentProfile
     */
    select?: StudentProfileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the StudentProfile
     */
    omit?: StudentProfileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: StudentProfileInclude<ExtArgs> | null
    where?: StudentProfileWhereInput
    orderBy?: StudentProfileOrderByWithRelationInput | StudentProfileOrderByWithRelationInput[]
    cursor?: StudentProfileWhereUniqueInput
    take?: number
    skip?: number
    distinct?: StudentProfileScalarFieldEnum | StudentProfileScalarFieldEnum[]
  }

  /**
   * Lesson.classroom
   */
  export type Lesson$classroomArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Classroom
     */
    select?: ClassroomSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Classroom
     */
    omit?: ClassroomOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ClassroomInclude<ExtArgs> | null
    where?: ClassroomWhereInput
  }

  /**
   * Lesson.attendances
   */
  export type Lesson$attendancesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    cursor?: AttendanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Lesson.homeworks
   */
  export type Lesson$homeworksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkInclude<ExtArgs> | null
    where?: HomeworkWhereInput
    orderBy?: HomeworkOrderByWithRelationInput | HomeworkOrderByWithRelationInput[]
    cursor?: HomeworkWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomeworkScalarFieldEnum | HomeworkScalarFieldEnum[]
  }

  /**
   * Lesson.materials
   */
  export type Lesson$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Lesson.payments
   */
  export type Lesson$paymentsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    cursor?: PaymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Lesson without action
   */
  export type LessonDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
  }


  /**
   * Model Material
   */

  export type AggregateMaterial = {
    _count: MaterialCountAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  export type MaterialMinAggregateOutputType = {
    id: string | null
    title: string | null
    fileId: string | null
    linkUrl: string | null
    type: $Enums.FileType | null
    lessonId: string | null
    createdAt: Date | null
  }

  export type MaterialMaxAggregateOutputType = {
    id: string | null
    title: string | null
    fileId: string | null
    linkUrl: string | null
    type: $Enums.FileType | null
    lessonId: string | null
    createdAt: Date | null
  }

  export type MaterialCountAggregateOutputType = {
    id: number
    title: number
    fileId: number
    linkUrl: number
    type: number
    lessonId: number
    createdAt: number
    _all: number
  }


  export type MaterialMinAggregateInputType = {
    id?: true
    title?: true
    fileId?: true
    linkUrl?: true
    type?: true
    lessonId?: true
    createdAt?: true
  }

  export type MaterialMaxAggregateInputType = {
    id?: true
    title?: true
    fileId?: true
    linkUrl?: true
    type?: true
    lessonId?: true
    createdAt?: true
  }

  export type MaterialCountAggregateInputType = {
    id?: true
    title?: true
    fileId?: true
    linkUrl?: true
    type?: true
    lessonId?: true
    createdAt?: true
    _all?: true
  }

  export type MaterialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Material to aggregate.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Materials
    **/
    _count?: true | MaterialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MaterialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MaterialMaxAggregateInputType
  }

  export type GetMaterialAggregateType<T extends MaterialAggregateArgs> = {
        [P in keyof T & keyof AggregateMaterial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMaterial[P]>
      : GetScalarType<T[P], AggregateMaterial[P]>
  }




  export type MaterialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithAggregationInput | MaterialOrderByWithAggregationInput[]
    by: MaterialScalarFieldEnum[] | MaterialScalarFieldEnum
    having?: MaterialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MaterialCountAggregateInputType | true
    _min?: MaterialMinAggregateInputType
    _max?: MaterialMaxAggregateInputType
  }

  export type MaterialGroupByOutputType = {
    id: string
    title: string
    fileId: string | null
    linkUrl: string | null
    type: $Enums.FileType
    lessonId: string
    createdAt: Date
    _count: MaterialCountAggregateOutputType | null
    _min: MaterialMinAggregateOutputType | null
    _max: MaterialMaxAggregateOutputType | null
  }

  type GetMaterialGroupByPayload<T extends MaterialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MaterialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MaterialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MaterialGroupByOutputType[P]>
            : GetScalarType<T[P], MaterialGroupByOutputType[P]>
        }
      >
    >


  export type MaterialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    fileId?: boolean
    linkUrl?: boolean
    type?: boolean
    lessonId?: boolean
    createdAt?: boolean
    file?: boolean | Material$fileArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    fileId?: boolean
    linkUrl?: boolean
    type?: boolean
    lessonId?: boolean
    createdAt?: boolean
    file?: boolean | Material$fileArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    fileId?: boolean
    linkUrl?: boolean
    type?: boolean
    lessonId?: boolean
    createdAt?: boolean
    file?: boolean | Material$fileArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["material"]>

  export type MaterialSelectScalar = {
    id?: boolean
    title?: boolean
    fileId?: boolean
    linkUrl?: boolean
    type?: boolean
    lessonId?: boolean
    createdAt?: boolean
  }

  export type MaterialOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "fileId" | "linkUrl" | "type" | "lessonId" | "createdAt", ExtArgs["result"]["material"]>
  export type MaterialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | Material$fileArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | Material$fileArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type MaterialIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | Material$fileArgs<ExtArgs>
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $MaterialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Material"
    objects: {
      file: Prisma.$FilePayload<ExtArgs> | null
      lesson: Prisma.$LessonPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      fileId: string | null
      linkUrl: string | null
      type: $Enums.FileType
      lessonId: string
      createdAt: Date
    }, ExtArgs["result"]["material"]>
    composites: {}
  }

  type MaterialGetPayload<S extends boolean | null | undefined | MaterialDefaultArgs> = $Result.GetResult<Prisma.$MaterialPayload, S>

  type MaterialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MaterialFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MaterialCountAggregateInputType | true
    }

  export interface MaterialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Material'], meta: { name: 'Material' } }
    /**
     * Find zero or one Material that matches the filter.
     * @param {MaterialFindUniqueArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MaterialFindUniqueArgs>(args: SelectSubset<T, MaterialFindUniqueArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Material that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MaterialFindUniqueOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MaterialFindUniqueOrThrowArgs>(args: SelectSubset<T, MaterialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MaterialFindFirstArgs>(args?: SelectSubset<T, MaterialFindFirstArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Material that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindFirstOrThrowArgs} args - Arguments to find a Material
     * @example
     * // Get one Material
     * const material = await prisma.material.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MaterialFindFirstOrThrowArgs>(args?: SelectSubset<T, MaterialFindFirstOrThrowArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Materials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Materials
     * const materials = await prisma.material.findMany()
     * 
     * // Get first 10 Materials
     * const materials = await prisma.material.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const materialWithIdOnly = await prisma.material.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MaterialFindManyArgs>(args?: SelectSubset<T, MaterialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Material.
     * @param {MaterialCreateArgs} args - Arguments to create a Material.
     * @example
     * // Create one Material
     * const Material = await prisma.material.create({
     *   data: {
     *     // ... data to create a Material
     *   }
     * })
     * 
     */
    create<T extends MaterialCreateArgs>(args: SelectSubset<T, MaterialCreateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Materials.
     * @param {MaterialCreateManyArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MaterialCreateManyArgs>(args?: SelectSubset<T, MaterialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Materials and returns the data saved in the database.
     * @param {MaterialCreateManyAndReturnArgs} args - Arguments to create many Materials.
     * @example
     * // Create many Materials
     * const material = await prisma.material.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MaterialCreateManyAndReturnArgs>(args?: SelectSubset<T, MaterialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Material.
     * @param {MaterialDeleteArgs} args - Arguments to delete one Material.
     * @example
     * // Delete one Material
     * const Material = await prisma.material.delete({
     *   where: {
     *     // ... filter to delete one Material
     *   }
     * })
     * 
     */
    delete<T extends MaterialDeleteArgs>(args: SelectSubset<T, MaterialDeleteArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Material.
     * @param {MaterialUpdateArgs} args - Arguments to update one Material.
     * @example
     * // Update one Material
     * const material = await prisma.material.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MaterialUpdateArgs>(args: SelectSubset<T, MaterialUpdateArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Materials.
     * @param {MaterialDeleteManyArgs} args - Arguments to filter Materials to delete.
     * @example
     * // Delete a few Materials
     * const { count } = await prisma.material.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MaterialDeleteManyArgs>(args?: SelectSubset<T, MaterialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MaterialUpdateManyArgs>(args: SelectSubset<T, MaterialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Materials and returns the data updated in the database.
     * @param {MaterialUpdateManyAndReturnArgs} args - Arguments to update many Materials.
     * @example
     * // Update many Materials
     * const material = await prisma.material.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Materials and only return the `id`
     * const materialWithIdOnly = await prisma.material.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MaterialUpdateManyAndReturnArgs>(args: SelectSubset<T, MaterialUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Material.
     * @param {MaterialUpsertArgs} args - Arguments to update or create a Material.
     * @example
     * // Update or create a Material
     * const material = await prisma.material.upsert({
     *   create: {
     *     // ... data to create a Material
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Material we want to update
     *   }
     * })
     */
    upsert<T extends MaterialUpsertArgs>(args: SelectSubset<T, MaterialUpsertArgs<ExtArgs>>): Prisma__MaterialClient<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Materials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialCountArgs} args - Arguments to filter Materials to count.
     * @example
     * // Count the number of Materials
     * const count = await prisma.material.count({
     *   where: {
     *     // ... the filter for the Materials we want to count
     *   }
     * })
    **/
    count<T extends MaterialCountArgs>(
      args?: Subset<T, MaterialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MaterialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MaterialAggregateArgs>(args: Subset<T, MaterialAggregateArgs>): Prisma.PrismaPromise<GetMaterialAggregateType<T>>

    /**
     * Group by Material.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MaterialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MaterialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MaterialGroupByArgs['orderBy'] }
        : { orderBy?: MaterialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MaterialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMaterialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Material model
   */
  readonly fields: MaterialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Material.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MaterialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends Material$fileArgs<ExtArgs> = {}>(args?: Subset<T, Material$fileArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Material model
   */
  interface MaterialFieldRefs {
    readonly id: FieldRef<"Material", 'String'>
    readonly title: FieldRef<"Material", 'String'>
    readonly fileId: FieldRef<"Material", 'String'>
    readonly linkUrl: FieldRef<"Material", 'String'>
    readonly type: FieldRef<"Material", 'FileType'>
    readonly lessonId: FieldRef<"Material", 'String'>
    readonly createdAt: FieldRef<"Material", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Material findUnique
   */
  export type MaterialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findUniqueOrThrow
   */
  export type MaterialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material findFirst
   */
  export type MaterialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findFirstOrThrow
   */
  export type MaterialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Material to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Materials.
     */
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material findMany
   */
  export type MaterialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter, which Materials to fetch.
     */
    where?: MaterialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Materials to fetch.
     */
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Materials.
     */
    cursor?: MaterialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Materials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Materials.
     */
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * Material create
   */
  export type MaterialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to create a Material.
     */
    data: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
  }

  /**
   * Material createMany
   */
  export type MaterialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Material createManyAndReturn
   */
  export type MaterialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to create many Materials.
     */
    data: MaterialCreateManyInput | MaterialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material update
   */
  export type MaterialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The data needed to update a Material.
     */
    data: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
    /**
     * Choose, which Material to update.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material updateMany
   */
  export type MaterialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
  }

  /**
   * Material updateManyAndReturn
   */
  export type MaterialUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * The data used to update Materials.
     */
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyInput>
    /**
     * Filter which Materials to update
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Material upsert
   */
  export type MaterialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * The filter to search for the Material to update in case it exists.
     */
    where: MaterialWhereUniqueInput
    /**
     * In case the Material found by the `where` argument doesn't exist, create a new Material with this data.
     */
    create: XOR<MaterialCreateInput, MaterialUncheckedCreateInput>
    /**
     * In case the Material was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MaterialUpdateInput, MaterialUncheckedUpdateInput>
  }

  /**
   * Material delete
   */
  export type MaterialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    /**
     * Filter which Material to delete.
     */
    where: MaterialWhereUniqueInput
  }

  /**
   * Material deleteMany
   */
  export type MaterialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Materials to delete
     */
    where?: MaterialWhereInput
    /**
     * Limit how many Materials to delete.
     */
    limit?: number
  }

  /**
   * Material.file
   */
  export type Material$fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
  }

  /**
   * Material without action
   */
  export type MaterialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
  }


  /**
   * Model Homework
   */

  export type AggregateHomework = {
    _count: HomeworkCountAggregateOutputType | null
    _min: HomeworkMinAggregateOutputType | null
    _max: HomeworkMaxAggregateOutputType | null
  }

  export type HomeworkMinAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    assignedDate: Date | null
    dueDate: Date | null
    lessonId: string | null
  }

  export type HomeworkMaxAggregateOutputType = {
    id: string | null
    title: string | null
    content: string | null
    assignedDate: Date | null
    dueDate: Date | null
    lessonId: string | null
  }

  export type HomeworkCountAggregateOutputType = {
    id: number
    title: number
    content: number
    assignedDate: number
    dueDate: number
    lessonId: number
    _all: number
  }


  export type HomeworkMinAggregateInputType = {
    id?: true
    title?: true
    content?: true
    assignedDate?: true
    dueDate?: true
    lessonId?: true
  }

  export type HomeworkMaxAggregateInputType = {
    id?: true
    title?: true
    content?: true
    assignedDate?: true
    dueDate?: true
    lessonId?: true
  }

  export type HomeworkCountAggregateInputType = {
    id?: true
    title?: true
    content?: true
    assignedDate?: true
    dueDate?: true
    lessonId?: true
    _all?: true
  }

  export type HomeworkAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Homework to aggregate.
     */
    where?: HomeworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Homework to fetch.
     */
    orderBy?: HomeworkOrderByWithRelationInput | HomeworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomeworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Homework from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Homework.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Homework
    **/
    _count?: true | HomeworkCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomeworkMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomeworkMaxAggregateInputType
  }

  export type GetHomeworkAggregateType<T extends HomeworkAggregateArgs> = {
        [P in keyof T & keyof AggregateHomework]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomework[P]>
      : GetScalarType<T[P], AggregateHomework[P]>
  }




  export type HomeworkGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeworkWhereInput
    orderBy?: HomeworkOrderByWithAggregationInput | HomeworkOrderByWithAggregationInput[]
    by: HomeworkScalarFieldEnum[] | HomeworkScalarFieldEnum
    having?: HomeworkScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomeworkCountAggregateInputType | true
    _min?: HomeworkMinAggregateInputType
    _max?: HomeworkMaxAggregateInputType
  }

  export type HomeworkGroupByOutputType = {
    id: string
    title: string
    content: string | null
    assignedDate: Date
    dueDate: Date
    lessonId: string
    _count: HomeworkCountAggregateOutputType | null
    _min: HomeworkMinAggregateOutputType | null
    _max: HomeworkMaxAggregateOutputType | null
  }

  type GetHomeworkGroupByPayload<T extends HomeworkGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HomeworkGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomeworkGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomeworkGroupByOutputType[P]>
            : GetScalarType<T[P], HomeworkGroupByOutputType[P]>
        }
      >
    >


  export type HomeworkSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    assignedDate?: boolean
    dueDate?: boolean
    lessonId?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    trackings?: boolean | Homework$trackingsArgs<ExtArgs>
    _count?: boolean | HomeworkCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homework"]>

  export type HomeworkSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    assignedDate?: boolean
    dueDate?: boolean
    lessonId?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homework"]>

  export type HomeworkSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    content?: boolean
    assignedDate?: boolean
    dueDate?: boolean
    lessonId?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homework"]>

  export type HomeworkSelectScalar = {
    id?: boolean
    title?: boolean
    content?: boolean
    assignedDate?: boolean
    dueDate?: boolean
    lessonId?: boolean
  }

  export type HomeworkOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "content" | "assignedDate" | "dueDate" | "lessonId", ExtArgs["result"]["homework"]>
  export type HomeworkInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    trackings?: boolean | Homework$trackingsArgs<ExtArgs>
    _count?: boolean | HomeworkCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type HomeworkIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }
  export type HomeworkIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
  }

  export type $HomeworkPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Homework"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      trackings: Prisma.$HomeworkTrackingPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      content: string | null
      assignedDate: Date
      dueDate: Date
      lessonId: string
    }, ExtArgs["result"]["homework"]>
    composites: {}
  }

  type HomeworkGetPayload<S extends boolean | null | undefined | HomeworkDefaultArgs> = $Result.GetResult<Prisma.$HomeworkPayload, S>

  type HomeworkCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HomeworkFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HomeworkCountAggregateInputType | true
    }

  export interface HomeworkDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Homework'], meta: { name: 'Homework' } }
    /**
     * Find zero or one Homework that matches the filter.
     * @param {HomeworkFindUniqueArgs} args - Arguments to find a Homework
     * @example
     * // Get one Homework
     * const homework = await prisma.homework.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HomeworkFindUniqueArgs>(args: SelectSubset<T, HomeworkFindUniqueArgs<ExtArgs>>): Prisma__HomeworkClient<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Homework that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HomeworkFindUniqueOrThrowArgs} args - Arguments to find a Homework
     * @example
     * // Get one Homework
     * const homework = await prisma.homework.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HomeworkFindUniqueOrThrowArgs>(args: SelectSubset<T, HomeworkFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HomeworkClient<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Homework that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkFindFirstArgs} args - Arguments to find a Homework
     * @example
     * // Get one Homework
     * const homework = await prisma.homework.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HomeworkFindFirstArgs>(args?: SelectSubset<T, HomeworkFindFirstArgs<ExtArgs>>): Prisma__HomeworkClient<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Homework that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkFindFirstOrThrowArgs} args - Arguments to find a Homework
     * @example
     * // Get one Homework
     * const homework = await prisma.homework.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HomeworkFindFirstOrThrowArgs>(args?: SelectSubset<T, HomeworkFindFirstOrThrowArgs<ExtArgs>>): Prisma__HomeworkClient<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Homework that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Homework
     * const homework = await prisma.homework.findMany()
     * 
     * // Get first 10 Homework
     * const homework = await prisma.homework.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homeworkWithIdOnly = await prisma.homework.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HomeworkFindManyArgs>(args?: SelectSubset<T, HomeworkFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Homework.
     * @param {HomeworkCreateArgs} args - Arguments to create a Homework.
     * @example
     * // Create one Homework
     * const Homework = await prisma.homework.create({
     *   data: {
     *     // ... data to create a Homework
     *   }
     * })
     * 
     */
    create<T extends HomeworkCreateArgs>(args: SelectSubset<T, HomeworkCreateArgs<ExtArgs>>): Prisma__HomeworkClient<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Homework.
     * @param {HomeworkCreateManyArgs} args - Arguments to create many Homework.
     * @example
     * // Create many Homework
     * const homework = await prisma.homework.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HomeworkCreateManyArgs>(args?: SelectSubset<T, HomeworkCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Homework and returns the data saved in the database.
     * @param {HomeworkCreateManyAndReturnArgs} args - Arguments to create many Homework.
     * @example
     * // Create many Homework
     * const homework = await prisma.homework.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Homework and only return the `id`
     * const homeworkWithIdOnly = await prisma.homework.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HomeworkCreateManyAndReturnArgs>(args?: SelectSubset<T, HomeworkCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Homework.
     * @param {HomeworkDeleteArgs} args - Arguments to delete one Homework.
     * @example
     * // Delete one Homework
     * const Homework = await prisma.homework.delete({
     *   where: {
     *     // ... filter to delete one Homework
     *   }
     * })
     * 
     */
    delete<T extends HomeworkDeleteArgs>(args: SelectSubset<T, HomeworkDeleteArgs<ExtArgs>>): Prisma__HomeworkClient<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Homework.
     * @param {HomeworkUpdateArgs} args - Arguments to update one Homework.
     * @example
     * // Update one Homework
     * const homework = await prisma.homework.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HomeworkUpdateArgs>(args: SelectSubset<T, HomeworkUpdateArgs<ExtArgs>>): Prisma__HomeworkClient<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Homework.
     * @param {HomeworkDeleteManyArgs} args - Arguments to filter Homework to delete.
     * @example
     * // Delete a few Homework
     * const { count } = await prisma.homework.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HomeworkDeleteManyArgs>(args?: SelectSubset<T, HomeworkDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Homework.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Homework
     * const homework = await prisma.homework.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HomeworkUpdateManyArgs>(args: SelectSubset<T, HomeworkUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Homework and returns the data updated in the database.
     * @param {HomeworkUpdateManyAndReturnArgs} args - Arguments to update many Homework.
     * @example
     * // Update many Homework
     * const homework = await prisma.homework.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Homework and only return the `id`
     * const homeworkWithIdOnly = await prisma.homework.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HomeworkUpdateManyAndReturnArgs>(args: SelectSubset<T, HomeworkUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Homework.
     * @param {HomeworkUpsertArgs} args - Arguments to update or create a Homework.
     * @example
     * // Update or create a Homework
     * const homework = await prisma.homework.upsert({
     *   create: {
     *     // ... data to create a Homework
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Homework we want to update
     *   }
     * })
     */
    upsert<T extends HomeworkUpsertArgs>(args: SelectSubset<T, HomeworkUpsertArgs<ExtArgs>>): Prisma__HomeworkClient<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Homework.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkCountArgs} args - Arguments to filter Homework to count.
     * @example
     * // Count the number of Homework
     * const count = await prisma.homework.count({
     *   where: {
     *     // ... the filter for the Homework we want to count
     *   }
     * })
    **/
    count<T extends HomeworkCountArgs>(
      args?: Subset<T, HomeworkCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomeworkCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Homework.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomeworkAggregateArgs>(args: Subset<T, HomeworkAggregateArgs>): Prisma.PrismaPromise<GetHomeworkAggregateType<T>>

    /**
     * Group by Homework.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomeworkGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomeworkGroupByArgs['orderBy'] }
        : { orderBy?: HomeworkGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomeworkGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomeworkGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Homework model
   */
  readonly fields: HomeworkFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Homework.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HomeworkClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    trackings<T extends Homework$trackingsArgs<ExtArgs> = {}>(args?: Subset<T, Homework$trackingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Homework model
   */
  interface HomeworkFieldRefs {
    readonly id: FieldRef<"Homework", 'String'>
    readonly title: FieldRef<"Homework", 'String'>
    readonly content: FieldRef<"Homework", 'String'>
    readonly assignedDate: FieldRef<"Homework", 'DateTime'>
    readonly dueDate: FieldRef<"Homework", 'DateTime'>
    readonly lessonId: FieldRef<"Homework", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Homework findUnique
   */
  export type HomeworkFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkInclude<ExtArgs> | null
    /**
     * Filter, which Homework to fetch.
     */
    where: HomeworkWhereUniqueInput
  }

  /**
   * Homework findUniqueOrThrow
   */
  export type HomeworkFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkInclude<ExtArgs> | null
    /**
     * Filter, which Homework to fetch.
     */
    where: HomeworkWhereUniqueInput
  }

  /**
   * Homework findFirst
   */
  export type HomeworkFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkInclude<ExtArgs> | null
    /**
     * Filter, which Homework to fetch.
     */
    where?: HomeworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Homework to fetch.
     */
    orderBy?: HomeworkOrderByWithRelationInput | HomeworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Homework.
     */
    cursor?: HomeworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Homework from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Homework.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Homework.
     */
    distinct?: HomeworkScalarFieldEnum | HomeworkScalarFieldEnum[]
  }

  /**
   * Homework findFirstOrThrow
   */
  export type HomeworkFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkInclude<ExtArgs> | null
    /**
     * Filter, which Homework to fetch.
     */
    where?: HomeworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Homework to fetch.
     */
    orderBy?: HomeworkOrderByWithRelationInput | HomeworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Homework.
     */
    cursor?: HomeworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Homework from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Homework.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Homework.
     */
    distinct?: HomeworkScalarFieldEnum | HomeworkScalarFieldEnum[]
  }

  /**
   * Homework findMany
   */
  export type HomeworkFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkInclude<ExtArgs> | null
    /**
     * Filter, which Homework to fetch.
     */
    where?: HomeworkWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Homework to fetch.
     */
    orderBy?: HomeworkOrderByWithRelationInput | HomeworkOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Homework.
     */
    cursor?: HomeworkWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Homework from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Homework.
     */
    skip?: number
    distinct?: HomeworkScalarFieldEnum | HomeworkScalarFieldEnum[]
  }

  /**
   * Homework create
   */
  export type HomeworkCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkInclude<ExtArgs> | null
    /**
     * The data needed to create a Homework.
     */
    data: XOR<HomeworkCreateInput, HomeworkUncheckedCreateInput>
  }

  /**
   * Homework createMany
   */
  export type HomeworkCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Homework.
     */
    data: HomeworkCreateManyInput | HomeworkCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Homework createManyAndReturn
   */
  export type HomeworkCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * The data used to create many Homework.
     */
    data: HomeworkCreateManyInput | HomeworkCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Homework update
   */
  export type HomeworkUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkInclude<ExtArgs> | null
    /**
     * The data needed to update a Homework.
     */
    data: XOR<HomeworkUpdateInput, HomeworkUncheckedUpdateInput>
    /**
     * Choose, which Homework to update.
     */
    where: HomeworkWhereUniqueInput
  }

  /**
   * Homework updateMany
   */
  export type HomeworkUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Homework.
     */
    data: XOR<HomeworkUpdateManyMutationInput, HomeworkUncheckedUpdateManyInput>
    /**
     * Filter which Homework to update
     */
    where?: HomeworkWhereInput
    /**
     * Limit how many Homework to update.
     */
    limit?: number
  }

  /**
   * Homework updateManyAndReturn
   */
  export type HomeworkUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * The data used to update Homework.
     */
    data: XOR<HomeworkUpdateManyMutationInput, HomeworkUncheckedUpdateManyInput>
    /**
     * Filter which Homework to update
     */
    where?: HomeworkWhereInput
    /**
     * Limit how many Homework to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Homework upsert
   */
  export type HomeworkUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkInclude<ExtArgs> | null
    /**
     * The filter to search for the Homework to update in case it exists.
     */
    where: HomeworkWhereUniqueInput
    /**
     * In case the Homework found by the `where` argument doesn't exist, create a new Homework with this data.
     */
    create: XOR<HomeworkCreateInput, HomeworkUncheckedCreateInput>
    /**
     * In case the Homework was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomeworkUpdateInput, HomeworkUncheckedUpdateInput>
  }

  /**
   * Homework delete
   */
  export type HomeworkDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkInclude<ExtArgs> | null
    /**
     * Filter which Homework to delete.
     */
    where: HomeworkWhereUniqueInput
  }

  /**
   * Homework deleteMany
   */
  export type HomeworkDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Homework to delete
     */
    where?: HomeworkWhereInput
    /**
     * Limit how many Homework to delete.
     */
    limit?: number
  }

  /**
   * Homework.trackings
   */
  export type Homework$trackingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
    where?: HomeworkTrackingWhereInput
    orderBy?: HomeworkTrackingOrderByWithRelationInput | HomeworkTrackingOrderByWithRelationInput[]
    cursor?: HomeworkTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomeworkTrackingScalarFieldEnum | HomeworkTrackingScalarFieldEnum[]
  }

  /**
   * Homework without action
   */
  export type HomeworkDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Homework
     */
    select?: HomeworkSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Homework
     */
    omit?: HomeworkOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkInclude<ExtArgs> | null
  }


  /**
   * Model HomeworkTracking
   */

  export type AggregateHomeworkTracking = {
    _count: HomeworkTrackingCountAggregateOutputType | null
    _min: HomeworkTrackingMinAggregateOutputType | null
    _max: HomeworkTrackingMaxAggregateOutputType | null
  }

  export type HomeworkTrackingMinAggregateOutputType = {
    id: string | null
    homeworkId: string | null
    studentId: string | null
    status: $Enums.HomeworkStatus | null
    studentNote: string | null
    teacherNote: string | null
    fileId: string | null
    checkedAt: Date | null
  }

  export type HomeworkTrackingMaxAggregateOutputType = {
    id: string | null
    homeworkId: string | null
    studentId: string | null
    status: $Enums.HomeworkStatus | null
    studentNote: string | null
    teacherNote: string | null
    fileId: string | null
    checkedAt: Date | null
  }

  export type HomeworkTrackingCountAggregateOutputType = {
    id: number
    homeworkId: number
    studentId: number
    status: number
    studentNote: number
    teacherNote: number
    fileId: number
    checkedAt: number
    _all: number
  }


  export type HomeworkTrackingMinAggregateInputType = {
    id?: true
    homeworkId?: true
    studentId?: true
    status?: true
    studentNote?: true
    teacherNote?: true
    fileId?: true
    checkedAt?: true
  }

  export type HomeworkTrackingMaxAggregateInputType = {
    id?: true
    homeworkId?: true
    studentId?: true
    status?: true
    studentNote?: true
    teacherNote?: true
    fileId?: true
    checkedAt?: true
  }

  export type HomeworkTrackingCountAggregateInputType = {
    id?: true
    homeworkId?: true
    studentId?: true
    status?: true
    studentNote?: true
    teacherNote?: true
    fileId?: true
    checkedAt?: true
    _all?: true
  }

  export type HomeworkTrackingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomeworkTracking to aggregate.
     */
    where?: HomeworkTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeworkTrackings to fetch.
     */
    orderBy?: HomeworkTrackingOrderByWithRelationInput | HomeworkTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomeworkTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` HomeworkTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeworkTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomeworkTrackings
    **/
    _count?: true | HomeworkTrackingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomeworkTrackingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomeworkTrackingMaxAggregateInputType
  }

  export type GetHomeworkTrackingAggregateType<T extends HomeworkTrackingAggregateArgs> = {
        [P in keyof T & keyof AggregateHomeworkTracking]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomeworkTracking[P]>
      : GetScalarType<T[P], AggregateHomeworkTracking[P]>
  }




  export type HomeworkTrackingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeworkTrackingWhereInput
    orderBy?: HomeworkTrackingOrderByWithAggregationInput | HomeworkTrackingOrderByWithAggregationInput[]
    by: HomeworkTrackingScalarFieldEnum[] | HomeworkTrackingScalarFieldEnum
    having?: HomeworkTrackingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomeworkTrackingCountAggregateInputType | true
    _min?: HomeworkTrackingMinAggregateInputType
    _max?: HomeworkTrackingMaxAggregateInputType
  }

  export type HomeworkTrackingGroupByOutputType = {
    id: string
    homeworkId: string
    studentId: string
    status: $Enums.HomeworkStatus
    studentNote: string | null
    teacherNote: string | null
    fileId: string | null
    checkedAt: Date | null
    _count: HomeworkTrackingCountAggregateOutputType | null
    _min: HomeworkTrackingMinAggregateOutputType | null
    _max: HomeworkTrackingMaxAggregateOutputType | null
  }

  type GetHomeworkTrackingGroupByPayload<T extends HomeworkTrackingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HomeworkTrackingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomeworkTrackingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomeworkTrackingGroupByOutputType[P]>
            : GetScalarType<T[P], HomeworkTrackingGroupByOutputType[P]>
        }
      >
    >


  export type HomeworkTrackingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    homeworkId?: boolean
    studentId?: boolean
    status?: boolean
    studentNote?: boolean
    teacherNote?: boolean
    fileId?: boolean
    checkedAt?: boolean
    file?: boolean | HomeworkTracking$fileArgs<ExtArgs>
    homework?: boolean | HomeworkDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homeworkTracking"]>

  export type HomeworkTrackingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    homeworkId?: boolean
    studentId?: boolean
    status?: boolean
    studentNote?: boolean
    teacherNote?: boolean
    fileId?: boolean
    checkedAt?: boolean
    file?: boolean | HomeworkTracking$fileArgs<ExtArgs>
    homework?: boolean | HomeworkDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homeworkTracking"]>

  export type HomeworkTrackingSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    homeworkId?: boolean
    studentId?: boolean
    status?: boolean
    studentNote?: boolean
    teacherNote?: boolean
    fileId?: boolean
    checkedAt?: boolean
    file?: boolean | HomeworkTracking$fileArgs<ExtArgs>
    homework?: boolean | HomeworkDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homeworkTracking"]>

  export type HomeworkTrackingSelectScalar = {
    id?: boolean
    homeworkId?: boolean
    studentId?: boolean
    status?: boolean
    studentNote?: boolean
    teacherNote?: boolean
    fileId?: boolean
    checkedAt?: boolean
  }

  export type HomeworkTrackingOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "homeworkId" | "studentId" | "status" | "studentNote" | "teacherNote" | "fileId" | "checkedAt", ExtArgs["result"]["homeworkTracking"]>
  export type HomeworkTrackingInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | HomeworkTracking$fileArgs<ExtArgs>
    homework?: boolean | HomeworkDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type HomeworkTrackingIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | HomeworkTracking$fileArgs<ExtArgs>
    homework?: boolean | HomeworkDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type HomeworkTrackingIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | HomeworkTracking$fileArgs<ExtArgs>
    homework?: boolean | HomeworkDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $HomeworkTrackingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HomeworkTracking"
    objects: {
      file: Prisma.$FilePayload<ExtArgs> | null
      homework: Prisma.$HomeworkPayload<ExtArgs>
      student: Prisma.$StudentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      homeworkId: string
      studentId: string
      status: $Enums.HomeworkStatus
      studentNote: string | null
      teacherNote: string | null
      fileId: string | null
      checkedAt: Date | null
    }, ExtArgs["result"]["homeworkTracking"]>
    composites: {}
  }

  type HomeworkTrackingGetPayload<S extends boolean | null | undefined | HomeworkTrackingDefaultArgs> = $Result.GetResult<Prisma.$HomeworkTrackingPayload, S>

  type HomeworkTrackingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HomeworkTrackingFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HomeworkTrackingCountAggregateInputType | true
    }

  export interface HomeworkTrackingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HomeworkTracking'], meta: { name: 'HomeworkTracking' } }
    /**
     * Find zero or one HomeworkTracking that matches the filter.
     * @param {HomeworkTrackingFindUniqueArgs} args - Arguments to find a HomeworkTracking
     * @example
     * // Get one HomeworkTracking
     * const homeworkTracking = await prisma.homeworkTracking.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HomeworkTrackingFindUniqueArgs>(args: SelectSubset<T, HomeworkTrackingFindUniqueArgs<ExtArgs>>): Prisma__HomeworkTrackingClient<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HomeworkTracking that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HomeworkTrackingFindUniqueOrThrowArgs} args - Arguments to find a HomeworkTracking
     * @example
     * // Get one HomeworkTracking
     * const homeworkTracking = await prisma.homeworkTracking.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HomeworkTrackingFindUniqueOrThrowArgs>(args: SelectSubset<T, HomeworkTrackingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HomeworkTrackingClient<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HomeworkTracking that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkTrackingFindFirstArgs} args - Arguments to find a HomeworkTracking
     * @example
     * // Get one HomeworkTracking
     * const homeworkTracking = await prisma.homeworkTracking.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HomeworkTrackingFindFirstArgs>(args?: SelectSubset<T, HomeworkTrackingFindFirstArgs<ExtArgs>>): Prisma__HomeworkTrackingClient<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HomeworkTracking that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkTrackingFindFirstOrThrowArgs} args - Arguments to find a HomeworkTracking
     * @example
     * // Get one HomeworkTracking
     * const homeworkTracking = await prisma.homeworkTracking.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HomeworkTrackingFindFirstOrThrowArgs>(args?: SelectSubset<T, HomeworkTrackingFindFirstOrThrowArgs<ExtArgs>>): Prisma__HomeworkTrackingClient<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HomeworkTrackings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkTrackingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomeworkTrackings
     * const homeworkTrackings = await prisma.homeworkTracking.findMany()
     * 
     * // Get first 10 HomeworkTrackings
     * const homeworkTrackings = await prisma.homeworkTracking.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homeworkTrackingWithIdOnly = await prisma.homeworkTracking.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HomeworkTrackingFindManyArgs>(args?: SelectSubset<T, HomeworkTrackingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HomeworkTracking.
     * @param {HomeworkTrackingCreateArgs} args - Arguments to create a HomeworkTracking.
     * @example
     * // Create one HomeworkTracking
     * const HomeworkTracking = await prisma.homeworkTracking.create({
     *   data: {
     *     // ... data to create a HomeworkTracking
     *   }
     * })
     * 
     */
    create<T extends HomeworkTrackingCreateArgs>(args: SelectSubset<T, HomeworkTrackingCreateArgs<ExtArgs>>): Prisma__HomeworkTrackingClient<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HomeworkTrackings.
     * @param {HomeworkTrackingCreateManyArgs} args - Arguments to create many HomeworkTrackings.
     * @example
     * // Create many HomeworkTrackings
     * const homeworkTracking = await prisma.homeworkTracking.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HomeworkTrackingCreateManyArgs>(args?: SelectSubset<T, HomeworkTrackingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HomeworkTrackings and returns the data saved in the database.
     * @param {HomeworkTrackingCreateManyAndReturnArgs} args - Arguments to create many HomeworkTrackings.
     * @example
     * // Create many HomeworkTrackings
     * const homeworkTracking = await prisma.homeworkTracking.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HomeworkTrackings and only return the `id`
     * const homeworkTrackingWithIdOnly = await prisma.homeworkTracking.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HomeworkTrackingCreateManyAndReturnArgs>(args?: SelectSubset<T, HomeworkTrackingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HomeworkTracking.
     * @param {HomeworkTrackingDeleteArgs} args - Arguments to delete one HomeworkTracking.
     * @example
     * // Delete one HomeworkTracking
     * const HomeworkTracking = await prisma.homeworkTracking.delete({
     *   where: {
     *     // ... filter to delete one HomeworkTracking
     *   }
     * })
     * 
     */
    delete<T extends HomeworkTrackingDeleteArgs>(args: SelectSubset<T, HomeworkTrackingDeleteArgs<ExtArgs>>): Prisma__HomeworkTrackingClient<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HomeworkTracking.
     * @param {HomeworkTrackingUpdateArgs} args - Arguments to update one HomeworkTracking.
     * @example
     * // Update one HomeworkTracking
     * const homeworkTracking = await prisma.homeworkTracking.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HomeworkTrackingUpdateArgs>(args: SelectSubset<T, HomeworkTrackingUpdateArgs<ExtArgs>>): Prisma__HomeworkTrackingClient<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HomeworkTrackings.
     * @param {HomeworkTrackingDeleteManyArgs} args - Arguments to filter HomeworkTrackings to delete.
     * @example
     * // Delete a few HomeworkTrackings
     * const { count } = await prisma.homeworkTracking.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HomeworkTrackingDeleteManyArgs>(args?: SelectSubset<T, HomeworkTrackingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomeworkTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkTrackingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomeworkTrackings
     * const homeworkTracking = await prisma.homeworkTracking.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HomeworkTrackingUpdateManyArgs>(args: SelectSubset<T, HomeworkTrackingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomeworkTrackings and returns the data updated in the database.
     * @param {HomeworkTrackingUpdateManyAndReturnArgs} args - Arguments to update many HomeworkTrackings.
     * @example
     * // Update many HomeworkTrackings
     * const homeworkTracking = await prisma.homeworkTracking.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HomeworkTrackings and only return the `id`
     * const homeworkTrackingWithIdOnly = await prisma.homeworkTracking.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HomeworkTrackingUpdateManyAndReturnArgs>(args: SelectSubset<T, HomeworkTrackingUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HomeworkTracking.
     * @param {HomeworkTrackingUpsertArgs} args - Arguments to update or create a HomeworkTracking.
     * @example
     * // Update or create a HomeworkTracking
     * const homeworkTracking = await prisma.homeworkTracking.upsert({
     *   create: {
     *     // ... data to create a HomeworkTracking
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomeworkTracking we want to update
     *   }
     * })
     */
    upsert<T extends HomeworkTrackingUpsertArgs>(args: SelectSubset<T, HomeworkTrackingUpsertArgs<ExtArgs>>): Prisma__HomeworkTrackingClient<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HomeworkTrackings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkTrackingCountArgs} args - Arguments to filter HomeworkTrackings to count.
     * @example
     * // Count the number of HomeworkTrackings
     * const count = await prisma.homeworkTracking.count({
     *   where: {
     *     // ... the filter for the HomeworkTrackings we want to count
     *   }
     * })
    **/
    count<T extends HomeworkTrackingCountArgs>(
      args?: Subset<T, HomeworkTrackingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomeworkTrackingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomeworkTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkTrackingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomeworkTrackingAggregateArgs>(args: Subset<T, HomeworkTrackingAggregateArgs>): Prisma.PrismaPromise<GetHomeworkTrackingAggregateType<T>>

    /**
     * Group by HomeworkTracking.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkTrackingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomeworkTrackingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomeworkTrackingGroupByArgs['orderBy'] }
        : { orderBy?: HomeworkTrackingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomeworkTrackingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomeworkTrackingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HomeworkTracking model
   */
  readonly fields: HomeworkTrackingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HomeworkTracking.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HomeworkTrackingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends HomeworkTracking$fileArgs<ExtArgs> = {}>(args?: Subset<T, HomeworkTracking$fileArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    homework<T extends HomeworkDefaultArgs<ExtArgs> = {}>(args?: Subset<T, HomeworkDefaultArgs<ExtArgs>>): Prisma__HomeworkClient<$Result.GetResult<Prisma.$HomeworkPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HomeworkTracking model
   */
  interface HomeworkTrackingFieldRefs {
    readonly id: FieldRef<"HomeworkTracking", 'String'>
    readonly homeworkId: FieldRef<"HomeworkTracking", 'String'>
    readonly studentId: FieldRef<"HomeworkTracking", 'String'>
    readonly status: FieldRef<"HomeworkTracking", 'HomeworkStatus'>
    readonly studentNote: FieldRef<"HomeworkTracking", 'String'>
    readonly teacherNote: FieldRef<"HomeworkTracking", 'String'>
    readonly fileId: FieldRef<"HomeworkTracking", 'String'>
    readonly checkedAt: FieldRef<"HomeworkTracking", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HomeworkTracking findUnique
   */
  export type HomeworkTrackingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
    /**
     * Filter, which HomeworkTracking to fetch.
     */
    where: HomeworkTrackingWhereUniqueInput
  }

  /**
   * HomeworkTracking findUniqueOrThrow
   */
  export type HomeworkTrackingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
    /**
     * Filter, which HomeworkTracking to fetch.
     */
    where: HomeworkTrackingWhereUniqueInput
  }

  /**
   * HomeworkTracking findFirst
   */
  export type HomeworkTrackingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
    /**
     * Filter, which HomeworkTracking to fetch.
     */
    where?: HomeworkTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeworkTrackings to fetch.
     */
    orderBy?: HomeworkTrackingOrderByWithRelationInput | HomeworkTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeworkTrackings.
     */
    cursor?: HomeworkTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` HomeworkTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeworkTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeworkTrackings.
     */
    distinct?: HomeworkTrackingScalarFieldEnum | HomeworkTrackingScalarFieldEnum[]
  }

  /**
   * HomeworkTracking findFirstOrThrow
   */
  export type HomeworkTrackingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
    /**
     * Filter, which HomeworkTracking to fetch.
     */
    where?: HomeworkTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeworkTrackings to fetch.
     */
    orderBy?: HomeworkTrackingOrderByWithRelationInput | HomeworkTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeworkTrackings.
     */
    cursor?: HomeworkTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` HomeworkTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeworkTrackings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeworkTrackings.
     */
    distinct?: HomeworkTrackingScalarFieldEnum | HomeworkTrackingScalarFieldEnum[]
  }

  /**
   * HomeworkTracking findMany
   */
  export type HomeworkTrackingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
    /**
     * Filter, which HomeworkTrackings to fetch.
     */
    where?: HomeworkTrackingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeworkTrackings to fetch.
     */
    orderBy?: HomeworkTrackingOrderByWithRelationInput | HomeworkTrackingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomeworkTrackings.
     */
    cursor?: HomeworkTrackingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` HomeworkTrackings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeworkTrackings.
     */
    skip?: number
    distinct?: HomeworkTrackingScalarFieldEnum | HomeworkTrackingScalarFieldEnum[]
  }

  /**
   * HomeworkTracking create
   */
  export type HomeworkTrackingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
    /**
     * The data needed to create a HomeworkTracking.
     */
    data: XOR<HomeworkTrackingCreateInput, HomeworkTrackingUncheckedCreateInput>
  }

  /**
   * HomeworkTracking createMany
   */
  export type HomeworkTrackingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HomeworkTrackings.
     */
    data: HomeworkTrackingCreateManyInput | HomeworkTrackingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HomeworkTracking createManyAndReturn
   */
  export type HomeworkTrackingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * The data used to create many HomeworkTrackings.
     */
    data: HomeworkTrackingCreateManyInput | HomeworkTrackingCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HomeworkTracking update
   */
  export type HomeworkTrackingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
    /**
     * The data needed to update a HomeworkTracking.
     */
    data: XOR<HomeworkTrackingUpdateInput, HomeworkTrackingUncheckedUpdateInput>
    /**
     * Choose, which HomeworkTracking to update.
     */
    where: HomeworkTrackingWhereUniqueInput
  }

  /**
   * HomeworkTracking updateMany
   */
  export type HomeworkTrackingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HomeworkTrackings.
     */
    data: XOR<HomeworkTrackingUpdateManyMutationInput, HomeworkTrackingUncheckedUpdateManyInput>
    /**
     * Filter which HomeworkTrackings to update
     */
    where?: HomeworkTrackingWhereInput
    /**
     * Limit how many HomeworkTrackings to update.
     */
    limit?: number
  }

  /**
   * HomeworkTracking updateManyAndReturn
   */
  export type HomeworkTrackingUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * The data used to update HomeworkTrackings.
     */
    data: XOR<HomeworkTrackingUpdateManyMutationInput, HomeworkTrackingUncheckedUpdateManyInput>
    /**
     * Filter which HomeworkTrackings to update
     */
    where?: HomeworkTrackingWhereInput
    /**
     * Limit how many HomeworkTrackings to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HomeworkTracking upsert
   */
  export type HomeworkTrackingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
    /**
     * The filter to search for the HomeworkTracking to update in case it exists.
     */
    where: HomeworkTrackingWhereUniqueInput
    /**
     * In case the HomeworkTracking found by the `where` argument doesn't exist, create a new HomeworkTracking with this data.
     */
    create: XOR<HomeworkTrackingCreateInput, HomeworkTrackingUncheckedCreateInput>
    /**
     * In case the HomeworkTracking was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomeworkTrackingUpdateInput, HomeworkTrackingUncheckedUpdateInput>
  }

  /**
   * HomeworkTracking delete
   */
  export type HomeworkTrackingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
    /**
     * Filter which HomeworkTracking to delete.
     */
    where: HomeworkTrackingWhereUniqueInput
  }

  /**
   * HomeworkTracking deleteMany
   */
  export type HomeworkTrackingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomeworkTrackings to delete
     */
    where?: HomeworkTrackingWhereInput
    /**
     * Limit how many HomeworkTrackings to delete.
     */
    limit?: number
  }

  /**
   * HomeworkTracking.file
   */
  export type HomeworkTracking$fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
  }

  /**
   * HomeworkTracking without action
   */
  export type HomeworkTrackingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
  }


  /**
   * Model HomeworkSubmission
   */

  export type AggregateHomeworkSubmission = {
    _count: HomeworkSubmissionCountAggregateOutputType | null
    _min: HomeworkSubmissionMinAggregateOutputType | null
    _max: HomeworkSubmissionMaxAggregateOutputType | null
  }

  export type HomeworkSubmissionMinAggregateOutputType = {
    id: string | null
    fileId: string | null
    note: string | null
    submittedAt: Date | null
    studentId: string | null
  }

  export type HomeworkSubmissionMaxAggregateOutputType = {
    id: string | null
    fileId: string | null
    note: string | null
    submittedAt: Date | null
    studentId: string | null
  }

  export type HomeworkSubmissionCountAggregateOutputType = {
    id: number
    fileId: number
    note: number
    submittedAt: number
    studentId: number
    _all: number
  }


  export type HomeworkSubmissionMinAggregateInputType = {
    id?: true
    fileId?: true
    note?: true
    submittedAt?: true
    studentId?: true
  }

  export type HomeworkSubmissionMaxAggregateInputType = {
    id?: true
    fileId?: true
    note?: true
    submittedAt?: true
    studentId?: true
  }

  export type HomeworkSubmissionCountAggregateInputType = {
    id?: true
    fileId?: true
    note?: true
    submittedAt?: true
    studentId?: true
    _all?: true
  }

  export type HomeworkSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomeworkSubmission to aggregate.
     */
    where?: HomeworkSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeworkSubmissions to fetch.
     */
    orderBy?: HomeworkSubmissionOrderByWithRelationInput | HomeworkSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HomeworkSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` HomeworkSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeworkSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HomeworkSubmissions
    **/
    _count?: true | HomeworkSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HomeworkSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HomeworkSubmissionMaxAggregateInputType
  }

  export type GetHomeworkSubmissionAggregateType<T extends HomeworkSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateHomeworkSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHomeworkSubmission[P]>
      : GetScalarType<T[P], AggregateHomeworkSubmission[P]>
  }




  export type HomeworkSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HomeworkSubmissionWhereInput
    orderBy?: HomeworkSubmissionOrderByWithAggregationInput | HomeworkSubmissionOrderByWithAggregationInput[]
    by: HomeworkSubmissionScalarFieldEnum[] | HomeworkSubmissionScalarFieldEnum
    having?: HomeworkSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HomeworkSubmissionCountAggregateInputType | true
    _min?: HomeworkSubmissionMinAggregateInputType
    _max?: HomeworkSubmissionMaxAggregateInputType
  }

  export type HomeworkSubmissionGroupByOutputType = {
    id: string
    fileId: string | null
    note: string | null
    submittedAt: Date
    studentId: string
    _count: HomeworkSubmissionCountAggregateOutputType | null
    _min: HomeworkSubmissionMinAggregateOutputType | null
    _max: HomeworkSubmissionMaxAggregateOutputType | null
  }

  type GetHomeworkSubmissionGroupByPayload<T extends HomeworkSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HomeworkSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HomeworkSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HomeworkSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], HomeworkSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type HomeworkSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    note?: boolean
    submittedAt?: boolean
    studentId?: boolean
    file?: boolean | HomeworkSubmission$fileArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homeworkSubmission"]>

  export type HomeworkSubmissionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    note?: boolean
    submittedAt?: boolean
    studentId?: boolean
    file?: boolean | HomeworkSubmission$fileArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homeworkSubmission"]>

  export type HomeworkSubmissionSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    fileId?: boolean
    note?: boolean
    submittedAt?: boolean
    studentId?: boolean
    file?: boolean | HomeworkSubmission$fileArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["homeworkSubmission"]>

  export type HomeworkSubmissionSelectScalar = {
    id?: boolean
    fileId?: boolean
    note?: boolean
    submittedAt?: boolean
    studentId?: boolean
  }

  export type HomeworkSubmissionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "fileId" | "note" | "submittedAt" | "studentId", ExtArgs["result"]["homeworkSubmission"]>
  export type HomeworkSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | HomeworkSubmission$fileArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type HomeworkSubmissionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | HomeworkSubmission$fileArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type HomeworkSubmissionIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | HomeworkSubmission$fileArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $HomeworkSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HomeworkSubmission"
    objects: {
      file: Prisma.$FilePayload<ExtArgs> | null
      student: Prisma.$StudentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      fileId: string | null
      note: string | null
      submittedAt: Date
      studentId: string
    }, ExtArgs["result"]["homeworkSubmission"]>
    composites: {}
  }

  type HomeworkSubmissionGetPayload<S extends boolean | null | undefined | HomeworkSubmissionDefaultArgs> = $Result.GetResult<Prisma.$HomeworkSubmissionPayload, S>

  type HomeworkSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<HomeworkSubmissionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: HomeworkSubmissionCountAggregateInputType | true
    }

  export interface HomeworkSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HomeworkSubmission'], meta: { name: 'HomeworkSubmission' } }
    /**
     * Find zero or one HomeworkSubmission that matches the filter.
     * @param {HomeworkSubmissionFindUniqueArgs} args - Arguments to find a HomeworkSubmission
     * @example
     * // Get one HomeworkSubmission
     * const homeworkSubmission = await prisma.homeworkSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HomeworkSubmissionFindUniqueArgs>(args: SelectSubset<T, HomeworkSubmissionFindUniqueArgs<ExtArgs>>): Prisma__HomeworkSubmissionClient<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one HomeworkSubmission that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {HomeworkSubmissionFindUniqueOrThrowArgs} args - Arguments to find a HomeworkSubmission
     * @example
     * // Get one HomeworkSubmission
     * const homeworkSubmission = await prisma.homeworkSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HomeworkSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, HomeworkSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HomeworkSubmissionClient<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HomeworkSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkSubmissionFindFirstArgs} args - Arguments to find a HomeworkSubmission
     * @example
     * // Get one HomeworkSubmission
     * const homeworkSubmission = await prisma.homeworkSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HomeworkSubmissionFindFirstArgs>(args?: SelectSubset<T, HomeworkSubmissionFindFirstArgs<ExtArgs>>): Prisma__HomeworkSubmissionClient<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first HomeworkSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkSubmissionFindFirstOrThrowArgs} args - Arguments to find a HomeworkSubmission
     * @example
     * // Get one HomeworkSubmission
     * const homeworkSubmission = await prisma.homeworkSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HomeworkSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, HomeworkSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__HomeworkSubmissionClient<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more HomeworkSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HomeworkSubmissions
     * const homeworkSubmissions = await prisma.homeworkSubmission.findMany()
     * 
     * // Get first 10 HomeworkSubmissions
     * const homeworkSubmissions = await prisma.homeworkSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const homeworkSubmissionWithIdOnly = await prisma.homeworkSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HomeworkSubmissionFindManyArgs>(args?: SelectSubset<T, HomeworkSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a HomeworkSubmission.
     * @param {HomeworkSubmissionCreateArgs} args - Arguments to create a HomeworkSubmission.
     * @example
     * // Create one HomeworkSubmission
     * const HomeworkSubmission = await prisma.homeworkSubmission.create({
     *   data: {
     *     // ... data to create a HomeworkSubmission
     *   }
     * })
     * 
     */
    create<T extends HomeworkSubmissionCreateArgs>(args: SelectSubset<T, HomeworkSubmissionCreateArgs<ExtArgs>>): Prisma__HomeworkSubmissionClient<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many HomeworkSubmissions.
     * @param {HomeworkSubmissionCreateManyArgs} args - Arguments to create many HomeworkSubmissions.
     * @example
     * // Create many HomeworkSubmissions
     * const homeworkSubmission = await prisma.homeworkSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HomeworkSubmissionCreateManyArgs>(args?: SelectSubset<T, HomeworkSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HomeworkSubmissions and returns the data saved in the database.
     * @param {HomeworkSubmissionCreateManyAndReturnArgs} args - Arguments to create many HomeworkSubmissions.
     * @example
     * // Create many HomeworkSubmissions
     * const homeworkSubmission = await prisma.homeworkSubmission.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HomeworkSubmissions and only return the `id`
     * const homeworkSubmissionWithIdOnly = await prisma.homeworkSubmission.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HomeworkSubmissionCreateManyAndReturnArgs>(args?: SelectSubset<T, HomeworkSubmissionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a HomeworkSubmission.
     * @param {HomeworkSubmissionDeleteArgs} args - Arguments to delete one HomeworkSubmission.
     * @example
     * // Delete one HomeworkSubmission
     * const HomeworkSubmission = await prisma.homeworkSubmission.delete({
     *   where: {
     *     // ... filter to delete one HomeworkSubmission
     *   }
     * })
     * 
     */
    delete<T extends HomeworkSubmissionDeleteArgs>(args: SelectSubset<T, HomeworkSubmissionDeleteArgs<ExtArgs>>): Prisma__HomeworkSubmissionClient<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one HomeworkSubmission.
     * @param {HomeworkSubmissionUpdateArgs} args - Arguments to update one HomeworkSubmission.
     * @example
     * // Update one HomeworkSubmission
     * const homeworkSubmission = await prisma.homeworkSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HomeworkSubmissionUpdateArgs>(args: SelectSubset<T, HomeworkSubmissionUpdateArgs<ExtArgs>>): Prisma__HomeworkSubmissionClient<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more HomeworkSubmissions.
     * @param {HomeworkSubmissionDeleteManyArgs} args - Arguments to filter HomeworkSubmissions to delete.
     * @example
     * // Delete a few HomeworkSubmissions
     * const { count } = await prisma.homeworkSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HomeworkSubmissionDeleteManyArgs>(args?: SelectSubset<T, HomeworkSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomeworkSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HomeworkSubmissions
     * const homeworkSubmission = await prisma.homeworkSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HomeworkSubmissionUpdateManyArgs>(args: SelectSubset<T, HomeworkSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HomeworkSubmissions and returns the data updated in the database.
     * @param {HomeworkSubmissionUpdateManyAndReturnArgs} args - Arguments to update many HomeworkSubmissions.
     * @example
     * // Update many HomeworkSubmissions
     * const homeworkSubmission = await prisma.homeworkSubmission.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more HomeworkSubmissions and only return the `id`
     * const homeworkSubmissionWithIdOnly = await prisma.homeworkSubmission.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends HomeworkSubmissionUpdateManyAndReturnArgs>(args: SelectSubset<T, HomeworkSubmissionUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one HomeworkSubmission.
     * @param {HomeworkSubmissionUpsertArgs} args - Arguments to update or create a HomeworkSubmission.
     * @example
     * // Update or create a HomeworkSubmission
     * const homeworkSubmission = await prisma.homeworkSubmission.upsert({
     *   create: {
     *     // ... data to create a HomeworkSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HomeworkSubmission we want to update
     *   }
     * })
     */
    upsert<T extends HomeworkSubmissionUpsertArgs>(args: SelectSubset<T, HomeworkSubmissionUpsertArgs<ExtArgs>>): Prisma__HomeworkSubmissionClient<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of HomeworkSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkSubmissionCountArgs} args - Arguments to filter HomeworkSubmissions to count.
     * @example
     * // Count the number of HomeworkSubmissions
     * const count = await prisma.homeworkSubmission.count({
     *   where: {
     *     // ... the filter for the HomeworkSubmissions we want to count
     *   }
     * })
    **/
    count<T extends HomeworkSubmissionCountArgs>(
      args?: Subset<T, HomeworkSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HomeworkSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HomeworkSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HomeworkSubmissionAggregateArgs>(args: Subset<T, HomeworkSubmissionAggregateArgs>): Prisma.PrismaPromise<GetHomeworkSubmissionAggregateType<T>>

    /**
     * Group by HomeworkSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HomeworkSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HomeworkSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HomeworkSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: HomeworkSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HomeworkSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHomeworkSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HomeworkSubmission model
   */
  readonly fields: HomeworkSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HomeworkSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HomeworkSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends HomeworkSubmission$fileArgs<ExtArgs> = {}>(args?: Subset<T, HomeworkSubmission$fileArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HomeworkSubmission model
   */
  interface HomeworkSubmissionFieldRefs {
    readonly id: FieldRef<"HomeworkSubmission", 'String'>
    readonly fileId: FieldRef<"HomeworkSubmission", 'String'>
    readonly note: FieldRef<"HomeworkSubmission", 'String'>
    readonly submittedAt: FieldRef<"HomeworkSubmission", 'DateTime'>
    readonly studentId: FieldRef<"HomeworkSubmission", 'String'>
  }
    

  // Custom InputTypes
  /**
   * HomeworkSubmission findUnique
   */
  export type HomeworkSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which HomeworkSubmission to fetch.
     */
    where: HomeworkSubmissionWhereUniqueInput
  }

  /**
   * HomeworkSubmission findUniqueOrThrow
   */
  export type HomeworkSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which HomeworkSubmission to fetch.
     */
    where: HomeworkSubmissionWhereUniqueInput
  }

  /**
   * HomeworkSubmission findFirst
   */
  export type HomeworkSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which HomeworkSubmission to fetch.
     */
    where?: HomeworkSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeworkSubmissions to fetch.
     */
    orderBy?: HomeworkSubmissionOrderByWithRelationInput | HomeworkSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeworkSubmissions.
     */
    cursor?: HomeworkSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` HomeworkSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeworkSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeworkSubmissions.
     */
    distinct?: HomeworkSubmissionScalarFieldEnum | HomeworkSubmissionScalarFieldEnum[]
  }

  /**
   * HomeworkSubmission findFirstOrThrow
   */
  export type HomeworkSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which HomeworkSubmission to fetch.
     */
    where?: HomeworkSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeworkSubmissions to fetch.
     */
    orderBy?: HomeworkSubmissionOrderByWithRelationInput | HomeworkSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HomeworkSubmissions.
     */
    cursor?: HomeworkSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` HomeworkSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeworkSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HomeworkSubmissions.
     */
    distinct?: HomeworkSubmissionScalarFieldEnum | HomeworkSubmissionScalarFieldEnum[]
  }

  /**
   * HomeworkSubmission findMany
   */
  export type HomeworkSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which HomeworkSubmissions to fetch.
     */
    where?: HomeworkSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HomeworkSubmissions to fetch.
     */
    orderBy?: HomeworkSubmissionOrderByWithRelationInput | HomeworkSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HomeworkSubmissions.
     */
    cursor?: HomeworkSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` HomeworkSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HomeworkSubmissions.
     */
    skip?: number
    distinct?: HomeworkSubmissionScalarFieldEnum | HomeworkSubmissionScalarFieldEnum[]
  }

  /**
   * HomeworkSubmission create
   */
  export type HomeworkSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a HomeworkSubmission.
     */
    data: XOR<HomeworkSubmissionCreateInput, HomeworkSubmissionUncheckedCreateInput>
  }

  /**
   * HomeworkSubmission createMany
   */
  export type HomeworkSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HomeworkSubmissions.
     */
    data: HomeworkSubmissionCreateManyInput | HomeworkSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HomeworkSubmission createManyAndReturn
   */
  export type HomeworkSubmissionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * The data used to create many HomeworkSubmissions.
     */
    data: HomeworkSubmissionCreateManyInput | HomeworkSubmissionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HomeworkSubmission update
   */
  export type HomeworkSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a HomeworkSubmission.
     */
    data: XOR<HomeworkSubmissionUpdateInput, HomeworkSubmissionUncheckedUpdateInput>
    /**
     * Choose, which HomeworkSubmission to update.
     */
    where: HomeworkSubmissionWhereUniqueInput
  }

  /**
   * HomeworkSubmission updateMany
   */
  export type HomeworkSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HomeworkSubmissions.
     */
    data: XOR<HomeworkSubmissionUpdateManyMutationInput, HomeworkSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which HomeworkSubmissions to update
     */
    where?: HomeworkSubmissionWhereInput
    /**
     * Limit how many HomeworkSubmissions to update.
     */
    limit?: number
  }

  /**
   * HomeworkSubmission updateManyAndReturn
   */
  export type HomeworkSubmissionUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * The data used to update HomeworkSubmissions.
     */
    data: XOR<HomeworkSubmissionUpdateManyMutationInput, HomeworkSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which HomeworkSubmissions to update
     */
    where?: HomeworkSubmissionWhereInput
    /**
     * Limit how many HomeworkSubmissions to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * HomeworkSubmission upsert
   */
  export type HomeworkSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the HomeworkSubmission to update in case it exists.
     */
    where: HomeworkSubmissionWhereUniqueInput
    /**
     * In case the HomeworkSubmission found by the `where` argument doesn't exist, create a new HomeworkSubmission with this data.
     */
    create: XOR<HomeworkSubmissionCreateInput, HomeworkSubmissionUncheckedCreateInput>
    /**
     * In case the HomeworkSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HomeworkSubmissionUpdateInput, HomeworkSubmissionUncheckedUpdateInput>
  }

  /**
   * HomeworkSubmission delete
   */
  export type HomeworkSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionInclude<ExtArgs> | null
    /**
     * Filter which HomeworkSubmission to delete.
     */
    where: HomeworkSubmissionWhereUniqueInput
  }

  /**
   * HomeworkSubmission deleteMany
   */
  export type HomeworkSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HomeworkSubmissions to delete
     */
    where?: HomeworkSubmissionWhereInput
    /**
     * Limit how many HomeworkSubmissions to delete.
     */
    limit?: number
  }

  /**
   * HomeworkSubmission.file
   */
  export type HomeworkSubmission$fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
  }

  /**
   * HomeworkSubmission without action
   */
  export type HomeworkSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model SchoolExam
   */

  export type AggregateSchoolExam = {
    _count: SchoolExamCountAggregateOutputType | null
    _avg: SchoolExamAvgAggregateOutputType | null
    _sum: SchoolExamSumAggregateOutputType | null
    _min: SchoolExamMinAggregateOutputType | null
    _max: SchoolExamMaxAggregateOutputType | null
  }

  export type SchoolExamAvgAggregateOutputType = {
    score: number | null
  }

  export type SchoolExamSumAggregateOutputType = {
    score: number | null
  }

  export type SchoolExamMinAggregateOutputType = {
    id: string | null
    title: string | null
    score: number | null
    date: Date | null
    subject: string | null
    studentId: string | null
  }

  export type SchoolExamMaxAggregateOutputType = {
    id: string | null
    title: string | null
    score: number | null
    date: Date | null
    subject: string | null
    studentId: string | null
  }

  export type SchoolExamCountAggregateOutputType = {
    id: number
    title: number
    score: number
    date: number
    subject: number
    studentId: number
    _all: number
  }


  export type SchoolExamAvgAggregateInputType = {
    score?: true
  }

  export type SchoolExamSumAggregateInputType = {
    score?: true
  }

  export type SchoolExamMinAggregateInputType = {
    id?: true
    title?: true
    score?: true
    date?: true
    subject?: true
    studentId?: true
  }

  export type SchoolExamMaxAggregateInputType = {
    id?: true
    title?: true
    score?: true
    date?: true
    subject?: true
    studentId?: true
  }

  export type SchoolExamCountAggregateInputType = {
    id?: true
    title?: true
    score?: true
    date?: true
    subject?: true
    studentId?: true
    _all?: true
  }

  export type SchoolExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolExam to aggregate.
     */
    where?: SchoolExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolExams to fetch.
     */
    orderBy?: SchoolExamOrderByWithRelationInput | SchoolExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SchoolExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` SchoolExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SchoolExams
    **/
    _count?: true | SchoolExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SchoolExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SchoolExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SchoolExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SchoolExamMaxAggregateInputType
  }

  export type GetSchoolExamAggregateType<T extends SchoolExamAggregateArgs> = {
        [P in keyof T & keyof AggregateSchoolExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSchoolExam[P]>
      : GetScalarType<T[P], AggregateSchoolExam[P]>
  }




  export type SchoolExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SchoolExamWhereInput
    orderBy?: SchoolExamOrderByWithAggregationInput | SchoolExamOrderByWithAggregationInput[]
    by: SchoolExamScalarFieldEnum[] | SchoolExamScalarFieldEnum
    having?: SchoolExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SchoolExamCountAggregateInputType | true
    _avg?: SchoolExamAvgAggregateInputType
    _sum?: SchoolExamSumAggregateInputType
    _min?: SchoolExamMinAggregateInputType
    _max?: SchoolExamMaxAggregateInputType
  }

  export type SchoolExamGroupByOutputType = {
    id: string
    title: string
    score: number
    date: Date
    subject: string
    studentId: string
    _count: SchoolExamCountAggregateOutputType | null
    _avg: SchoolExamAvgAggregateOutputType | null
    _sum: SchoolExamSumAggregateOutputType | null
    _min: SchoolExamMinAggregateOutputType | null
    _max: SchoolExamMaxAggregateOutputType | null
  }

  type GetSchoolExamGroupByPayload<T extends SchoolExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SchoolExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SchoolExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SchoolExamGroupByOutputType[P]>
            : GetScalarType<T[P], SchoolExamGroupByOutputType[P]>
        }
      >
    >


  export type SchoolExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    score?: boolean
    date?: boolean
    subject?: boolean
    studentId?: boolean
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolExam"]>

  export type SchoolExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    score?: boolean
    date?: boolean
    subject?: boolean
    studentId?: boolean
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolExam"]>

  export type SchoolExamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    score?: boolean
    date?: boolean
    subject?: boolean
    studentId?: boolean
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["schoolExam"]>

  export type SchoolExamSelectScalar = {
    id?: boolean
    title?: boolean
    score?: boolean
    date?: boolean
    subject?: boolean
    studentId?: boolean
  }

  export type SchoolExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "score" | "date" | "subject" | "studentId", ExtArgs["result"]["schoolExam"]>
  export type SchoolExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type SchoolExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type SchoolExamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $SchoolExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SchoolExam"
    objects: {
      student: Prisma.$StudentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      score: number
      date: Date
      subject: string
      studentId: string
    }, ExtArgs["result"]["schoolExam"]>
    composites: {}
  }

  type SchoolExamGetPayload<S extends boolean | null | undefined | SchoolExamDefaultArgs> = $Result.GetResult<Prisma.$SchoolExamPayload, S>

  type SchoolExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<SchoolExamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: SchoolExamCountAggregateInputType | true
    }

  export interface SchoolExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SchoolExam'], meta: { name: 'SchoolExam' } }
    /**
     * Find zero or one SchoolExam that matches the filter.
     * @param {SchoolExamFindUniqueArgs} args - Arguments to find a SchoolExam
     * @example
     * // Get one SchoolExam
     * const schoolExam = await prisma.schoolExam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SchoolExamFindUniqueArgs>(args: SelectSubset<T, SchoolExamFindUniqueArgs<ExtArgs>>): Prisma__SchoolExamClient<$Result.GetResult<Prisma.$SchoolExamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one SchoolExam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {SchoolExamFindUniqueOrThrowArgs} args - Arguments to find a SchoolExam
     * @example
     * // Get one SchoolExam
     * const schoolExam = await prisma.schoolExam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SchoolExamFindUniqueOrThrowArgs>(args: SelectSubset<T, SchoolExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SchoolExamClient<$Result.GetResult<Prisma.$SchoolExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolExam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolExamFindFirstArgs} args - Arguments to find a SchoolExam
     * @example
     * // Get one SchoolExam
     * const schoolExam = await prisma.schoolExam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SchoolExamFindFirstArgs>(args?: SelectSubset<T, SchoolExamFindFirstArgs<ExtArgs>>): Prisma__SchoolExamClient<$Result.GetResult<Prisma.$SchoolExamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first SchoolExam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolExamFindFirstOrThrowArgs} args - Arguments to find a SchoolExam
     * @example
     * // Get one SchoolExam
     * const schoolExam = await prisma.schoolExam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SchoolExamFindFirstOrThrowArgs>(args?: SelectSubset<T, SchoolExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__SchoolExamClient<$Result.GetResult<Prisma.$SchoolExamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more SchoolExams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SchoolExams
     * const schoolExams = await prisma.schoolExam.findMany()
     * 
     * // Get first 10 SchoolExams
     * const schoolExams = await prisma.schoolExam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const schoolExamWithIdOnly = await prisma.schoolExam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SchoolExamFindManyArgs>(args?: SelectSubset<T, SchoolExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a SchoolExam.
     * @param {SchoolExamCreateArgs} args - Arguments to create a SchoolExam.
     * @example
     * // Create one SchoolExam
     * const SchoolExam = await prisma.schoolExam.create({
     *   data: {
     *     // ... data to create a SchoolExam
     *   }
     * })
     * 
     */
    create<T extends SchoolExamCreateArgs>(args: SelectSubset<T, SchoolExamCreateArgs<ExtArgs>>): Prisma__SchoolExamClient<$Result.GetResult<Prisma.$SchoolExamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many SchoolExams.
     * @param {SchoolExamCreateManyArgs} args - Arguments to create many SchoolExams.
     * @example
     * // Create many SchoolExams
     * const schoolExam = await prisma.schoolExam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SchoolExamCreateManyArgs>(args?: SelectSubset<T, SchoolExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many SchoolExams and returns the data saved in the database.
     * @param {SchoolExamCreateManyAndReturnArgs} args - Arguments to create many SchoolExams.
     * @example
     * // Create many SchoolExams
     * const schoolExam = await prisma.schoolExam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many SchoolExams and only return the `id`
     * const schoolExamWithIdOnly = await prisma.schoolExam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SchoolExamCreateManyAndReturnArgs>(args?: SelectSubset<T, SchoolExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolExamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a SchoolExam.
     * @param {SchoolExamDeleteArgs} args - Arguments to delete one SchoolExam.
     * @example
     * // Delete one SchoolExam
     * const SchoolExam = await prisma.schoolExam.delete({
     *   where: {
     *     // ... filter to delete one SchoolExam
     *   }
     * })
     * 
     */
    delete<T extends SchoolExamDeleteArgs>(args: SelectSubset<T, SchoolExamDeleteArgs<ExtArgs>>): Prisma__SchoolExamClient<$Result.GetResult<Prisma.$SchoolExamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one SchoolExam.
     * @param {SchoolExamUpdateArgs} args - Arguments to update one SchoolExam.
     * @example
     * // Update one SchoolExam
     * const schoolExam = await prisma.schoolExam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SchoolExamUpdateArgs>(args: SelectSubset<T, SchoolExamUpdateArgs<ExtArgs>>): Prisma__SchoolExamClient<$Result.GetResult<Prisma.$SchoolExamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more SchoolExams.
     * @param {SchoolExamDeleteManyArgs} args - Arguments to filter SchoolExams to delete.
     * @example
     * // Delete a few SchoolExams
     * const { count } = await prisma.schoolExam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SchoolExamDeleteManyArgs>(args?: SelectSubset<T, SchoolExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SchoolExams
     * const schoolExam = await prisma.schoolExam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SchoolExamUpdateManyArgs>(args: SelectSubset<T, SchoolExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SchoolExams and returns the data updated in the database.
     * @param {SchoolExamUpdateManyAndReturnArgs} args - Arguments to update many SchoolExams.
     * @example
     * // Update many SchoolExams
     * const schoolExam = await prisma.schoolExam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more SchoolExams and only return the `id`
     * const schoolExamWithIdOnly = await prisma.schoolExam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends SchoolExamUpdateManyAndReturnArgs>(args: SelectSubset<T, SchoolExamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SchoolExamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one SchoolExam.
     * @param {SchoolExamUpsertArgs} args - Arguments to update or create a SchoolExam.
     * @example
     * // Update or create a SchoolExam
     * const schoolExam = await prisma.schoolExam.upsert({
     *   create: {
     *     // ... data to create a SchoolExam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SchoolExam we want to update
     *   }
     * })
     */
    upsert<T extends SchoolExamUpsertArgs>(args: SelectSubset<T, SchoolExamUpsertArgs<ExtArgs>>): Prisma__SchoolExamClient<$Result.GetResult<Prisma.$SchoolExamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of SchoolExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolExamCountArgs} args - Arguments to filter SchoolExams to count.
     * @example
     * // Count the number of SchoolExams
     * const count = await prisma.schoolExam.count({
     *   where: {
     *     // ... the filter for the SchoolExams we want to count
     *   }
     * })
    **/
    count<T extends SchoolExamCountArgs>(
      args?: Subset<T, SchoolExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SchoolExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SchoolExam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SchoolExamAggregateArgs>(args: Subset<T, SchoolExamAggregateArgs>): Prisma.PrismaPromise<GetSchoolExamAggregateType<T>>

    /**
     * Group by SchoolExam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SchoolExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SchoolExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SchoolExamGroupByArgs['orderBy'] }
        : { orderBy?: SchoolExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SchoolExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSchoolExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SchoolExam model
   */
  readonly fields: SchoolExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SchoolExam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SchoolExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SchoolExam model
   */
  interface SchoolExamFieldRefs {
    readonly id: FieldRef<"SchoolExam", 'String'>
    readonly title: FieldRef<"SchoolExam", 'String'>
    readonly score: FieldRef<"SchoolExam", 'Float'>
    readonly date: FieldRef<"SchoolExam", 'DateTime'>
    readonly subject: FieldRef<"SchoolExam", 'String'>
    readonly studentId: FieldRef<"SchoolExam", 'String'>
  }
    

  // Custom InputTypes
  /**
   * SchoolExam findUnique
   */
  export type SchoolExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamInclude<ExtArgs> | null
    /**
     * Filter, which SchoolExam to fetch.
     */
    where: SchoolExamWhereUniqueInput
  }

  /**
   * SchoolExam findUniqueOrThrow
   */
  export type SchoolExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamInclude<ExtArgs> | null
    /**
     * Filter, which SchoolExam to fetch.
     */
    where: SchoolExamWhereUniqueInput
  }

  /**
   * SchoolExam findFirst
   */
  export type SchoolExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamInclude<ExtArgs> | null
    /**
     * Filter, which SchoolExam to fetch.
     */
    where?: SchoolExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolExams to fetch.
     */
    orderBy?: SchoolExamOrderByWithRelationInput | SchoolExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolExams.
     */
    cursor?: SchoolExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` SchoolExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolExams.
     */
    distinct?: SchoolExamScalarFieldEnum | SchoolExamScalarFieldEnum[]
  }

  /**
   * SchoolExam findFirstOrThrow
   */
  export type SchoolExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamInclude<ExtArgs> | null
    /**
     * Filter, which SchoolExam to fetch.
     */
    where?: SchoolExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolExams to fetch.
     */
    orderBy?: SchoolExamOrderByWithRelationInput | SchoolExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SchoolExams.
     */
    cursor?: SchoolExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` SchoolExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SchoolExams.
     */
    distinct?: SchoolExamScalarFieldEnum | SchoolExamScalarFieldEnum[]
  }

  /**
   * SchoolExam findMany
   */
  export type SchoolExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamInclude<ExtArgs> | null
    /**
     * Filter, which SchoolExams to fetch.
     */
    where?: SchoolExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SchoolExams to fetch.
     */
    orderBy?: SchoolExamOrderByWithRelationInput | SchoolExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SchoolExams.
     */
    cursor?: SchoolExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` SchoolExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SchoolExams.
     */
    skip?: number
    distinct?: SchoolExamScalarFieldEnum | SchoolExamScalarFieldEnum[]
  }

  /**
   * SchoolExam create
   */
  export type SchoolExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamInclude<ExtArgs> | null
    /**
     * The data needed to create a SchoolExam.
     */
    data: XOR<SchoolExamCreateInput, SchoolExamUncheckedCreateInput>
  }

  /**
   * SchoolExam createMany
   */
  export type SchoolExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SchoolExams.
     */
    data: SchoolExamCreateManyInput | SchoolExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SchoolExam createManyAndReturn
   */
  export type SchoolExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * The data used to create many SchoolExams.
     */
    data: SchoolExamCreateManyInput | SchoolExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolExam update
   */
  export type SchoolExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamInclude<ExtArgs> | null
    /**
     * The data needed to update a SchoolExam.
     */
    data: XOR<SchoolExamUpdateInput, SchoolExamUncheckedUpdateInput>
    /**
     * Choose, which SchoolExam to update.
     */
    where: SchoolExamWhereUniqueInput
  }

  /**
   * SchoolExam updateMany
   */
  export type SchoolExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SchoolExams.
     */
    data: XOR<SchoolExamUpdateManyMutationInput, SchoolExamUncheckedUpdateManyInput>
    /**
     * Filter which SchoolExams to update
     */
    where?: SchoolExamWhereInput
    /**
     * Limit how many SchoolExams to update.
     */
    limit?: number
  }

  /**
   * SchoolExam updateManyAndReturn
   */
  export type SchoolExamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * The data used to update SchoolExams.
     */
    data: XOR<SchoolExamUpdateManyMutationInput, SchoolExamUncheckedUpdateManyInput>
    /**
     * Filter which SchoolExams to update
     */
    where?: SchoolExamWhereInput
    /**
     * Limit how many SchoolExams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * SchoolExam upsert
   */
  export type SchoolExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamInclude<ExtArgs> | null
    /**
     * The filter to search for the SchoolExam to update in case it exists.
     */
    where: SchoolExamWhereUniqueInput
    /**
     * In case the SchoolExam found by the `where` argument doesn't exist, create a new SchoolExam with this data.
     */
    create: XOR<SchoolExamCreateInput, SchoolExamUncheckedCreateInput>
    /**
     * In case the SchoolExam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SchoolExamUpdateInput, SchoolExamUncheckedUpdateInput>
  }

  /**
   * SchoolExam delete
   */
  export type SchoolExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamInclude<ExtArgs> | null
    /**
     * Filter which SchoolExam to delete.
     */
    where: SchoolExamWhereUniqueInput
  }

  /**
   * SchoolExam deleteMany
   */
  export type SchoolExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SchoolExams to delete
     */
    where?: SchoolExamWhereInput
    /**
     * Limit how many SchoolExams to delete.
     */
    limit?: number
  }

  /**
   * SchoolExam without action
   */
  export type SchoolExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SchoolExam
     */
    select?: SchoolExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the SchoolExam
     */
    omit?: SchoolExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SchoolExamInclude<ExtArgs> | null
  }


  /**
   * Model TrialExam
   */

  export type AggregateTrialExam = {
    _count: TrialExamCountAggregateOutputType | null
    _avg: TrialExamAvgAggregateOutputType | null
    _sum: TrialExamSumAggregateOutputType | null
    _min: TrialExamMinAggregateOutputType | null
    _max: TrialExamMaxAggregateOutputType | null
  }

  export type TrialExamAvgAggregateOutputType = {
    totalNet: number | null
    totalScore: number | null
  }

  export type TrialExamSumAggregateOutputType = {
    totalNet: number | null
    totalScore: number | null
  }

  export type TrialExamMinAggregateOutputType = {
    id: string | null
    title: string | null
    date: Date | null
    category: $Enums.ExamCategory | null
    publisher: string | null
    studentId: string | null
    totalNet: number | null
    totalScore: number | null
  }

  export type TrialExamMaxAggregateOutputType = {
    id: string | null
    title: string | null
    date: Date | null
    category: $Enums.ExamCategory | null
    publisher: string | null
    studentId: string | null
    totalNet: number | null
    totalScore: number | null
  }

  export type TrialExamCountAggregateOutputType = {
    id: number
    title: number
    date: number
    category: number
    publisher: number
    studentId: number
    totalNet: number
    totalScore: number
    _all: number
  }


  export type TrialExamAvgAggregateInputType = {
    totalNet?: true
    totalScore?: true
  }

  export type TrialExamSumAggregateInputType = {
    totalNet?: true
    totalScore?: true
  }

  export type TrialExamMinAggregateInputType = {
    id?: true
    title?: true
    date?: true
    category?: true
    publisher?: true
    studentId?: true
    totalNet?: true
    totalScore?: true
  }

  export type TrialExamMaxAggregateInputType = {
    id?: true
    title?: true
    date?: true
    category?: true
    publisher?: true
    studentId?: true
    totalNet?: true
    totalScore?: true
  }

  export type TrialExamCountAggregateInputType = {
    id?: true
    title?: true
    date?: true
    category?: true
    publisher?: true
    studentId?: true
    totalNet?: true
    totalScore?: true
    _all?: true
  }

  export type TrialExamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrialExam to aggregate.
     */
    where?: TrialExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrialExams to fetch.
     */
    orderBy?: TrialExamOrderByWithRelationInput | TrialExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrialExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` TrialExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrialExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrialExams
    **/
    _count?: true | TrialExamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrialExamAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrialExamSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrialExamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrialExamMaxAggregateInputType
  }

  export type GetTrialExamAggregateType<T extends TrialExamAggregateArgs> = {
        [P in keyof T & keyof AggregateTrialExam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrialExam[P]>
      : GetScalarType<T[P], AggregateTrialExam[P]>
  }




  export type TrialExamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrialExamWhereInput
    orderBy?: TrialExamOrderByWithAggregationInput | TrialExamOrderByWithAggregationInput[]
    by: TrialExamScalarFieldEnum[] | TrialExamScalarFieldEnum
    having?: TrialExamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrialExamCountAggregateInputType | true
    _avg?: TrialExamAvgAggregateInputType
    _sum?: TrialExamSumAggregateInputType
    _min?: TrialExamMinAggregateInputType
    _max?: TrialExamMaxAggregateInputType
  }

  export type TrialExamGroupByOutputType = {
    id: string
    title: string
    date: Date
    category: $Enums.ExamCategory
    publisher: string | null
    studentId: string
    totalNet: number | null
    totalScore: number | null
    _count: TrialExamCountAggregateOutputType | null
    _avg: TrialExamAvgAggregateOutputType | null
    _sum: TrialExamSumAggregateOutputType | null
    _min: TrialExamMinAggregateOutputType | null
    _max: TrialExamMaxAggregateOutputType | null
  }

  type GetTrialExamGroupByPayload<T extends TrialExamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrialExamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrialExamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrialExamGroupByOutputType[P]>
            : GetScalarType<T[P], TrialExamGroupByOutputType[P]>
        }
      >
    >


  export type TrialExamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    category?: boolean
    publisher?: boolean
    studentId?: boolean
    totalNet?: boolean
    totalScore?: boolean
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
    results?: boolean | TrialExam$resultsArgs<ExtArgs>
    _count?: boolean | TrialExamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trialExam"]>

  export type TrialExamSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    category?: boolean
    publisher?: boolean
    studentId?: boolean
    totalNet?: boolean
    totalScore?: boolean
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trialExam"]>

  export type TrialExamSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    date?: boolean
    category?: boolean
    publisher?: boolean
    studentId?: boolean
    totalNet?: boolean
    totalScore?: boolean
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trialExam"]>

  export type TrialExamSelectScalar = {
    id?: boolean
    title?: boolean
    date?: boolean
    category?: boolean
    publisher?: boolean
    studentId?: boolean
    totalNet?: boolean
    totalScore?: boolean
  }

  export type TrialExamOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "date" | "category" | "publisher" | "studentId" | "totalNet" | "totalScore", ExtArgs["result"]["trialExam"]>
  export type TrialExamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
    results?: boolean | TrialExam$resultsArgs<ExtArgs>
    _count?: boolean | TrialExamCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TrialExamIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type TrialExamIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $TrialExamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrialExam"
    objects: {
      student: Prisma.$StudentProfilePayload<ExtArgs>
      results: Prisma.$TrialExamResultPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      date: Date
      category: $Enums.ExamCategory
      publisher: string | null
      studentId: string
      totalNet: number | null
      totalScore: number | null
    }, ExtArgs["result"]["trialExam"]>
    composites: {}
  }

  type TrialExamGetPayload<S extends boolean | null | undefined | TrialExamDefaultArgs> = $Result.GetResult<Prisma.$TrialExamPayload, S>

  type TrialExamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrialExamFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrialExamCountAggregateInputType | true
    }

  export interface TrialExamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrialExam'], meta: { name: 'TrialExam' } }
    /**
     * Find zero or one TrialExam that matches the filter.
     * @param {TrialExamFindUniqueArgs} args - Arguments to find a TrialExam
     * @example
     * // Get one TrialExam
     * const trialExam = await prisma.trialExam.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrialExamFindUniqueArgs>(args: SelectSubset<T, TrialExamFindUniqueArgs<ExtArgs>>): Prisma__TrialExamClient<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrialExam that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrialExamFindUniqueOrThrowArgs} args - Arguments to find a TrialExam
     * @example
     * // Get one TrialExam
     * const trialExam = await prisma.trialExam.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrialExamFindUniqueOrThrowArgs>(args: SelectSubset<T, TrialExamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrialExamClient<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrialExam that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamFindFirstArgs} args - Arguments to find a TrialExam
     * @example
     * // Get one TrialExam
     * const trialExam = await prisma.trialExam.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrialExamFindFirstArgs>(args?: SelectSubset<T, TrialExamFindFirstArgs<ExtArgs>>): Prisma__TrialExamClient<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrialExam that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamFindFirstOrThrowArgs} args - Arguments to find a TrialExam
     * @example
     * // Get one TrialExam
     * const trialExam = await prisma.trialExam.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrialExamFindFirstOrThrowArgs>(args?: SelectSubset<T, TrialExamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrialExamClient<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrialExams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrialExams
     * const trialExams = await prisma.trialExam.findMany()
     * 
     * // Get first 10 TrialExams
     * const trialExams = await prisma.trialExam.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trialExamWithIdOnly = await prisma.trialExam.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrialExamFindManyArgs>(args?: SelectSubset<T, TrialExamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrialExam.
     * @param {TrialExamCreateArgs} args - Arguments to create a TrialExam.
     * @example
     * // Create one TrialExam
     * const TrialExam = await prisma.trialExam.create({
     *   data: {
     *     // ... data to create a TrialExam
     *   }
     * })
     * 
     */
    create<T extends TrialExamCreateArgs>(args: SelectSubset<T, TrialExamCreateArgs<ExtArgs>>): Prisma__TrialExamClient<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrialExams.
     * @param {TrialExamCreateManyArgs} args - Arguments to create many TrialExams.
     * @example
     * // Create many TrialExams
     * const trialExam = await prisma.trialExam.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrialExamCreateManyArgs>(args?: SelectSubset<T, TrialExamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrialExams and returns the data saved in the database.
     * @param {TrialExamCreateManyAndReturnArgs} args - Arguments to create many TrialExams.
     * @example
     * // Create many TrialExams
     * const trialExam = await prisma.trialExam.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrialExams and only return the `id`
     * const trialExamWithIdOnly = await prisma.trialExam.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrialExamCreateManyAndReturnArgs>(args?: SelectSubset<T, TrialExamCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrialExam.
     * @param {TrialExamDeleteArgs} args - Arguments to delete one TrialExam.
     * @example
     * // Delete one TrialExam
     * const TrialExam = await prisma.trialExam.delete({
     *   where: {
     *     // ... filter to delete one TrialExam
     *   }
     * })
     * 
     */
    delete<T extends TrialExamDeleteArgs>(args: SelectSubset<T, TrialExamDeleteArgs<ExtArgs>>): Prisma__TrialExamClient<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrialExam.
     * @param {TrialExamUpdateArgs} args - Arguments to update one TrialExam.
     * @example
     * // Update one TrialExam
     * const trialExam = await prisma.trialExam.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrialExamUpdateArgs>(args: SelectSubset<T, TrialExamUpdateArgs<ExtArgs>>): Prisma__TrialExamClient<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrialExams.
     * @param {TrialExamDeleteManyArgs} args - Arguments to filter TrialExams to delete.
     * @example
     * // Delete a few TrialExams
     * const { count } = await prisma.trialExam.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrialExamDeleteManyArgs>(args?: SelectSubset<T, TrialExamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrialExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrialExams
     * const trialExam = await prisma.trialExam.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrialExamUpdateManyArgs>(args: SelectSubset<T, TrialExamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrialExams and returns the data updated in the database.
     * @param {TrialExamUpdateManyAndReturnArgs} args - Arguments to update many TrialExams.
     * @example
     * // Update many TrialExams
     * const trialExam = await prisma.trialExam.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrialExams and only return the `id`
     * const trialExamWithIdOnly = await prisma.trialExam.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrialExamUpdateManyAndReturnArgs>(args: SelectSubset<T, TrialExamUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrialExam.
     * @param {TrialExamUpsertArgs} args - Arguments to update or create a TrialExam.
     * @example
     * // Update or create a TrialExam
     * const trialExam = await prisma.trialExam.upsert({
     *   create: {
     *     // ... data to create a TrialExam
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrialExam we want to update
     *   }
     * })
     */
    upsert<T extends TrialExamUpsertArgs>(args: SelectSubset<T, TrialExamUpsertArgs<ExtArgs>>): Prisma__TrialExamClient<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrialExams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamCountArgs} args - Arguments to filter TrialExams to count.
     * @example
     * // Count the number of TrialExams
     * const count = await prisma.trialExam.count({
     *   where: {
     *     // ... the filter for the TrialExams we want to count
     *   }
     * })
    **/
    count<T extends TrialExamCountArgs>(
      args?: Subset<T, TrialExamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrialExamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrialExam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrialExamAggregateArgs>(args: Subset<T, TrialExamAggregateArgs>): Prisma.PrismaPromise<GetTrialExamAggregateType<T>>

    /**
     * Group by TrialExam.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrialExamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrialExamGroupByArgs['orderBy'] }
        : { orderBy?: TrialExamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrialExamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrialExamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrialExam model
   */
  readonly fields: TrialExamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrialExam.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrialExamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    results<T extends TrialExam$resultsArgs<ExtArgs> = {}>(args?: Subset<T, TrialExam$resultsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrialExamResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrialExam model
   */
  interface TrialExamFieldRefs {
    readonly id: FieldRef<"TrialExam", 'String'>
    readonly title: FieldRef<"TrialExam", 'String'>
    readonly date: FieldRef<"TrialExam", 'DateTime'>
    readonly category: FieldRef<"TrialExam", 'ExamCategory'>
    readonly publisher: FieldRef<"TrialExam", 'String'>
    readonly studentId: FieldRef<"TrialExam", 'String'>
    readonly totalNet: FieldRef<"TrialExam", 'Float'>
    readonly totalScore: FieldRef<"TrialExam", 'Float'>
  }
    

  // Custom InputTypes
  /**
   * TrialExam findUnique
   */
  export type TrialExamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamInclude<ExtArgs> | null
    /**
     * Filter, which TrialExam to fetch.
     */
    where: TrialExamWhereUniqueInput
  }

  /**
   * TrialExam findUniqueOrThrow
   */
  export type TrialExamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamInclude<ExtArgs> | null
    /**
     * Filter, which TrialExam to fetch.
     */
    where: TrialExamWhereUniqueInput
  }

  /**
   * TrialExam findFirst
   */
  export type TrialExamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamInclude<ExtArgs> | null
    /**
     * Filter, which TrialExam to fetch.
     */
    where?: TrialExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrialExams to fetch.
     */
    orderBy?: TrialExamOrderByWithRelationInput | TrialExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrialExams.
     */
    cursor?: TrialExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` TrialExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrialExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrialExams.
     */
    distinct?: TrialExamScalarFieldEnum | TrialExamScalarFieldEnum[]
  }

  /**
   * TrialExam findFirstOrThrow
   */
  export type TrialExamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamInclude<ExtArgs> | null
    /**
     * Filter, which TrialExam to fetch.
     */
    where?: TrialExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrialExams to fetch.
     */
    orderBy?: TrialExamOrderByWithRelationInput | TrialExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrialExams.
     */
    cursor?: TrialExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` TrialExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrialExams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrialExams.
     */
    distinct?: TrialExamScalarFieldEnum | TrialExamScalarFieldEnum[]
  }

  /**
   * TrialExam findMany
   */
  export type TrialExamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamInclude<ExtArgs> | null
    /**
     * Filter, which TrialExams to fetch.
     */
    where?: TrialExamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrialExams to fetch.
     */
    orderBy?: TrialExamOrderByWithRelationInput | TrialExamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrialExams.
     */
    cursor?: TrialExamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` TrialExams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrialExams.
     */
    skip?: number
    distinct?: TrialExamScalarFieldEnum | TrialExamScalarFieldEnum[]
  }

  /**
   * TrialExam create
   */
  export type TrialExamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamInclude<ExtArgs> | null
    /**
     * The data needed to create a TrialExam.
     */
    data: XOR<TrialExamCreateInput, TrialExamUncheckedCreateInput>
  }

  /**
   * TrialExam createMany
   */
  export type TrialExamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrialExams.
     */
    data: TrialExamCreateManyInput | TrialExamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrialExam createManyAndReturn
   */
  export type TrialExamCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * The data used to create many TrialExams.
     */
    data: TrialExamCreateManyInput | TrialExamCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrialExam update
   */
  export type TrialExamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamInclude<ExtArgs> | null
    /**
     * The data needed to update a TrialExam.
     */
    data: XOR<TrialExamUpdateInput, TrialExamUncheckedUpdateInput>
    /**
     * Choose, which TrialExam to update.
     */
    where: TrialExamWhereUniqueInput
  }

  /**
   * TrialExam updateMany
   */
  export type TrialExamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrialExams.
     */
    data: XOR<TrialExamUpdateManyMutationInput, TrialExamUncheckedUpdateManyInput>
    /**
     * Filter which TrialExams to update
     */
    where?: TrialExamWhereInput
    /**
     * Limit how many TrialExams to update.
     */
    limit?: number
  }

  /**
   * TrialExam updateManyAndReturn
   */
  export type TrialExamUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * The data used to update TrialExams.
     */
    data: XOR<TrialExamUpdateManyMutationInput, TrialExamUncheckedUpdateManyInput>
    /**
     * Filter which TrialExams to update
     */
    where?: TrialExamWhereInput
    /**
     * Limit how many TrialExams to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrialExam upsert
   */
  export type TrialExamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamInclude<ExtArgs> | null
    /**
     * The filter to search for the TrialExam to update in case it exists.
     */
    where: TrialExamWhereUniqueInput
    /**
     * In case the TrialExam found by the `where` argument doesn't exist, create a new TrialExam with this data.
     */
    create: XOR<TrialExamCreateInput, TrialExamUncheckedCreateInput>
    /**
     * In case the TrialExam was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrialExamUpdateInput, TrialExamUncheckedUpdateInput>
  }

  /**
   * TrialExam delete
   */
  export type TrialExamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamInclude<ExtArgs> | null
    /**
     * Filter which TrialExam to delete.
     */
    where: TrialExamWhereUniqueInput
  }

  /**
   * TrialExam deleteMany
   */
  export type TrialExamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrialExams to delete
     */
    where?: TrialExamWhereInput
    /**
     * Limit how many TrialExams to delete.
     */
    limit?: number
  }

  /**
   * TrialExam.results
   */
  export type TrialExam$resultsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultInclude<ExtArgs> | null
    where?: TrialExamResultWhereInput
    orderBy?: TrialExamResultOrderByWithRelationInput | TrialExamResultOrderByWithRelationInput[]
    cursor?: TrialExamResultWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TrialExamResultScalarFieldEnum | TrialExamResultScalarFieldEnum[]
  }

  /**
   * TrialExam without action
   */
  export type TrialExamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExam
     */
    select?: TrialExamSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExam
     */
    omit?: TrialExamOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamInclude<ExtArgs> | null
  }


  /**
   * Model TrialExamResult
   */

  export type AggregateTrialExamResult = {
    _count: TrialExamResultCountAggregateOutputType | null
    _avg: TrialExamResultAvgAggregateOutputType | null
    _sum: TrialExamResultSumAggregateOutputType | null
    _min: TrialExamResultMinAggregateOutputType | null
    _max: TrialExamResultMaxAggregateOutputType | null
  }

  export type TrialExamResultAvgAggregateOutputType = {
    correctCount: number | null
    incorrectCount: number | null
    emptyCount: number | null
    net: number | null
  }

  export type TrialExamResultSumAggregateOutputType = {
    correctCount: number | null
    incorrectCount: number | null
    emptyCount: number | null
    net: number | null
  }

  export type TrialExamResultMinAggregateOutputType = {
    id: string | null
    trialExamId: string | null
    lessonName: string | null
    correctCount: number | null
    incorrectCount: number | null
    emptyCount: number | null
    net: number | null
    mistakeAnalysis: string | null
  }

  export type TrialExamResultMaxAggregateOutputType = {
    id: string | null
    trialExamId: string | null
    lessonName: string | null
    correctCount: number | null
    incorrectCount: number | null
    emptyCount: number | null
    net: number | null
    mistakeAnalysis: string | null
  }

  export type TrialExamResultCountAggregateOutputType = {
    id: number
    trialExamId: number
    lessonName: number
    correctCount: number
    incorrectCount: number
    emptyCount: number
    net: number
    mistakeTopics: number
    mistakeAnalysis: number
    _all: number
  }


  export type TrialExamResultAvgAggregateInputType = {
    correctCount?: true
    incorrectCount?: true
    emptyCount?: true
    net?: true
  }

  export type TrialExamResultSumAggregateInputType = {
    correctCount?: true
    incorrectCount?: true
    emptyCount?: true
    net?: true
  }

  export type TrialExamResultMinAggregateInputType = {
    id?: true
    trialExamId?: true
    lessonName?: true
    correctCount?: true
    incorrectCount?: true
    emptyCount?: true
    net?: true
    mistakeAnalysis?: true
  }

  export type TrialExamResultMaxAggregateInputType = {
    id?: true
    trialExamId?: true
    lessonName?: true
    correctCount?: true
    incorrectCount?: true
    emptyCount?: true
    net?: true
    mistakeAnalysis?: true
  }

  export type TrialExamResultCountAggregateInputType = {
    id?: true
    trialExamId?: true
    lessonName?: true
    correctCount?: true
    incorrectCount?: true
    emptyCount?: true
    net?: true
    mistakeTopics?: true
    mistakeAnalysis?: true
    _all?: true
  }

  export type TrialExamResultAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrialExamResult to aggregate.
     */
    where?: TrialExamResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrialExamResults to fetch.
     */
    orderBy?: TrialExamResultOrderByWithRelationInput | TrialExamResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TrialExamResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` TrialExamResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrialExamResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TrialExamResults
    **/
    _count?: true | TrialExamResultCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TrialExamResultAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TrialExamResultSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TrialExamResultMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TrialExamResultMaxAggregateInputType
  }

  export type GetTrialExamResultAggregateType<T extends TrialExamResultAggregateArgs> = {
        [P in keyof T & keyof AggregateTrialExamResult]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTrialExamResult[P]>
      : GetScalarType<T[P], AggregateTrialExamResult[P]>
  }




  export type TrialExamResultGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TrialExamResultWhereInput
    orderBy?: TrialExamResultOrderByWithAggregationInput | TrialExamResultOrderByWithAggregationInput[]
    by: TrialExamResultScalarFieldEnum[] | TrialExamResultScalarFieldEnum
    having?: TrialExamResultScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TrialExamResultCountAggregateInputType | true
    _avg?: TrialExamResultAvgAggregateInputType
    _sum?: TrialExamResultSumAggregateInputType
    _min?: TrialExamResultMinAggregateInputType
    _max?: TrialExamResultMaxAggregateInputType
  }

  export type TrialExamResultGroupByOutputType = {
    id: string
    trialExamId: string
    lessonName: string
    correctCount: number
    incorrectCount: number
    emptyCount: number
    net: number
    mistakeTopics: string[]
    mistakeAnalysis: string | null
    _count: TrialExamResultCountAggregateOutputType | null
    _avg: TrialExamResultAvgAggregateOutputType | null
    _sum: TrialExamResultSumAggregateOutputType | null
    _min: TrialExamResultMinAggregateOutputType | null
    _max: TrialExamResultMaxAggregateOutputType | null
  }

  type GetTrialExamResultGroupByPayload<T extends TrialExamResultGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TrialExamResultGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TrialExamResultGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TrialExamResultGroupByOutputType[P]>
            : GetScalarType<T[P], TrialExamResultGroupByOutputType[P]>
        }
      >
    >


  export type TrialExamResultSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trialExamId?: boolean
    lessonName?: boolean
    correctCount?: boolean
    incorrectCount?: boolean
    emptyCount?: boolean
    net?: boolean
    mistakeTopics?: boolean
    mistakeAnalysis?: boolean
    trialExam?: boolean | TrialExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trialExamResult"]>

  export type TrialExamResultSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trialExamId?: boolean
    lessonName?: boolean
    correctCount?: boolean
    incorrectCount?: boolean
    emptyCount?: boolean
    net?: boolean
    mistakeTopics?: boolean
    mistakeAnalysis?: boolean
    trialExam?: boolean | TrialExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trialExamResult"]>

  export type TrialExamResultSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    trialExamId?: boolean
    lessonName?: boolean
    correctCount?: boolean
    incorrectCount?: boolean
    emptyCount?: boolean
    net?: boolean
    mistakeTopics?: boolean
    mistakeAnalysis?: boolean
    trialExam?: boolean | TrialExamDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["trialExamResult"]>

  export type TrialExamResultSelectScalar = {
    id?: boolean
    trialExamId?: boolean
    lessonName?: boolean
    correctCount?: boolean
    incorrectCount?: boolean
    emptyCount?: boolean
    net?: boolean
    mistakeTopics?: boolean
    mistakeAnalysis?: boolean
  }

  export type TrialExamResultOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "trialExamId" | "lessonName" | "correctCount" | "incorrectCount" | "emptyCount" | "net" | "mistakeTopics" | "mistakeAnalysis", ExtArgs["result"]["trialExamResult"]>
  export type TrialExamResultInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trialExam?: boolean | TrialExamDefaultArgs<ExtArgs>
  }
  export type TrialExamResultIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trialExam?: boolean | TrialExamDefaultArgs<ExtArgs>
  }
  export type TrialExamResultIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    trialExam?: boolean | TrialExamDefaultArgs<ExtArgs>
  }

  export type $TrialExamResultPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TrialExamResult"
    objects: {
      trialExam: Prisma.$TrialExamPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      trialExamId: string
      lessonName: string
      correctCount: number
      incorrectCount: number
      emptyCount: number
      net: number
      mistakeTopics: string[]
      mistakeAnalysis: string | null
    }, ExtArgs["result"]["trialExamResult"]>
    composites: {}
  }

  type TrialExamResultGetPayload<S extends boolean | null | undefined | TrialExamResultDefaultArgs> = $Result.GetResult<Prisma.$TrialExamResultPayload, S>

  type TrialExamResultCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TrialExamResultFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TrialExamResultCountAggregateInputType | true
    }

  export interface TrialExamResultDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TrialExamResult'], meta: { name: 'TrialExamResult' } }
    /**
     * Find zero or one TrialExamResult that matches the filter.
     * @param {TrialExamResultFindUniqueArgs} args - Arguments to find a TrialExamResult
     * @example
     * // Get one TrialExamResult
     * const trialExamResult = await prisma.trialExamResult.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TrialExamResultFindUniqueArgs>(args: SelectSubset<T, TrialExamResultFindUniqueArgs<ExtArgs>>): Prisma__TrialExamResultClient<$Result.GetResult<Prisma.$TrialExamResultPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one TrialExamResult that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TrialExamResultFindUniqueOrThrowArgs} args - Arguments to find a TrialExamResult
     * @example
     * // Get one TrialExamResult
     * const trialExamResult = await prisma.trialExamResult.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TrialExamResultFindUniqueOrThrowArgs>(args: SelectSubset<T, TrialExamResultFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TrialExamResultClient<$Result.GetResult<Prisma.$TrialExamResultPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrialExamResult that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamResultFindFirstArgs} args - Arguments to find a TrialExamResult
     * @example
     * // Get one TrialExamResult
     * const trialExamResult = await prisma.trialExamResult.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TrialExamResultFindFirstArgs>(args?: SelectSubset<T, TrialExamResultFindFirstArgs<ExtArgs>>): Prisma__TrialExamResultClient<$Result.GetResult<Prisma.$TrialExamResultPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first TrialExamResult that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamResultFindFirstOrThrowArgs} args - Arguments to find a TrialExamResult
     * @example
     * // Get one TrialExamResult
     * const trialExamResult = await prisma.trialExamResult.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TrialExamResultFindFirstOrThrowArgs>(args?: SelectSubset<T, TrialExamResultFindFirstOrThrowArgs<ExtArgs>>): Prisma__TrialExamResultClient<$Result.GetResult<Prisma.$TrialExamResultPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more TrialExamResults that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamResultFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TrialExamResults
     * const trialExamResults = await prisma.trialExamResult.findMany()
     * 
     * // Get first 10 TrialExamResults
     * const trialExamResults = await prisma.trialExamResult.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const trialExamResultWithIdOnly = await prisma.trialExamResult.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TrialExamResultFindManyArgs>(args?: SelectSubset<T, TrialExamResultFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrialExamResultPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a TrialExamResult.
     * @param {TrialExamResultCreateArgs} args - Arguments to create a TrialExamResult.
     * @example
     * // Create one TrialExamResult
     * const TrialExamResult = await prisma.trialExamResult.create({
     *   data: {
     *     // ... data to create a TrialExamResult
     *   }
     * })
     * 
     */
    create<T extends TrialExamResultCreateArgs>(args: SelectSubset<T, TrialExamResultCreateArgs<ExtArgs>>): Prisma__TrialExamResultClient<$Result.GetResult<Prisma.$TrialExamResultPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many TrialExamResults.
     * @param {TrialExamResultCreateManyArgs} args - Arguments to create many TrialExamResults.
     * @example
     * // Create many TrialExamResults
     * const trialExamResult = await prisma.trialExamResult.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TrialExamResultCreateManyArgs>(args?: SelectSubset<T, TrialExamResultCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TrialExamResults and returns the data saved in the database.
     * @param {TrialExamResultCreateManyAndReturnArgs} args - Arguments to create many TrialExamResults.
     * @example
     * // Create many TrialExamResults
     * const trialExamResult = await prisma.trialExamResult.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TrialExamResults and only return the `id`
     * const trialExamResultWithIdOnly = await prisma.trialExamResult.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TrialExamResultCreateManyAndReturnArgs>(args?: SelectSubset<T, TrialExamResultCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrialExamResultPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a TrialExamResult.
     * @param {TrialExamResultDeleteArgs} args - Arguments to delete one TrialExamResult.
     * @example
     * // Delete one TrialExamResult
     * const TrialExamResult = await prisma.trialExamResult.delete({
     *   where: {
     *     // ... filter to delete one TrialExamResult
     *   }
     * })
     * 
     */
    delete<T extends TrialExamResultDeleteArgs>(args: SelectSubset<T, TrialExamResultDeleteArgs<ExtArgs>>): Prisma__TrialExamResultClient<$Result.GetResult<Prisma.$TrialExamResultPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one TrialExamResult.
     * @param {TrialExamResultUpdateArgs} args - Arguments to update one TrialExamResult.
     * @example
     * // Update one TrialExamResult
     * const trialExamResult = await prisma.trialExamResult.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TrialExamResultUpdateArgs>(args: SelectSubset<T, TrialExamResultUpdateArgs<ExtArgs>>): Prisma__TrialExamResultClient<$Result.GetResult<Prisma.$TrialExamResultPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more TrialExamResults.
     * @param {TrialExamResultDeleteManyArgs} args - Arguments to filter TrialExamResults to delete.
     * @example
     * // Delete a few TrialExamResults
     * const { count } = await prisma.trialExamResult.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TrialExamResultDeleteManyArgs>(args?: SelectSubset<T, TrialExamResultDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrialExamResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamResultUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TrialExamResults
     * const trialExamResult = await prisma.trialExamResult.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TrialExamResultUpdateManyArgs>(args: SelectSubset<T, TrialExamResultUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TrialExamResults and returns the data updated in the database.
     * @param {TrialExamResultUpdateManyAndReturnArgs} args - Arguments to update many TrialExamResults.
     * @example
     * // Update many TrialExamResults
     * const trialExamResult = await prisma.trialExamResult.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more TrialExamResults and only return the `id`
     * const trialExamResultWithIdOnly = await prisma.trialExamResult.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TrialExamResultUpdateManyAndReturnArgs>(args: SelectSubset<T, TrialExamResultUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TrialExamResultPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one TrialExamResult.
     * @param {TrialExamResultUpsertArgs} args - Arguments to update or create a TrialExamResult.
     * @example
     * // Update or create a TrialExamResult
     * const trialExamResult = await prisma.trialExamResult.upsert({
     *   create: {
     *     // ... data to create a TrialExamResult
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TrialExamResult we want to update
     *   }
     * })
     */
    upsert<T extends TrialExamResultUpsertArgs>(args: SelectSubset<T, TrialExamResultUpsertArgs<ExtArgs>>): Prisma__TrialExamResultClient<$Result.GetResult<Prisma.$TrialExamResultPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of TrialExamResults.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamResultCountArgs} args - Arguments to filter TrialExamResults to count.
     * @example
     * // Count the number of TrialExamResults
     * const count = await prisma.trialExamResult.count({
     *   where: {
     *     // ... the filter for the TrialExamResults we want to count
     *   }
     * })
    **/
    count<T extends TrialExamResultCountArgs>(
      args?: Subset<T, TrialExamResultCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TrialExamResultCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TrialExamResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamResultAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TrialExamResultAggregateArgs>(args: Subset<T, TrialExamResultAggregateArgs>): Prisma.PrismaPromise<GetTrialExamResultAggregateType<T>>

    /**
     * Group by TrialExamResult.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TrialExamResultGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TrialExamResultGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TrialExamResultGroupByArgs['orderBy'] }
        : { orderBy?: TrialExamResultGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TrialExamResultGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTrialExamResultGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TrialExamResult model
   */
  readonly fields: TrialExamResultFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TrialExamResult.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TrialExamResultClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    trialExam<T extends TrialExamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TrialExamDefaultArgs<ExtArgs>>): Prisma__TrialExamClient<$Result.GetResult<Prisma.$TrialExamPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TrialExamResult model
   */
  interface TrialExamResultFieldRefs {
    readonly id: FieldRef<"TrialExamResult", 'String'>
    readonly trialExamId: FieldRef<"TrialExamResult", 'String'>
    readonly lessonName: FieldRef<"TrialExamResult", 'String'>
    readonly correctCount: FieldRef<"TrialExamResult", 'Int'>
    readonly incorrectCount: FieldRef<"TrialExamResult", 'Int'>
    readonly emptyCount: FieldRef<"TrialExamResult", 'Int'>
    readonly net: FieldRef<"TrialExamResult", 'Float'>
    readonly mistakeTopics: FieldRef<"TrialExamResult", 'String[]'>
    readonly mistakeAnalysis: FieldRef<"TrialExamResult", 'String'>
  }
    

  // Custom InputTypes
  /**
   * TrialExamResult findUnique
   */
  export type TrialExamResultFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultInclude<ExtArgs> | null
    /**
     * Filter, which TrialExamResult to fetch.
     */
    where: TrialExamResultWhereUniqueInput
  }

  /**
   * TrialExamResult findUniqueOrThrow
   */
  export type TrialExamResultFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultInclude<ExtArgs> | null
    /**
     * Filter, which TrialExamResult to fetch.
     */
    where: TrialExamResultWhereUniqueInput
  }

  /**
   * TrialExamResult findFirst
   */
  export type TrialExamResultFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultInclude<ExtArgs> | null
    /**
     * Filter, which TrialExamResult to fetch.
     */
    where?: TrialExamResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrialExamResults to fetch.
     */
    orderBy?: TrialExamResultOrderByWithRelationInput | TrialExamResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrialExamResults.
     */
    cursor?: TrialExamResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` TrialExamResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrialExamResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrialExamResults.
     */
    distinct?: TrialExamResultScalarFieldEnum | TrialExamResultScalarFieldEnum[]
  }

  /**
   * TrialExamResult findFirstOrThrow
   */
  export type TrialExamResultFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultInclude<ExtArgs> | null
    /**
     * Filter, which TrialExamResult to fetch.
     */
    where?: TrialExamResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrialExamResults to fetch.
     */
    orderBy?: TrialExamResultOrderByWithRelationInput | TrialExamResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TrialExamResults.
     */
    cursor?: TrialExamResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` TrialExamResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrialExamResults.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TrialExamResults.
     */
    distinct?: TrialExamResultScalarFieldEnum | TrialExamResultScalarFieldEnum[]
  }

  /**
   * TrialExamResult findMany
   */
  export type TrialExamResultFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultInclude<ExtArgs> | null
    /**
     * Filter, which TrialExamResults to fetch.
     */
    where?: TrialExamResultWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TrialExamResults to fetch.
     */
    orderBy?: TrialExamResultOrderByWithRelationInput | TrialExamResultOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TrialExamResults.
     */
    cursor?: TrialExamResultWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` TrialExamResults from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TrialExamResults.
     */
    skip?: number
    distinct?: TrialExamResultScalarFieldEnum | TrialExamResultScalarFieldEnum[]
  }

  /**
   * TrialExamResult create
   */
  export type TrialExamResultCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultInclude<ExtArgs> | null
    /**
     * The data needed to create a TrialExamResult.
     */
    data: XOR<TrialExamResultCreateInput, TrialExamResultUncheckedCreateInput>
  }

  /**
   * TrialExamResult createMany
   */
  export type TrialExamResultCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TrialExamResults.
     */
    data: TrialExamResultCreateManyInput | TrialExamResultCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TrialExamResult createManyAndReturn
   */
  export type TrialExamResultCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * The data used to create many TrialExamResults.
     */
    data: TrialExamResultCreateManyInput | TrialExamResultCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrialExamResult update
   */
  export type TrialExamResultUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultInclude<ExtArgs> | null
    /**
     * The data needed to update a TrialExamResult.
     */
    data: XOR<TrialExamResultUpdateInput, TrialExamResultUncheckedUpdateInput>
    /**
     * Choose, which TrialExamResult to update.
     */
    where: TrialExamResultWhereUniqueInput
  }

  /**
   * TrialExamResult updateMany
   */
  export type TrialExamResultUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TrialExamResults.
     */
    data: XOR<TrialExamResultUpdateManyMutationInput, TrialExamResultUncheckedUpdateManyInput>
    /**
     * Filter which TrialExamResults to update
     */
    where?: TrialExamResultWhereInput
    /**
     * Limit how many TrialExamResults to update.
     */
    limit?: number
  }

  /**
   * TrialExamResult updateManyAndReturn
   */
  export type TrialExamResultUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * The data used to update TrialExamResults.
     */
    data: XOR<TrialExamResultUpdateManyMutationInput, TrialExamResultUncheckedUpdateManyInput>
    /**
     * Filter which TrialExamResults to update
     */
    where?: TrialExamResultWhereInput
    /**
     * Limit how many TrialExamResults to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * TrialExamResult upsert
   */
  export type TrialExamResultUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultInclude<ExtArgs> | null
    /**
     * The filter to search for the TrialExamResult to update in case it exists.
     */
    where: TrialExamResultWhereUniqueInput
    /**
     * In case the TrialExamResult found by the `where` argument doesn't exist, create a new TrialExamResult with this data.
     */
    create: XOR<TrialExamResultCreateInput, TrialExamResultUncheckedCreateInput>
    /**
     * In case the TrialExamResult was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TrialExamResultUpdateInput, TrialExamResultUncheckedUpdateInput>
  }

  /**
   * TrialExamResult delete
   */
  export type TrialExamResultDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultInclude<ExtArgs> | null
    /**
     * Filter which TrialExamResult to delete.
     */
    where: TrialExamResultWhereUniqueInput
  }

  /**
   * TrialExamResult deleteMany
   */
  export type TrialExamResultDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TrialExamResults to delete
     */
    where?: TrialExamResultWhereInput
    /**
     * Limit how many TrialExamResults to delete.
     */
    limit?: number
  }

  /**
   * TrialExamResult without action
   */
  export type TrialExamResultDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TrialExamResult
     */
    select?: TrialExamResultSelect<ExtArgs> | null
    /**
     * Omit specific fields from the TrialExamResult
     */
    omit?: TrialExamResultOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TrialExamResultInclude<ExtArgs> | null
  }


  /**
   * Model Attendance
   */

  export type AggregateAttendance = {
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  export type AttendanceMinAggregateOutputType = {
    id: string | null
    lessonId: string | null
    studentId: string | null
    status: $Enums.AttendanceStatus | null
    note: string | null
  }

  export type AttendanceMaxAggregateOutputType = {
    id: string | null
    lessonId: string | null
    studentId: string | null
    status: $Enums.AttendanceStatus | null
    note: string | null
  }

  export type AttendanceCountAggregateOutputType = {
    id: number
    lessonId: number
    studentId: number
    status: number
    note: number
    _all: number
  }


  export type AttendanceMinAggregateInputType = {
    id?: true
    lessonId?: true
    studentId?: true
    status?: true
    note?: true
  }

  export type AttendanceMaxAggregateInputType = {
    id?: true
    lessonId?: true
    studentId?: true
    status?: true
    note?: true
  }

  export type AttendanceCountAggregateInputType = {
    id?: true
    lessonId?: true
    studentId?: true
    status?: true
    note?: true
    _all?: true
  }

  export type AttendanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendance to aggregate.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Attendances
    **/
    _count?: true | AttendanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceMaxAggregateInputType
  }

  export type GetAttendanceAggregateType<T extends AttendanceAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendance[P]>
      : GetScalarType<T[P], AggregateAttendance[P]>
  }




  export type AttendanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceWhereInput
    orderBy?: AttendanceOrderByWithAggregationInput | AttendanceOrderByWithAggregationInput[]
    by: AttendanceScalarFieldEnum[] | AttendanceScalarFieldEnum
    having?: AttendanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceCountAggregateInputType | true
    _min?: AttendanceMinAggregateInputType
    _max?: AttendanceMaxAggregateInputType
  }

  export type AttendanceGroupByOutputType = {
    id: string
    lessonId: string
    studentId: string
    status: $Enums.AttendanceStatus
    note: string | null
    _count: AttendanceCountAggregateOutputType | null
    _min: AttendanceMinAggregateOutputType | null
    _max: AttendanceMaxAggregateOutputType | null
  }

  type GetAttendanceGroupByPayload<T extends AttendanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    studentId?: boolean
    status?: boolean
    note?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    studentId?: boolean
    status?: boolean
    note?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    lessonId?: boolean
    studentId?: boolean
    status?: boolean
    note?: boolean
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["attendance"]>

  export type AttendanceSelectScalar = {
    id?: boolean
    lessonId?: boolean
    studentId?: boolean
    status?: boolean
    note?: boolean
  }

  export type AttendanceOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "lessonId" | "studentId" | "status" | "note", ExtArgs["result"]["attendance"]>
  export type AttendanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }
  export type AttendanceIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    lesson?: boolean | LessonDefaultArgs<ExtArgs>
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
  }

  export type $AttendancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Attendance"
    objects: {
      lesson: Prisma.$LessonPayload<ExtArgs>
      student: Prisma.$StudentProfilePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      lessonId: string
      studentId: string
      status: $Enums.AttendanceStatus
      note: string | null
    }, ExtArgs["result"]["attendance"]>
    composites: {}
  }

  type AttendanceGetPayload<S extends boolean | null | undefined | AttendanceDefaultArgs> = $Result.GetResult<Prisma.$AttendancePayload, S>

  type AttendanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<AttendanceFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: AttendanceCountAggregateInputType | true
    }

  export interface AttendanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Attendance'], meta: { name: 'Attendance' } }
    /**
     * Find zero or one Attendance that matches the filter.
     * @param {AttendanceFindUniqueArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceFindUniqueArgs>(args: SelectSubset<T, AttendanceFindUniqueArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Attendance that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {AttendanceFindUniqueOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceFindFirstArgs>(args?: SelectSubset<T, AttendanceFindFirstArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Attendance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindFirstOrThrowArgs} args - Arguments to find a Attendance
     * @example
     * // Get one Attendance
     * const attendance = await prisma.attendance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Attendances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Attendances
     * const attendances = await prisma.attendance.findMany()
     * 
     * // Get first 10 Attendances
     * const attendances = await prisma.attendance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceWithIdOnly = await prisma.attendance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceFindManyArgs>(args?: SelectSubset<T, AttendanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Attendance.
     * @param {AttendanceCreateArgs} args - Arguments to create a Attendance.
     * @example
     * // Create one Attendance
     * const Attendance = await prisma.attendance.create({
     *   data: {
     *     // ... data to create a Attendance
     *   }
     * })
     * 
     */
    create<T extends AttendanceCreateArgs>(args: SelectSubset<T, AttendanceCreateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Attendances.
     * @param {AttendanceCreateManyArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceCreateManyArgs>(args?: SelectSubset<T, AttendanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Attendances and returns the data saved in the database.
     * @param {AttendanceCreateManyAndReturnArgs} args - Arguments to create many Attendances.
     * @example
     * // Create many Attendances
     * const attendance = await prisma.attendance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Attendance.
     * @param {AttendanceDeleteArgs} args - Arguments to delete one Attendance.
     * @example
     * // Delete one Attendance
     * const Attendance = await prisma.attendance.delete({
     *   where: {
     *     // ... filter to delete one Attendance
     *   }
     * })
     * 
     */
    delete<T extends AttendanceDeleteArgs>(args: SelectSubset<T, AttendanceDeleteArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Attendance.
     * @param {AttendanceUpdateArgs} args - Arguments to update one Attendance.
     * @example
     * // Update one Attendance
     * const attendance = await prisma.attendance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceUpdateArgs>(args: SelectSubset<T, AttendanceUpdateArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Attendances.
     * @param {AttendanceDeleteManyArgs} args - Arguments to filter Attendances to delete.
     * @example
     * // Delete a few Attendances
     * const { count } = await prisma.attendance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceDeleteManyArgs>(args?: SelectSubset<T, AttendanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceUpdateManyArgs>(args: SelectSubset<T, AttendanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Attendances and returns the data updated in the database.
     * @param {AttendanceUpdateManyAndReturnArgs} args - Arguments to update many Attendances.
     * @example
     * // Update many Attendances
     * const attendance = await prisma.attendance.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Attendances and only return the `id`
     * const attendanceWithIdOnly = await prisma.attendance.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends AttendanceUpdateManyAndReturnArgs>(args: SelectSubset<T, AttendanceUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Attendance.
     * @param {AttendanceUpsertArgs} args - Arguments to update or create a Attendance.
     * @example
     * // Update or create a Attendance
     * const attendance = await prisma.attendance.upsert({
     *   create: {
     *     // ... data to create a Attendance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Attendance we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceUpsertArgs>(args: SelectSubset<T, AttendanceUpsertArgs<ExtArgs>>): Prisma__AttendanceClient<$Result.GetResult<Prisma.$AttendancePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Attendances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceCountArgs} args - Arguments to filter Attendances to count.
     * @example
     * // Count the number of Attendances
     * const count = await prisma.attendance.count({
     *   where: {
     *     // ... the filter for the Attendances we want to count
     *   }
     * })
    **/
    count<T extends AttendanceCountArgs>(
      args?: Subset<T, AttendanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceAggregateArgs>(args: Subset<T, AttendanceAggregateArgs>): Prisma.PrismaPromise<GetAttendanceAggregateType<T>>

    /**
     * Group by Attendance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Attendance model
   */
  readonly fields: AttendanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Attendance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    lesson<T extends LessonDefaultArgs<ExtArgs> = {}>(args?: Subset<T, LessonDefaultArgs<ExtArgs>>): Prisma__LessonClient<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    student<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Attendance model
   */
  interface AttendanceFieldRefs {
    readonly id: FieldRef<"Attendance", 'String'>
    readonly lessonId: FieldRef<"Attendance", 'String'>
    readonly studentId: FieldRef<"Attendance", 'String'>
    readonly status: FieldRef<"Attendance", 'AttendanceStatus'>
    readonly note: FieldRef<"Attendance", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Attendance findUnique
   */
  export type AttendanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findUniqueOrThrow
   */
  export type AttendanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance findFirst
   */
  export type AttendanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findFirstOrThrow
   */
  export type AttendanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendance to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Attendances.
     */
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance findMany
   */
  export type AttendanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter, which Attendances to fetch.
     */
    where?: AttendanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Attendances to fetch.
     */
    orderBy?: AttendanceOrderByWithRelationInput | AttendanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Attendances.
     */
    cursor?: AttendanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Attendances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Attendances.
     */
    skip?: number
    distinct?: AttendanceScalarFieldEnum | AttendanceScalarFieldEnum[]
  }

  /**
   * Attendance create
   */
  export type AttendanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to create a Attendance.
     */
    data: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
  }

  /**
   * Attendance createMany
   */
  export type AttendanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Attendance createManyAndReturn
   */
  export type AttendanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to create many Attendances.
     */
    data: AttendanceCreateManyInput | AttendanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance update
   */
  export type AttendanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The data needed to update a Attendance.
     */
    data: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
    /**
     * Choose, which Attendance to update.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance updateMany
   */
  export type AttendanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
  }

  /**
   * Attendance updateManyAndReturn
   */
  export type AttendanceUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * The data used to update Attendances.
     */
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyInput>
    /**
     * Filter which Attendances to update
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Attendance upsert
   */
  export type AttendanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * The filter to search for the Attendance to update in case it exists.
     */
    where: AttendanceWhereUniqueInput
    /**
     * In case the Attendance found by the `where` argument doesn't exist, create a new Attendance with this data.
     */
    create: XOR<AttendanceCreateInput, AttendanceUncheckedCreateInput>
    /**
     * In case the Attendance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceUpdateInput, AttendanceUncheckedUpdateInput>
  }

  /**
   * Attendance delete
   */
  export type AttendanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
    /**
     * Filter which Attendance to delete.
     */
    where: AttendanceWhereUniqueInput
  }

  /**
   * Attendance deleteMany
   */
  export type AttendanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Attendances to delete
     */
    where?: AttendanceWhereInput
    /**
     * Limit how many Attendances to delete.
     */
    limit?: number
  }

  /**
   * Attendance without action
   */
  export type AttendanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Attendance
     */
    select?: AttendanceSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Attendance
     */
    omit?: AttendanceOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceInclude<ExtArgs> | null
  }


  /**
   * Model Payment
   */

  export type AggregatePayment = {
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  export type PaymentAvgAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentSumAggregateOutputType = {
    amount: Decimal | null
  }

  export type PaymentMinAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    date: Date | null
    type: $Enums.PaymentType | null
    note: string | null
    isVisibleToStudent: boolean | null
    studentId: string | null
    teacherId: string | null
  }

  export type PaymentMaxAggregateOutputType = {
    id: string | null
    amount: Decimal | null
    date: Date | null
    type: $Enums.PaymentType | null
    note: string | null
    isVisibleToStudent: boolean | null
    studentId: string | null
    teacherId: string | null
  }

  export type PaymentCountAggregateOutputType = {
    id: number
    amount: number
    date: number
    type: number
    note: number
    isVisibleToStudent: number
    studentId: number
    teacherId: number
    _all: number
  }


  export type PaymentAvgAggregateInputType = {
    amount?: true
  }

  export type PaymentSumAggregateInputType = {
    amount?: true
  }

  export type PaymentMinAggregateInputType = {
    id?: true
    amount?: true
    date?: true
    type?: true
    note?: true
    isVisibleToStudent?: true
    studentId?: true
    teacherId?: true
  }

  export type PaymentMaxAggregateInputType = {
    id?: true
    amount?: true
    date?: true
    type?: true
    note?: true
    isVisibleToStudent?: true
    studentId?: true
    teacherId?: true
  }

  export type PaymentCountAggregateInputType = {
    id?: true
    amount?: true
    date?: true
    type?: true
    note?: true
    isVisibleToStudent?: true
    studentId?: true
    teacherId?: true
    _all?: true
  }

  export type PaymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payment to aggregate.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Payments
    **/
    _count?: true | PaymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PaymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PaymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PaymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PaymentMaxAggregateInputType
  }

  export type GetPaymentAggregateType<T extends PaymentAggregateArgs> = {
        [P in keyof T & keyof AggregatePayment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayment[P]>
      : GetScalarType<T[P], AggregatePayment[P]>
  }




  export type PaymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PaymentWhereInput
    orderBy?: PaymentOrderByWithAggregationInput | PaymentOrderByWithAggregationInput[]
    by: PaymentScalarFieldEnum[] | PaymentScalarFieldEnum
    having?: PaymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PaymentCountAggregateInputType | true
    _avg?: PaymentAvgAggregateInputType
    _sum?: PaymentSumAggregateInputType
    _min?: PaymentMinAggregateInputType
    _max?: PaymentMaxAggregateInputType
  }

  export type PaymentGroupByOutputType = {
    id: string
    amount: Decimal
    date: Date
    type: $Enums.PaymentType
    note: string | null
    isVisibleToStudent: boolean
    studentId: string
    teacherId: string
    _count: PaymentCountAggregateOutputType | null
    _avg: PaymentAvgAggregateOutputType | null
    _sum: PaymentSumAggregateOutputType | null
    _min: PaymentMinAggregateOutputType | null
    _max: PaymentMaxAggregateOutputType | null
  }

  type GetPaymentGroupByPayload<T extends PaymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PaymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PaymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PaymentGroupByOutputType[P]>
            : GetScalarType<T[P], PaymentGroupByOutputType[P]>
        }
      >
    >


  export type PaymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    date?: boolean
    type?: boolean
    note?: boolean
    isVisibleToStudent?: boolean
    studentId?: boolean
    teacherId?: boolean
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    lessons?: boolean | Payment$lessonsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    date?: boolean
    type?: boolean
    note?: boolean
    isVisibleToStudent?: boolean
    studentId?: boolean
    teacherId?: boolean
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    amount?: boolean
    date?: boolean
    type?: boolean
    note?: boolean
    isVisibleToStudent?: boolean
    studentId?: boolean
    teacherId?: boolean
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["payment"]>

  export type PaymentSelectScalar = {
    id?: boolean
    amount?: boolean
    date?: boolean
    type?: boolean
    note?: boolean
    isVisibleToStudent?: boolean
    studentId?: boolean
    teacherId?: boolean
  }

  export type PaymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "amount" | "date" | "type" | "note" | "isVisibleToStudent" | "studentId" | "teacherId", ExtArgs["result"]["payment"]>
  export type PaymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
    lessons?: boolean | Payment$lessonsArgs<ExtArgs>
    _count?: boolean | PaymentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
  }
  export type PaymentIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    student?: boolean | StudentProfileDefaultArgs<ExtArgs>
    teacher?: boolean | TeacherProfileDefaultArgs<ExtArgs>
  }

  export type $PaymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Payment"
    objects: {
      student: Prisma.$StudentProfilePayload<ExtArgs>
      teacher: Prisma.$TeacherProfilePayload<ExtArgs>
      lessons: Prisma.$LessonPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      amount: Prisma.Decimal
      date: Date
      type: $Enums.PaymentType
      note: string | null
      isVisibleToStudent: boolean
      studentId: string
      teacherId: string
    }, ExtArgs["result"]["payment"]>
    composites: {}
  }

  type PaymentGetPayload<S extends boolean | null | undefined | PaymentDefaultArgs> = $Result.GetResult<Prisma.$PaymentPayload, S>

  type PaymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<PaymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: PaymentCountAggregateInputType | true
    }

  export interface PaymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Payment'], meta: { name: 'Payment' } }
    /**
     * Find zero or one Payment that matches the filter.
     * @param {PaymentFindUniqueArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PaymentFindUniqueArgs>(args: SelectSubset<T, PaymentFindUniqueArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {PaymentFindUniqueOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PaymentFindUniqueOrThrowArgs>(args: SelectSubset<T, PaymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PaymentFindFirstArgs>(args?: SelectSubset<T, PaymentFindFirstArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindFirstOrThrowArgs} args - Arguments to find a Payment
     * @example
     * // Get one Payment
     * const payment = await prisma.payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PaymentFindFirstOrThrowArgs>(args?: SelectSubset<T, PaymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Payments
     * const payments = await prisma.payment.findMany()
     * 
     * // Get first 10 Payments
     * const payments = await prisma.payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const paymentWithIdOnly = await prisma.payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PaymentFindManyArgs>(args?: SelectSubset<T, PaymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Payment.
     * @param {PaymentCreateArgs} args - Arguments to create a Payment.
     * @example
     * // Create one Payment
     * const Payment = await prisma.payment.create({
     *   data: {
     *     // ... data to create a Payment
     *   }
     * })
     * 
     */
    create<T extends PaymentCreateArgs>(args: SelectSubset<T, PaymentCreateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Payments.
     * @param {PaymentCreateManyArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PaymentCreateManyArgs>(args?: SelectSubset<T, PaymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Payments and returns the data saved in the database.
     * @param {PaymentCreateManyAndReturnArgs} args - Arguments to create many Payments.
     * @example
     * // Create many Payments
     * const payment = await prisma.payment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PaymentCreateManyAndReturnArgs>(args?: SelectSubset<T, PaymentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Payment.
     * @param {PaymentDeleteArgs} args - Arguments to delete one Payment.
     * @example
     * // Delete one Payment
     * const Payment = await prisma.payment.delete({
     *   where: {
     *     // ... filter to delete one Payment
     *   }
     * })
     * 
     */
    delete<T extends PaymentDeleteArgs>(args: SelectSubset<T, PaymentDeleteArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Payment.
     * @param {PaymentUpdateArgs} args - Arguments to update one Payment.
     * @example
     * // Update one Payment
     * const payment = await prisma.payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PaymentUpdateArgs>(args: SelectSubset<T, PaymentUpdateArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Payments.
     * @param {PaymentDeleteManyArgs} args - Arguments to filter Payments to delete.
     * @example
     * // Delete a few Payments
     * const { count } = await prisma.payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PaymentDeleteManyArgs>(args?: SelectSubset<T, PaymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PaymentUpdateManyArgs>(args: SelectSubset<T, PaymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Payments and returns the data updated in the database.
     * @param {PaymentUpdateManyAndReturnArgs} args - Arguments to update many Payments.
     * @example
     * // Update many Payments
     * const payment = await prisma.payment.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Payments and only return the `id`
     * const paymentWithIdOnly = await prisma.payment.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends PaymentUpdateManyAndReturnArgs>(args: SelectSubset<T, PaymentUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Payment.
     * @param {PaymentUpsertArgs} args - Arguments to update or create a Payment.
     * @example
     * // Update or create a Payment
     * const payment = await prisma.payment.upsert({
     *   create: {
     *     // ... data to create a Payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Payment we want to update
     *   }
     * })
     */
    upsert<T extends PaymentUpsertArgs>(args: SelectSubset<T, PaymentUpsertArgs<ExtArgs>>): Prisma__PaymentClient<$Result.GetResult<Prisma.$PaymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentCountArgs} args - Arguments to filter Payments to count.
     * @example
     * // Count the number of Payments
     * const count = await prisma.payment.count({
     *   where: {
     *     // ... the filter for the Payments we want to count
     *   }
     * })
    **/
    count<T extends PaymentCountArgs>(
      args?: Subset<T, PaymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PaymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PaymentAggregateArgs>(args: Subset<T, PaymentAggregateArgs>): Prisma.PrismaPromise<GetPaymentAggregateType<T>>

    /**
     * Group by Payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PaymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PaymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PaymentGroupByArgs['orderBy'] }
        : { orderBy?: PaymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PaymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPaymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Payment model
   */
  readonly fields: PaymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PaymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    student<T extends StudentProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, StudentProfileDefaultArgs<ExtArgs>>): Prisma__StudentProfileClient<$Result.GetResult<Prisma.$StudentProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    teacher<T extends TeacherProfileDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeacherProfileDefaultArgs<ExtArgs>>): Prisma__TeacherProfileClient<$Result.GetResult<Prisma.$TeacherProfilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    lessons<T extends Payment$lessonsArgs<ExtArgs> = {}>(args?: Subset<T, Payment$lessonsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LessonPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Payment model
   */
  interface PaymentFieldRefs {
    readonly id: FieldRef<"Payment", 'String'>
    readonly amount: FieldRef<"Payment", 'Decimal'>
    readonly date: FieldRef<"Payment", 'DateTime'>
    readonly type: FieldRef<"Payment", 'PaymentType'>
    readonly note: FieldRef<"Payment", 'String'>
    readonly isVisibleToStudent: FieldRef<"Payment", 'Boolean'>
    readonly studentId: FieldRef<"Payment", 'String'>
    readonly teacherId: FieldRef<"Payment", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Payment findUnique
   */
  export type PaymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findUniqueOrThrow
   */
  export type PaymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment findFirst
   */
  export type PaymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findFirstOrThrow
   */
  export type PaymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payment to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Payments.
     */
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment findMany
   */
  export type PaymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter, which Payments to fetch.
     */
    where?: PaymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Payments to fetch.
     */
    orderBy?: PaymentOrderByWithRelationInput | PaymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Payments.
     */
    cursor?: PaymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Payments.
     */
    skip?: number
    distinct?: PaymentScalarFieldEnum | PaymentScalarFieldEnum[]
  }

  /**
   * Payment create
   */
  export type PaymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to create a Payment.
     */
    data: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
  }

  /**
   * Payment createMany
   */
  export type PaymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Payment createManyAndReturn
   */
  export type PaymentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to create many Payments.
     */
    data: PaymentCreateManyInput | PaymentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment update
   */
  export type PaymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The data needed to update a Payment.
     */
    data: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
    /**
     * Choose, which Payment to update.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment updateMany
   */
  export type PaymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
  }

  /**
   * Payment updateManyAndReturn
   */
  export type PaymentUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * The data used to update Payments.
     */
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyInput>
    /**
     * Filter which Payments to update
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Payment upsert
   */
  export type PaymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * The filter to search for the Payment to update in case it exists.
     */
    where: PaymentWhereUniqueInput
    /**
     * In case the Payment found by the `where` argument doesn't exist, create a new Payment with this data.
     */
    create: XOR<PaymentCreateInput, PaymentUncheckedCreateInput>
    /**
     * In case the Payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PaymentUpdateInput, PaymentUncheckedUpdateInput>
  }

  /**
   * Payment delete
   */
  export type PaymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
    /**
     * Filter which Payment to delete.
     */
    where: PaymentWhereUniqueInput
  }

  /**
   * Payment deleteMany
   */
  export type PaymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Payments to delete
     */
    where?: PaymentWhereInput
    /**
     * Limit how many Payments to delete.
     */
    limit?: number
  }

  /**
   * Payment.lessons
   */
  export type Payment$lessonsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Lesson
     */
    select?: LessonSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Lesson
     */
    omit?: LessonOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LessonInclude<ExtArgs> | null
    where?: LessonWhereInput
    orderBy?: LessonOrderByWithRelationInput | LessonOrderByWithRelationInput[]
    cursor?: LessonWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LessonScalarFieldEnum | LessonScalarFieldEnum[]
  }

  /**
   * Payment without action
   */
  export type PaymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Payment
     */
    select?: PaymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Payment
     */
    omit?: PaymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PaymentInclude<ExtArgs> | null
  }


  /**
   * Model Todo
   */

  export type AggregateTodo = {
    _count: TodoCountAggregateOutputType | null
    _min: TodoMinAggregateOutputType | null
    _max: TodoMaxAggregateOutputType | null
  }

  export type TodoMinAggregateOutputType = {
    id: string | null
    content: string | null
    isCompleted: boolean | null
    dueDate: Date | null
    reminderTime: Date | null
    priority: $Enums.Priority | null
    userId: string | null
    createdAt: Date | null
  }

  export type TodoMaxAggregateOutputType = {
    id: string | null
    content: string | null
    isCompleted: boolean | null
    dueDate: Date | null
    reminderTime: Date | null
    priority: $Enums.Priority | null
    userId: string | null
    createdAt: Date | null
  }

  export type TodoCountAggregateOutputType = {
    id: number
    content: number
    isCompleted: number
    dueDate: number
    reminderTime: number
    priority: number
    userId: number
    createdAt: number
    _all: number
  }


  export type TodoMinAggregateInputType = {
    id?: true
    content?: true
    isCompleted?: true
    dueDate?: true
    reminderTime?: true
    priority?: true
    userId?: true
    createdAt?: true
  }

  export type TodoMaxAggregateInputType = {
    id?: true
    content?: true
    isCompleted?: true
    dueDate?: true
    reminderTime?: true
    priority?: true
    userId?: true
    createdAt?: true
  }

  export type TodoCountAggregateInputType = {
    id?: true
    content?: true
    isCompleted?: true
    dueDate?: true
    reminderTime?: true
    priority?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type TodoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Todo to aggregate.
     */
    where?: TodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todos to fetch.
     */
    orderBy?: TodoOrderByWithRelationInput | TodoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Todos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Todos
    **/
    _count?: true | TodoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TodoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TodoMaxAggregateInputType
  }

  export type GetTodoAggregateType<T extends TodoAggregateArgs> = {
        [P in keyof T & keyof AggregateTodo]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTodo[P]>
      : GetScalarType<T[P], AggregateTodo[P]>
  }




  export type TodoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TodoWhereInput
    orderBy?: TodoOrderByWithAggregationInput | TodoOrderByWithAggregationInput[]
    by: TodoScalarFieldEnum[] | TodoScalarFieldEnum
    having?: TodoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TodoCountAggregateInputType | true
    _min?: TodoMinAggregateInputType
    _max?: TodoMaxAggregateInputType
  }

  export type TodoGroupByOutputType = {
    id: string
    content: string
    isCompleted: boolean
    dueDate: Date | null
    reminderTime: Date | null
    priority: $Enums.Priority
    userId: string
    createdAt: Date
    _count: TodoCountAggregateOutputType | null
    _min: TodoMinAggregateOutputType | null
    _max: TodoMaxAggregateOutputType | null
  }

  type GetTodoGroupByPayload<T extends TodoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TodoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TodoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TodoGroupByOutputType[P]>
            : GetScalarType<T[P], TodoGroupByOutputType[P]>
        }
      >
    >


  export type TodoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isCompleted?: boolean
    dueDate?: boolean
    reminderTime?: boolean
    priority?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todo"]>

  export type TodoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isCompleted?: boolean
    dueDate?: boolean
    reminderTime?: boolean
    priority?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todo"]>

  export type TodoSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    isCompleted?: boolean
    dueDate?: boolean
    reminderTime?: boolean
    priority?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["todo"]>

  export type TodoSelectScalar = {
    id?: boolean
    content?: boolean
    isCompleted?: boolean
    dueDate?: boolean
    reminderTime?: boolean
    priority?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type TodoOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "isCompleted" | "dueDate" | "reminderTime" | "priority" | "userId" | "createdAt", ExtArgs["result"]["todo"]>
  export type TodoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TodoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type TodoIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TodoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Todo"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string
      isCompleted: boolean
      dueDate: Date | null
      reminderTime: Date | null
      priority: $Enums.Priority
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["todo"]>
    composites: {}
  }

  type TodoGetPayload<S extends boolean | null | undefined | TodoDefaultArgs> = $Result.GetResult<Prisma.$TodoPayload, S>

  type TodoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<TodoFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: TodoCountAggregateInputType | true
    }

  export interface TodoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Todo'], meta: { name: 'Todo' } }
    /**
     * Find zero or one Todo that matches the filter.
     * @param {TodoFindUniqueArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TodoFindUniqueArgs>(args: SelectSubset<T, TodoFindUniqueArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Todo that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {TodoFindUniqueOrThrowArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TodoFindUniqueOrThrowArgs>(args: SelectSubset<T, TodoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Todo that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoFindFirstArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TodoFindFirstArgs>(args?: SelectSubset<T, TodoFindFirstArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Todo that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoFindFirstOrThrowArgs} args - Arguments to find a Todo
     * @example
     * // Get one Todo
     * const todo = await prisma.todo.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TodoFindFirstOrThrowArgs>(args?: SelectSubset<T, TodoFindFirstOrThrowArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Todos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Todos
     * const todos = await prisma.todo.findMany()
     * 
     * // Get first 10 Todos
     * const todos = await prisma.todo.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const todoWithIdOnly = await prisma.todo.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TodoFindManyArgs>(args?: SelectSubset<T, TodoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Todo.
     * @param {TodoCreateArgs} args - Arguments to create a Todo.
     * @example
     * // Create one Todo
     * const Todo = await prisma.todo.create({
     *   data: {
     *     // ... data to create a Todo
     *   }
     * })
     * 
     */
    create<T extends TodoCreateArgs>(args: SelectSubset<T, TodoCreateArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Todos.
     * @param {TodoCreateManyArgs} args - Arguments to create many Todos.
     * @example
     * // Create many Todos
     * const todo = await prisma.todo.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TodoCreateManyArgs>(args?: SelectSubset<T, TodoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Todos and returns the data saved in the database.
     * @param {TodoCreateManyAndReturnArgs} args - Arguments to create many Todos.
     * @example
     * // Create many Todos
     * const todo = await prisma.todo.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Todos and only return the `id`
     * const todoWithIdOnly = await prisma.todo.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TodoCreateManyAndReturnArgs>(args?: SelectSubset<T, TodoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Todo.
     * @param {TodoDeleteArgs} args - Arguments to delete one Todo.
     * @example
     * // Delete one Todo
     * const Todo = await prisma.todo.delete({
     *   where: {
     *     // ... filter to delete one Todo
     *   }
     * })
     * 
     */
    delete<T extends TodoDeleteArgs>(args: SelectSubset<T, TodoDeleteArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Todo.
     * @param {TodoUpdateArgs} args - Arguments to update one Todo.
     * @example
     * // Update one Todo
     * const todo = await prisma.todo.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TodoUpdateArgs>(args: SelectSubset<T, TodoUpdateArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Todos.
     * @param {TodoDeleteManyArgs} args - Arguments to filter Todos to delete.
     * @example
     * // Delete a few Todos
     * const { count } = await prisma.todo.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TodoDeleteManyArgs>(args?: SelectSubset<T, TodoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Todos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Todos
     * const todo = await prisma.todo.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TodoUpdateManyArgs>(args: SelectSubset<T, TodoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Todos and returns the data updated in the database.
     * @param {TodoUpdateManyAndReturnArgs} args - Arguments to update many Todos.
     * @example
     * // Update many Todos
     * const todo = await prisma.todo.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Todos and only return the `id`
     * const todoWithIdOnly = await prisma.todo.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends TodoUpdateManyAndReturnArgs>(args: SelectSubset<T, TodoUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Todo.
     * @param {TodoUpsertArgs} args - Arguments to update or create a Todo.
     * @example
     * // Update or create a Todo
     * const todo = await prisma.todo.upsert({
     *   create: {
     *     // ... data to create a Todo
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Todo we want to update
     *   }
     * })
     */
    upsert<T extends TodoUpsertArgs>(args: SelectSubset<T, TodoUpsertArgs<ExtArgs>>): Prisma__TodoClient<$Result.GetResult<Prisma.$TodoPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Todos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoCountArgs} args - Arguments to filter Todos to count.
     * @example
     * // Count the number of Todos
     * const count = await prisma.todo.count({
     *   where: {
     *     // ... the filter for the Todos we want to count
     *   }
     * })
    **/
    count<T extends TodoCountArgs>(
      args?: Subset<T, TodoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TodoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Todo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TodoAggregateArgs>(args: Subset<T, TodoAggregateArgs>): Prisma.PrismaPromise<GetTodoAggregateType<T>>

    /**
     * Group by Todo.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TodoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TodoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TodoGroupByArgs['orderBy'] }
        : { orderBy?: TodoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TodoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTodoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Todo model
   */
  readonly fields: TodoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Todo.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TodoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Todo model
   */
  interface TodoFieldRefs {
    readonly id: FieldRef<"Todo", 'String'>
    readonly content: FieldRef<"Todo", 'String'>
    readonly isCompleted: FieldRef<"Todo", 'Boolean'>
    readonly dueDate: FieldRef<"Todo", 'DateTime'>
    readonly reminderTime: FieldRef<"Todo", 'DateTime'>
    readonly priority: FieldRef<"Todo", 'Priority'>
    readonly userId: FieldRef<"Todo", 'String'>
    readonly createdAt: FieldRef<"Todo", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Todo findUnique
   */
  export type TodoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * Filter, which Todo to fetch.
     */
    where: TodoWhereUniqueInput
  }

  /**
   * Todo findUniqueOrThrow
   */
  export type TodoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * Filter, which Todo to fetch.
     */
    where: TodoWhereUniqueInput
  }

  /**
   * Todo findFirst
   */
  export type TodoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * Filter, which Todo to fetch.
     */
    where?: TodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todos to fetch.
     */
    orderBy?: TodoOrderByWithRelationInput | TodoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Todos.
     */
    cursor?: TodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Todos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Todos.
     */
    distinct?: TodoScalarFieldEnum | TodoScalarFieldEnum[]
  }

  /**
   * Todo findFirstOrThrow
   */
  export type TodoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * Filter, which Todo to fetch.
     */
    where?: TodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todos to fetch.
     */
    orderBy?: TodoOrderByWithRelationInput | TodoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Todos.
     */
    cursor?: TodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Todos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Todos.
     */
    distinct?: TodoScalarFieldEnum | TodoScalarFieldEnum[]
  }

  /**
   * Todo findMany
   */
  export type TodoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * Filter, which Todos to fetch.
     */
    where?: TodoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Todos to fetch.
     */
    orderBy?: TodoOrderByWithRelationInput | TodoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Todos.
     */
    cursor?: TodoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Todos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Todos.
     */
    skip?: number
    distinct?: TodoScalarFieldEnum | TodoScalarFieldEnum[]
  }

  /**
   * Todo create
   */
  export type TodoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * The data needed to create a Todo.
     */
    data: XOR<TodoCreateInput, TodoUncheckedCreateInput>
  }

  /**
   * Todo createMany
   */
  export type TodoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Todos.
     */
    data: TodoCreateManyInput | TodoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Todo createManyAndReturn
   */
  export type TodoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * The data used to create many Todos.
     */
    data: TodoCreateManyInput | TodoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Todo update
   */
  export type TodoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * The data needed to update a Todo.
     */
    data: XOR<TodoUpdateInput, TodoUncheckedUpdateInput>
    /**
     * Choose, which Todo to update.
     */
    where: TodoWhereUniqueInput
  }

  /**
   * Todo updateMany
   */
  export type TodoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Todos.
     */
    data: XOR<TodoUpdateManyMutationInput, TodoUncheckedUpdateManyInput>
    /**
     * Filter which Todos to update
     */
    where?: TodoWhereInput
    /**
     * Limit how many Todos to update.
     */
    limit?: number
  }

  /**
   * Todo updateManyAndReturn
   */
  export type TodoUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * The data used to update Todos.
     */
    data: XOR<TodoUpdateManyMutationInput, TodoUncheckedUpdateManyInput>
    /**
     * Filter which Todos to update
     */
    where?: TodoWhereInput
    /**
     * Limit how many Todos to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Todo upsert
   */
  export type TodoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * The filter to search for the Todo to update in case it exists.
     */
    where: TodoWhereUniqueInput
    /**
     * In case the Todo found by the `where` argument doesn't exist, create a new Todo with this data.
     */
    create: XOR<TodoCreateInput, TodoUncheckedCreateInput>
    /**
     * In case the Todo was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TodoUpdateInput, TodoUncheckedUpdateInput>
  }

  /**
   * Todo delete
   */
  export type TodoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
    /**
     * Filter which Todo to delete.
     */
    where: TodoWhereUniqueInput
  }

  /**
   * Todo deleteMany
   */
  export type TodoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Todos to delete
     */
    where?: TodoWhereInput
    /**
     * Limit how many Todos to delete.
     */
    limit?: number
  }

  /**
   * Todo without action
   */
  export type TodoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Todo
     */
    select?: TodoSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Todo
     */
    omit?: TodoOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TodoInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    isAllDay: boolean | null
    remindAt: Date | null
    color: string | null
    userId: string | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    startDate: Date | null
    endDate: Date | null
    isAllDay: boolean | null
    remindAt: Date | null
    color: string | null
    userId: string | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    description: number
    startDate: number
    endDate: number
    isAllDay: number
    remindAt: number
    color: number
    userId: number
    _all: number
  }


  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    isAllDay?: true
    remindAt?: true
    color?: true
    userId?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    isAllDay?: true
    remindAt?: true
    color?: true
    userId?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    startDate?: true
    endDate?: true
    isAllDay?: true
    remindAt?: true
    color?: true
    userId?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    description: string | null
    startDate: Date
    endDate: Date
    isAllDay: boolean
    remindAt: Date | null
    color: string | null
    userId: string
    _count: EventCountAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isAllDay?: boolean
    remindAt?: boolean
    color?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isAllDay?: boolean
    remindAt?: boolean
    color?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isAllDay?: boolean
    remindAt?: boolean
    color?: boolean
    userId?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>

  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    startDate?: boolean
    endDate?: boolean
    isAllDay?: boolean
    remindAt?: boolean
    color?: boolean
    userId?: boolean
  }

  export type EventOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "description" | "startDate" | "endDate" | "isAllDay" | "remindAt" | "color" | "userId", ExtArgs["result"]["event"]>
  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type EventIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      startDate: Date
      endDate: Date
      isAllDay: boolean
      remindAt: Date | null
      color: string | null
      userId: string
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Events and returns the data saved in the database.
     * @param {EventCreateManyAndReturnArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventCreateManyAndReturnArgs>(args?: SelectSubset<T, EventCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events and returns the data updated in the database.
     * @param {EventUpdateManyAndReturnArgs} args - Arguments to update many Events.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Events and only return the `id`
     * const eventWithIdOnly = await prisma.event.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends EventUpdateManyAndReturnArgs>(args: SelectSubset<T, EventUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly startDate: FieldRef<"Event", 'DateTime'>
    readonly endDate: FieldRef<"Event", 'DateTime'>
    readonly isAllDay: FieldRef<"Event", 'Boolean'>
    readonly remindAt: FieldRef<"Event", 'DateTime'>
    readonly color: FieldRef<"Event", 'String'>
    readonly userId: FieldRef<"Event", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event createManyAndReturn
   */
  export type EventCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
  }

  /**
   * Event updateManyAndReturn
   */
  export type EventUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
    /**
     * Limit how many Events to delete.
     */
    limit?: number
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Event
     */
    omit?: EventOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model Message
   */

  export type AggregateMessage = {
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  export type MessageMinAggregateOutputType = {
    id: string | null
    content: string | null
    fileId: string | null
    createdAt: Date | null
    isRead: boolean | null
    readAt: Date | null
    senderId: string | null
    receiverId: string | null
  }

  export type MessageMaxAggregateOutputType = {
    id: string | null
    content: string | null
    fileId: string | null
    createdAt: Date | null
    isRead: boolean | null
    readAt: Date | null
    senderId: string | null
    receiverId: string | null
  }

  export type MessageCountAggregateOutputType = {
    id: number
    content: number
    fileId: number
    createdAt: number
    isRead: number
    readAt: number
    senderId: number
    receiverId: number
    _all: number
  }


  export type MessageMinAggregateInputType = {
    id?: true
    content?: true
    fileId?: true
    createdAt?: true
    isRead?: true
    readAt?: true
    senderId?: true
    receiverId?: true
  }

  export type MessageMaxAggregateInputType = {
    id?: true
    content?: true
    fileId?: true
    createdAt?: true
    isRead?: true
    readAt?: true
    senderId?: true
    receiverId?: true
  }

  export type MessageCountAggregateInputType = {
    id?: true
    content?: true
    fileId?: true
    createdAt?: true
    isRead?: true
    readAt?: true
    senderId?: true
    receiverId?: true
    _all?: true
  }

  export type MessageAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Message to aggregate.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Messages
    **/
    _count?: true | MessageCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: MessageMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: MessageMaxAggregateInputType
  }

  export type GetMessageAggregateType<T extends MessageAggregateArgs> = {
        [P in keyof T & keyof AggregateMessage]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateMessage[P]>
      : GetScalarType<T[P], AggregateMessage[P]>
  }




  export type MessageGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithAggregationInput | MessageOrderByWithAggregationInput[]
    by: MessageScalarFieldEnum[] | MessageScalarFieldEnum
    having?: MessageScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: MessageCountAggregateInputType | true
    _min?: MessageMinAggregateInputType
    _max?: MessageMaxAggregateInputType
  }

  export type MessageGroupByOutputType = {
    id: string
    content: string | null
    fileId: string | null
    createdAt: Date
    isRead: boolean
    readAt: Date | null
    senderId: string
    receiverId: string
    _count: MessageCountAggregateOutputType | null
    _min: MessageMinAggregateOutputType | null
    _max: MessageMaxAggregateOutputType | null
  }

  type GetMessageGroupByPayload<T extends MessageGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<MessageGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof MessageGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], MessageGroupByOutputType[P]>
            : GetScalarType<T[P], MessageGroupByOutputType[P]>
        }
      >
    >


  export type MessageSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    fileId?: boolean
    createdAt?: boolean
    isRead?: boolean
    readAt?: boolean
    senderId?: boolean
    receiverId?: boolean
    file?: boolean | Message$fileArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    fileId?: boolean
    createdAt?: boolean
    isRead?: boolean
    readAt?: boolean
    senderId?: boolean
    receiverId?: boolean
    file?: boolean | Message$fileArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    content?: boolean
    fileId?: boolean
    createdAt?: boolean
    isRead?: boolean
    readAt?: boolean
    senderId?: boolean
    receiverId?: boolean
    file?: boolean | Message$fileArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["message"]>

  export type MessageSelectScalar = {
    id?: boolean
    content?: boolean
    fileId?: boolean
    createdAt?: boolean
    isRead?: boolean
    readAt?: boolean
    senderId?: boolean
    receiverId?: boolean
  }

  export type MessageOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "content" | "fileId" | "createdAt" | "isRead" | "readAt" | "senderId" | "receiverId", ExtArgs["result"]["message"]>
  export type MessageInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | Message$fileArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | Message$fileArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type MessageIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    file?: boolean | Message$fileArgs<ExtArgs>
    receiver?: boolean | UserDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $MessagePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Message"
    objects: {
      file: Prisma.$FilePayload<ExtArgs> | null
      receiver: Prisma.$UserPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      content: string | null
      fileId: string | null
      createdAt: Date
      isRead: boolean
      readAt: Date | null
      senderId: string
      receiverId: string
    }, ExtArgs["result"]["message"]>
    composites: {}
  }

  type MessageGetPayload<S extends boolean | null | undefined | MessageDefaultArgs> = $Result.GetResult<Prisma.$MessagePayload, S>

  type MessageCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<MessageFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: MessageCountAggregateInputType | true
    }

  export interface MessageDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Message'], meta: { name: 'Message' } }
    /**
     * Find zero or one Message that matches the filter.
     * @param {MessageFindUniqueArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends MessageFindUniqueArgs>(args: SelectSubset<T, MessageFindUniqueArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Message that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {MessageFindUniqueOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends MessageFindUniqueOrThrowArgs>(args: SelectSubset<T, MessageFindUniqueOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends MessageFindFirstArgs>(args?: SelectSubset<T, MessageFindFirstArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Message that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindFirstOrThrowArgs} args - Arguments to find a Message
     * @example
     * // Get one Message
     * const message = await prisma.message.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends MessageFindFirstOrThrowArgs>(args?: SelectSubset<T, MessageFindFirstOrThrowArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Messages that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Messages
     * const messages = await prisma.message.findMany()
     * 
     * // Get first 10 Messages
     * const messages = await prisma.message.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const messageWithIdOnly = await prisma.message.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends MessageFindManyArgs>(args?: SelectSubset<T, MessageFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Message.
     * @param {MessageCreateArgs} args - Arguments to create a Message.
     * @example
     * // Create one Message
     * const Message = await prisma.message.create({
     *   data: {
     *     // ... data to create a Message
     *   }
     * })
     * 
     */
    create<T extends MessageCreateArgs>(args: SelectSubset<T, MessageCreateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Messages.
     * @param {MessageCreateManyArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends MessageCreateManyArgs>(args?: SelectSubset<T, MessageCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Messages and returns the data saved in the database.
     * @param {MessageCreateManyAndReturnArgs} args - Arguments to create many Messages.
     * @example
     * // Create many Messages
     * const message = await prisma.message.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends MessageCreateManyAndReturnArgs>(args?: SelectSubset<T, MessageCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Message.
     * @param {MessageDeleteArgs} args - Arguments to delete one Message.
     * @example
     * // Delete one Message
     * const Message = await prisma.message.delete({
     *   where: {
     *     // ... filter to delete one Message
     *   }
     * })
     * 
     */
    delete<T extends MessageDeleteArgs>(args: SelectSubset<T, MessageDeleteArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Message.
     * @param {MessageUpdateArgs} args - Arguments to update one Message.
     * @example
     * // Update one Message
     * const message = await prisma.message.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends MessageUpdateArgs>(args: SelectSubset<T, MessageUpdateArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Messages.
     * @param {MessageDeleteManyArgs} args - Arguments to filter Messages to delete.
     * @example
     * // Delete a few Messages
     * const { count } = await prisma.message.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends MessageDeleteManyArgs>(args?: SelectSubset<T, MessageDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends MessageUpdateManyArgs>(args: SelectSubset<T, MessageUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Messages and returns the data updated in the database.
     * @param {MessageUpdateManyAndReturnArgs} args - Arguments to update many Messages.
     * @example
     * // Update many Messages
     * const message = await prisma.message.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Messages and only return the `id`
     * const messageWithIdOnly = await prisma.message.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends MessageUpdateManyAndReturnArgs>(args: SelectSubset<T, MessageUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Message.
     * @param {MessageUpsertArgs} args - Arguments to update or create a Message.
     * @example
     * // Update or create a Message
     * const message = await prisma.message.upsert({
     *   create: {
     *     // ... data to create a Message
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Message we want to update
     *   }
     * })
     */
    upsert<T extends MessageUpsertArgs>(args: SelectSubset<T, MessageUpsertArgs<ExtArgs>>): Prisma__MessageClient<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Messages.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageCountArgs} args - Arguments to filter Messages to count.
     * @example
     * // Count the number of Messages
     * const count = await prisma.message.count({
     *   where: {
     *     // ... the filter for the Messages we want to count
     *   }
     * })
    **/
    count<T extends MessageCountArgs>(
      args?: Subset<T, MessageCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], MessageCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends MessageAggregateArgs>(args: Subset<T, MessageAggregateArgs>): Prisma.PrismaPromise<GetMessageAggregateType<T>>

    /**
     * Group by Message.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {MessageGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends MessageGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: MessageGroupByArgs['orderBy'] }
        : { orderBy?: MessageGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, MessageGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetMessageGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Message model
   */
  readonly fields: MessageFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Message.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__MessageClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    file<T extends Message$fileArgs<ExtArgs> = {}>(args?: Subset<T, Message$fileArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    receiver<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Message model
   */
  interface MessageFieldRefs {
    readonly id: FieldRef<"Message", 'String'>
    readonly content: FieldRef<"Message", 'String'>
    readonly fileId: FieldRef<"Message", 'String'>
    readonly createdAt: FieldRef<"Message", 'DateTime'>
    readonly isRead: FieldRef<"Message", 'Boolean'>
    readonly readAt: FieldRef<"Message", 'DateTime'>
    readonly senderId: FieldRef<"Message", 'String'>
    readonly receiverId: FieldRef<"Message", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Message findUnique
   */
  export type MessageFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findUniqueOrThrow
   */
  export type MessageFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message findFirst
   */
  export type MessageFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findFirstOrThrow
   */
  export type MessageFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Message to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Messages.
     */
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message findMany
   */
  export type MessageFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter, which Messages to fetch.
     */
    where?: MessageWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Messages to fetch.
     */
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Messages.
     */
    cursor?: MessageWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Messages from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Messages.
     */
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * Message create
   */
  export type MessageCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to create a Message.
     */
    data: XOR<MessageCreateInput, MessageUncheckedCreateInput>
  }

  /**
   * Message createMany
   */
  export type MessageCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Message createManyAndReturn
   */
  export type MessageCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to create many Messages.
     */
    data: MessageCreateManyInput | MessageCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message update
   */
  export type MessageUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The data needed to update a Message.
     */
    data: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
    /**
     * Choose, which Message to update.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message updateMany
   */
  export type MessageUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
  }

  /**
   * Message updateManyAndReturn
   */
  export type MessageUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * The data used to update Messages.
     */
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyInput>
    /**
     * Filter which Messages to update
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Message upsert
   */
  export type MessageUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * The filter to search for the Message to update in case it exists.
     */
    where: MessageWhereUniqueInput
    /**
     * In case the Message found by the `where` argument doesn't exist, create a new Message with this data.
     */
    create: XOR<MessageCreateInput, MessageUncheckedCreateInput>
    /**
     * In case the Message was found with the provided `where` argument, update it with this data.
     */
    update: XOR<MessageUpdateInput, MessageUncheckedUpdateInput>
  }

  /**
   * Message delete
   */
  export type MessageDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    /**
     * Filter which Message to delete.
     */
    where: MessageWhereUniqueInput
  }

  /**
   * Message deleteMany
   */
  export type MessageDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Messages to delete
     */
    where?: MessageWhereInput
    /**
     * Limit how many Messages to delete.
     */
    limit?: number
  }

  /**
   * Message.file
   */
  export type Message$fileArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    where?: FileWhereInput
  }

  /**
   * Message without action
   */
  export type MessageDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    title: string | null
    body: string | null
    route: string | null
    relatedId: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    userId: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    title: string | null
    body: string | null
    route: string | null
    relatedId: string | null
    type: $Enums.NotificationType | null
    isRead: boolean | null
    userId: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    title: number
    body: number
    route: number
    relatedId: number
    type: number
    isRead: number
    userId: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    title?: true
    body?: true
    route?: true
    relatedId?: true
    type?: true
    isRead?: true
    userId?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    title?: true
    body?: true
    route?: true
    relatedId?: true
    type?: true
    isRead?: true
    userId?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    title?: true
    body?: true
    route?: true
    relatedId?: true
    type?: true
    isRead?: true
    userId?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    title: string
    body: string
    route: string | null
    relatedId: string | null
    type: $Enums.NotificationType
    isRead: boolean
    userId: string
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    body?: boolean
    route?: boolean
    relatedId?: boolean
    type?: boolean
    isRead?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    body?: boolean
    route?: boolean
    relatedId?: boolean
    type?: boolean
    isRead?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    body?: boolean
    route?: boolean
    relatedId?: boolean
    type?: boolean
    isRead?: boolean
    userId?: boolean
    createdAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    title?: boolean
    body?: boolean
    route?: boolean
    relatedId?: boolean
    type?: boolean
    isRead?: boolean
    userId?: boolean
    createdAt?: boolean
  }

  export type NotificationOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "title" | "body" | "route" | "relatedId" | "type" | "isRead" | "userId" | "createdAt", ExtArgs["result"]["notification"]>
  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type NotificationIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      body: string
      route: string | null
      relatedId: string | null
      type: $Enums.NotificationType
      isRead: boolean
      userId: string
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications and returns the data updated in the database.
     * @param {NotificationUpdateManyAndReturnArgs} args - Arguments to update many Notifications.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends NotificationUpdateManyAndReturnArgs>(args: SelectSubset<T, NotificationUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly body: FieldRef<"Notification", 'String'>
    readonly route: FieldRef<"Notification", 'String'>
    readonly relatedId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'NotificationType'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
  }

  /**
   * Notification updateManyAndReturn
   */
  export type NotificationUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
    /**
     * Limit how many Notifications to delete.
     */
    limit?: number
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Notification
     */
    omit?: NotificationOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model File
   */

  export type AggregateFile = {
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  export type FileAvgAggregateOutputType = {
    sizeBytes: number | null
  }

  export type FileSumAggregateOutputType = {
    sizeBytes: number | null
  }

  export type FileMinAggregateOutputType = {
    id: string | null
    key: string | null
    filename: string | null
    mimeType: string | null
    sizeBytes: number | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileMaxAggregateOutputType = {
    id: string | null
    key: string | null
    filename: string | null
    mimeType: string | null
    sizeBytes: number | null
    ownerId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type FileCountAggregateOutputType = {
    id: number
    key: number
    filename: number
    mimeType: number
    sizeBytes: number
    ownerId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type FileAvgAggregateInputType = {
    sizeBytes?: true
  }

  export type FileSumAggregateInputType = {
    sizeBytes?: true
  }

  export type FileMinAggregateInputType = {
    id?: true
    key?: true
    filename?: true
    mimeType?: true
    sizeBytes?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileMaxAggregateInputType = {
    id?: true
    key?: true
    filename?: true
    mimeType?: true
    sizeBytes?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type FileCountAggregateInputType = {
    id?: true
    key?: true
    filename?: true
    mimeType?: true
    sizeBytes?: true
    ownerId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type FileAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which File to aggregate.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Files
    **/
    _count?: true | FileCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: FileAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: FileSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: FileMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: FileMaxAggregateInputType
  }

  export type GetFileAggregateType<T extends FileAggregateArgs> = {
        [P in keyof T & keyof AggregateFile]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateFile[P]>
      : GetScalarType<T[P], AggregateFile[P]>
  }




  export type FileGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: FileWhereInput
    orderBy?: FileOrderByWithAggregationInput | FileOrderByWithAggregationInput[]
    by: FileScalarFieldEnum[] | FileScalarFieldEnum
    having?: FileScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: FileCountAggregateInputType | true
    _avg?: FileAvgAggregateInputType
    _sum?: FileSumAggregateInputType
    _min?: FileMinAggregateInputType
    _max?: FileMaxAggregateInputType
  }

  export type FileGroupByOutputType = {
    id: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    ownerId: string
    createdAt: Date
    updatedAt: Date
    _count: FileCountAggregateOutputType | null
    _avg: FileAvgAggregateOutputType | null
    _sum: FileSumAggregateOutputType | null
    _min: FileMinAggregateOutputType | null
    _max: FileMaxAggregateOutputType | null
  }

  type GetFileGroupByPayload<T extends FileGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<FileGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof FileGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], FileGroupByOutputType[P]>
            : GetScalarType<T[P], FileGroupByOutputType[P]>
        }
      >
    >


  export type FileSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    filename?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
    materials?: boolean | File$materialsArgs<ExtArgs>
    messages?: boolean | File$messagesArgs<ExtArgs>
    homeworkTrackings?: boolean | File$homeworkTrackingsArgs<ExtArgs>
    homeworkSubmissions?: boolean | File$homeworkSubmissionsArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    filename?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    filename?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["file"]>

  export type FileSelectScalar = {
    id?: boolean
    key?: boolean
    filename?: boolean
    mimeType?: boolean
    sizeBytes?: boolean
    ownerId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type FileOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "key" | "filename" | "mimeType" | "sizeBytes" | "ownerId" | "createdAt" | "updatedAt", ExtArgs["result"]["file"]>
  export type FileInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
    materials?: boolean | File$materialsArgs<ExtArgs>
    messages?: boolean | File$messagesArgs<ExtArgs>
    homeworkTrackings?: boolean | File$homeworkTrackingsArgs<ExtArgs>
    homeworkSubmissions?: boolean | File$homeworkSubmissionsArgs<ExtArgs>
    _count?: boolean | FileCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type FileIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }
  export type FileIncludeUpdateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    owner?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $FilePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "File"
    objects: {
      owner: Prisma.$UserPayload<ExtArgs>
      materials: Prisma.$MaterialPayload<ExtArgs>[]
      messages: Prisma.$MessagePayload<ExtArgs>[]
      homeworkTrackings: Prisma.$HomeworkTrackingPayload<ExtArgs>[]
      homeworkSubmissions: Prisma.$HomeworkSubmissionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      filename: string
      mimeType: string
      sizeBytes: number
      ownerId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["file"]>
    composites: {}
  }

  type FileGetPayload<S extends boolean | null | undefined | FileDefaultArgs> = $Result.GetResult<Prisma.$FilePayload, S>

  type FileCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<FileFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: FileCountAggregateInputType | true
    }

  export interface FileDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['File'], meta: { name: 'File' } }
    /**
     * Find zero or one File that matches the filter.
     * @param {FileFindUniqueArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends FileFindUniqueArgs>(args: SelectSubset<T, FileFindUniqueArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one File that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {FileFindUniqueOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends FileFindUniqueOrThrowArgs>(args: SelectSubset<T, FileFindUniqueOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends FileFindFirstArgs>(args?: SelectSubset<T, FileFindFirstArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first File that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindFirstOrThrowArgs} args - Arguments to find a File
     * @example
     * // Get one File
     * const file = await prisma.file.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends FileFindFirstOrThrowArgs>(args?: SelectSubset<T, FileFindFirstOrThrowArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Files that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Files
     * const files = await prisma.file.findMany()
     * 
     * // Get first 10 Files
     * const files = await prisma.file.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const fileWithIdOnly = await prisma.file.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends FileFindManyArgs>(args?: SelectSubset<T, FileFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a File.
     * @param {FileCreateArgs} args - Arguments to create a File.
     * @example
     * // Create one File
     * const File = await prisma.file.create({
     *   data: {
     *     // ... data to create a File
     *   }
     * })
     * 
     */
    create<T extends FileCreateArgs>(args: SelectSubset<T, FileCreateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Files.
     * @param {FileCreateManyArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends FileCreateManyArgs>(args?: SelectSubset<T, FileCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Files and returns the data saved in the database.
     * @param {FileCreateManyAndReturnArgs} args - Arguments to create many Files.
     * @example
     * // Create many Files
     * const file = await prisma.file.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.createManyAndReturn({
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends FileCreateManyAndReturnArgs>(args?: SelectSubset<T, FileCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "createManyAndReturn", GlobalOmitOptions>>

    /**
     * Delete a File.
     * @param {FileDeleteArgs} args - Arguments to delete one File.
     * @example
     * // Delete one File
     * const File = await prisma.file.delete({
     *   where: {
     *     // ... filter to delete one File
     *   }
     * })
     * 
     */
    delete<T extends FileDeleteArgs>(args: SelectSubset<T, FileDeleteArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one File.
     * @param {FileUpdateArgs} args - Arguments to update one File.
     * @example
     * // Update one File
     * const file = await prisma.file.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends FileUpdateArgs>(args: SelectSubset<T, FileUpdateArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Files.
     * @param {FileDeleteManyArgs} args - Arguments to filter Files to delete.
     * @example
     * // Delete a few Files
     * const { count } = await prisma.file.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends FileDeleteManyArgs>(args?: SelectSubset<T, FileDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends FileUpdateManyArgs>(args: SelectSubset<T, FileUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Files and returns the data updated in the database.
     * @param {FileUpdateManyAndReturnArgs} args - Arguments to update many Files.
     * @example
     * // Update many Files
     * const file = await prisma.file.updateManyAndReturn({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Update zero or more Files and only return the `id`
     * const fileWithIdOnly = await prisma.file.updateManyAndReturn({
     *   select: { id: true },
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    updateManyAndReturn<T extends FileUpdateManyAndReturnArgs>(args: SelectSubset<T, FileUpdateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "updateManyAndReturn", GlobalOmitOptions>>

    /**
     * Create or update one File.
     * @param {FileUpsertArgs} args - Arguments to update or create a File.
     * @example
     * // Update or create a File
     * const file = await prisma.file.upsert({
     *   create: {
     *     // ... data to create a File
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the File we want to update
     *   }
     * })
     */
    upsert<T extends FileUpsertArgs>(args: SelectSubset<T, FileUpsertArgs<ExtArgs>>): Prisma__FileClient<$Result.GetResult<Prisma.$FilePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>


    /**
     * Count the number of Files.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileCountArgs} args - Arguments to filter Files to count.
     * @example
     * // Count the number of Files
     * const count = await prisma.file.count({
     *   where: {
     *     // ... the filter for the Files we want to count
     *   }
     * })
    **/
    count<T extends FileCountArgs>(
      args?: Subset<T, FileCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], FileCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends FileAggregateArgs>(args: Subset<T, FileAggregateArgs>): Prisma.PrismaPromise<GetFileAggregateType<T>>

    /**
     * Group by File.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {FileGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends FileGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: FileGroupByArgs['orderBy'] }
        : { orderBy?: FileGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, FileGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetFileGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the File model
   */
  readonly fields: FileFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for File.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__FileClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    owner<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    materials<T extends File$materialsArgs<ExtArgs> = {}>(args?: Subset<T, File$materialsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MaterialPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    messages<T extends File$messagesArgs<ExtArgs> = {}>(args?: Subset<T, File$messagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$MessagePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    homeworkTrackings<T extends File$homeworkTrackingsArgs<ExtArgs> = {}>(args?: Subset<T, File$homeworkTrackingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkTrackingPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    homeworkSubmissions<T extends File$homeworkSubmissionsArgs<ExtArgs> = {}>(args?: Subset<T, File$homeworkSubmissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HomeworkSubmissionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the File model
   */
  interface FileFieldRefs {
    readonly id: FieldRef<"File", 'String'>
    readonly key: FieldRef<"File", 'String'>
    readonly filename: FieldRef<"File", 'String'>
    readonly mimeType: FieldRef<"File", 'String'>
    readonly sizeBytes: FieldRef<"File", 'Int'>
    readonly ownerId: FieldRef<"File", 'String'>
    readonly createdAt: FieldRef<"File", 'DateTime'>
    readonly updatedAt: FieldRef<"File", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * File findUnique
   */
  export type FileFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findUniqueOrThrow
   */
  export type FileFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File findFirst
   */
  export type FileFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findFirstOrThrow
   */
  export type FileFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which File to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Files.
     */
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File findMany
   */
  export type FileFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter, which Files to fetch.
     */
    where?: FileWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Files to fetch.
     */
    orderBy?: FileOrderByWithRelationInput | FileOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Files.
     */
    cursor?: FileWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `Â±n` Files from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Files.
     */
    skip?: number
    distinct?: FileScalarFieldEnum | FileScalarFieldEnum[]
  }

  /**
   * File create
   */
  export type FileCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to create a File.
     */
    data: XOR<FileCreateInput, FileUncheckedCreateInput>
  }

  /**
   * File createMany
   */
  export type FileCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * File createManyAndReturn
   */
  export type FileCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to create many Files.
     */
    data: FileCreateManyInput | FileCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * File update
   */
  export type FileUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The data needed to update a File.
     */
    data: XOR<FileUpdateInput, FileUncheckedUpdateInput>
    /**
     * Choose, which File to update.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File updateMany
   */
  export type FileUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
  }

  /**
   * File updateManyAndReturn
   */
  export type FileUpdateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelectUpdateManyAndReturn<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * The data used to update Files.
     */
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyInput>
    /**
     * Filter which Files to update
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to update.
     */
    limit?: number
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileIncludeUpdateManyAndReturn<ExtArgs> | null
  }

  /**
   * File upsert
   */
  export type FileUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * The filter to search for the File to update in case it exists.
     */
    where: FileWhereUniqueInput
    /**
     * In case the File found by the `where` argument doesn't exist, create a new File with this data.
     */
    create: XOR<FileCreateInput, FileUncheckedCreateInput>
    /**
     * In case the File was found with the provided `where` argument, update it with this data.
     */
    update: XOR<FileUpdateInput, FileUncheckedUpdateInput>
  }

  /**
   * File delete
   */
  export type FileDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
    /**
     * Filter which File to delete.
     */
    where: FileWhereUniqueInput
  }

  /**
   * File deleteMany
   */
  export type FileDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Files to delete
     */
    where?: FileWhereInput
    /**
     * Limit how many Files to delete.
     */
    limit?: number
  }

  /**
   * File.materials
   */
  export type File$materialsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Material
     */
    select?: MaterialSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Material
     */
    omit?: MaterialOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MaterialInclude<ExtArgs> | null
    where?: MaterialWhereInput
    orderBy?: MaterialOrderByWithRelationInput | MaterialOrderByWithRelationInput[]
    cursor?: MaterialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MaterialScalarFieldEnum | MaterialScalarFieldEnum[]
  }

  /**
   * File.messages
   */
  export type File$messagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Message
     */
    select?: MessageSelect<ExtArgs> | null
    /**
     * Omit specific fields from the Message
     */
    omit?: MessageOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: MessageInclude<ExtArgs> | null
    where?: MessageWhereInput
    orderBy?: MessageOrderByWithRelationInput | MessageOrderByWithRelationInput[]
    cursor?: MessageWhereUniqueInput
    take?: number
    skip?: number
    distinct?: MessageScalarFieldEnum | MessageScalarFieldEnum[]
  }

  /**
   * File.homeworkTrackings
   */
  export type File$homeworkTrackingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkTracking
     */
    select?: HomeworkTrackingSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkTracking
     */
    omit?: HomeworkTrackingOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkTrackingInclude<ExtArgs> | null
    where?: HomeworkTrackingWhereInput
    orderBy?: HomeworkTrackingOrderByWithRelationInput | HomeworkTrackingOrderByWithRelationInput[]
    cursor?: HomeworkTrackingWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomeworkTrackingScalarFieldEnum | HomeworkTrackingScalarFieldEnum[]
  }

  /**
   * File.homeworkSubmissions
   */
  export type File$homeworkSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HomeworkSubmission
     */
    select?: HomeworkSubmissionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the HomeworkSubmission
     */
    omit?: HomeworkSubmissionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HomeworkSubmissionInclude<ExtArgs> | null
    where?: HomeworkSubmissionWhereInput
    orderBy?: HomeworkSubmissionOrderByWithRelationInput | HomeworkSubmissionOrderByWithRelationInput[]
    cursor?: HomeworkSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HomeworkSubmissionScalarFieldEnum | HomeworkSubmissionScalarFieldEnum[]
  }

  /**
   * File without action
   */
  export type FileDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the File
     */
    select?: FileSelect<ExtArgs> | null
    /**
     * Omit specific fields from the File
     */
    omit?: FileOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: FileInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    name: 'name',
    firstName: 'firstName',
    lastName: 'lastName',
    username: 'username',
    email: 'email',
    emailVerified: 'emailVerified',
    image: 'image',
    avatarVersion: 'avatarVersion',
    password: 'password',
    phoneNumber: 'phoneNumber',
    isDeleted: 'isDeleted',
    deletedAt: 'deletedAt',
    role: 'role',
    isActive: 'isActive',
    isOnboardingCompleted: 'isOnboardingCompleted',
    notificationEmailEnabled: 'notificationEmailEnabled',
    notificationInAppEnabled: 'notificationInAppEnabled',
    preferredCountry: 'preferredCountry',
    preferredTimezone: 'preferredTimezone',
    cookieAnalyticsEnabled: 'cookieAnalyticsEnabled',
    isMarketingConsent: 'isMarketingConsent',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const UserSettingsScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    profileVisibility: 'profileVisibility',
    showAvatar: 'showAvatar',
    showEmail: 'showEmail',
    showPhone: 'showPhone',
    allowMessages: 'allowMessages',
    showCourses: 'showCourses',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserSettingsScalarFieldEnum = (typeof UserSettingsScalarFieldEnum)[keyof typeof UserSettingsScalarFieldEnum]


  export const AccountScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    type: 'type',
    provider: 'provider',
    providerAccountId: 'providerAccountId',
    refresh_token: 'refresh_token',
    access_token: 'access_token',
    expires_at: 'expires_at',
    token_type: 'token_type',
    scope: 'scope',
    id_token: 'id_token',
    session_state: 'session_state'
  };

  export type AccountScalarFieldEnum = (typeof AccountScalarFieldEnum)[keyof typeof AccountScalarFieldEnum]


  export const SessionScalarFieldEnum: {
    id: 'id',
    sessionToken: 'sessionToken',
    userId: 'userId',
    expires: 'expires'
  };

  export type SessionScalarFieldEnum = (typeof SessionScalarFieldEnum)[keyof typeof SessionScalarFieldEnum]


  export const VerificationTokenScalarFieldEnum: {
    identifier: 'identifier',
    token: 'token',
    expires: 'expires'
  };

  export type VerificationTokenScalarFieldEnum = (typeof VerificationTokenScalarFieldEnum)[keyof typeof VerificationTokenScalarFieldEnum]


  export const PasswordResetTokenScalarFieldEnum: {
    id: 'id',
    email: 'email',
    token: 'token',
    expires: 'expires'
  };

  export type PasswordResetTokenScalarFieldEnum = (typeof PasswordResetTokenScalarFieldEnum)[keyof typeof PasswordResetTokenScalarFieldEnum]


  export const EmailChangeRequestScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    newEmail: 'newEmail',
    token: 'token',
    expires: 'expires',
    usedAt: 'usedAt'
  };

  export type EmailChangeRequestScalarFieldEnum = (typeof EmailChangeRequestScalarFieldEnum)[keyof typeof EmailChangeRequestScalarFieldEnum]


  export const DeviceScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    deviceType: 'deviceType',
    deviceId: 'deviceId',
    model: 'model',
    fcmToken: 'fcmToken',
    lastActive: 'lastActive'
  };

  export type DeviceScalarFieldEnum = (typeof DeviceScalarFieldEnum)[keyof typeof DeviceScalarFieldEnum]


  export const TeacherProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    branch: 'branch',
    bio: 'bio'
  };

  export type TeacherProfileScalarFieldEnum = (typeof TeacherProfileScalarFieldEnum)[keyof typeof TeacherProfileScalarFieldEnum]


  export const StudentProfileScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    tempFirstName: 'tempFirstName',
    tempLastName: 'tempLastName',
    tempPhone: 'tempPhone',
    tempEmail: 'tempEmail',
    tempAvatarKey: 'tempAvatarKey',
    inviteToken: 'inviteToken',
    inviteTokenExpires: 'inviteTokenExpires',
    isClaimed: 'isClaimed',
    creatorTeacherId: 'creatorTeacherId',
    studentNo: 'studentNo',
    gradeLevel: 'gradeLevel',
    parentName: 'parentName',
    parentPhone: 'parentPhone',
    parentEmail: 'parentEmail',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentProfileScalarFieldEnum = (typeof StudentProfileScalarFieldEnum)[keyof typeof StudentProfileScalarFieldEnum]


  export const StudentTeacherRelationScalarFieldEnum: {
    id: 'id',
    teacherId: 'teacherId',
    studentId: 'studentId',
    status: 'status',
    isCreator: 'isCreator',
    customName: 'customName',
    privateNotes: 'privateNotes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StudentTeacherRelationScalarFieldEnum = (typeof StudentTeacherRelationScalarFieldEnum)[keyof typeof StudentTeacherRelationScalarFieldEnum]


  export const ClassroomScalarFieldEnum: {
    id: 'id',
    name: 'name',
    year: 'year',
    teacherId: 'teacherId'
  };

  export type ClassroomScalarFieldEnum = (typeof ClassroomScalarFieldEnum)[keyof typeof ClassroomScalarFieldEnum]


  export const ScheduleItemScalarFieldEnum: {
    id: 'id',
    dayOfWeek: 'dayOfWeek',
    startTime: 'startTime',
    endTime: 'endTime',
    subject: 'subject',
    type: 'type',
    location: 'location',
    locationUrl: 'locationUrl',
    address: 'address',
    price: 'price',
    currency: 'currency',
    teacherId: 'teacherId',
    classroomId: 'classroomId',
    studentId: 'studentId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ScheduleItemScalarFieldEnum = (typeof ScheduleItemScalarFieldEnum)[keyof typeof ScheduleItemScalarFieldEnum]


  export const LessonScalarFieldEnum: {
    id: 'id',
    title: 'title',
    startTime: 'startTime',
    endTime: 'endTime',
    scheduleItemId: 'scheduleItemId',
    type: 'type',
    status: 'status',
    cancelReason: 'cancelReason',
    location: 'location',
    locationUrl: 'locationUrl',
    address: 'address',
    publicNote: 'publicNote',
    privateNote: 'privateNote',
    price: 'price',
    currency: 'currency',
    isPaid: 'isPaid',
    teacherId: 'teacherId',
    classroomId: 'classroomId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LessonScalarFieldEnum = (typeof LessonScalarFieldEnum)[keyof typeof LessonScalarFieldEnum]


  export const MaterialScalarFieldEnum: {
    id: 'id',
    title: 'title',
    fileId: 'fileId',
    linkUrl: 'linkUrl',
    type: 'type',
    lessonId: 'lessonId',
    createdAt: 'createdAt'
  };

  export type MaterialScalarFieldEnum = (typeof MaterialScalarFieldEnum)[keyof typeof MaterialScalarFieldEnum]


  export const HomeworkScalarFieldEnum: {
    id: 'id',
    title: 'title',
    content: 'content',
    assignedDate: 'assignedDate',
    dueDate: 'dueDate',
    lessonId: 'lessonId'
  };

  export type HomeworkScalarFieldEnum = (typeof HomeworkScalarFieldEnum)[keyof typeof HomeworkScalarFieldEnum]


  export const HomeworkTrackingScalarFieldEnum: {
    id: 'id',
    homeworkId: 'homeworkId',
    studentId: 'studentId',
    status: 'status',
    studentNote: 'studentNote',
    teacherNote: 'teacherNote',
    fileId: 'fileId',
    checkedAt: 'checkedAt'
  };

  export type HomeworkTrackingScalarFieldEnum = (typeof HomeworkTrackingScalarFieldEnum)[keyof typeof HomeworkTrackingScalarFieldEnum]


  export const HomeworkSubmissionScalarFieldEnum: {
    id: 'id',
    fileId: 'fileId',
    note: 'note',
    submittedAt: 'submittedAt',
    studentId: 'studentId'
  };

  export type HomeworkSubmissionScalarFieldEnum = (typeof HomeworkSubmissionScalarFieldEnum)[keyof typeof HomeworkSubmissionScalarFieldEnum]


  export const SchoolExamScalarFieldEnum: {
    id: 'id',
    title: 'title',
    score: 'score',
    date: 'date',
    subject: 'subject',
    studentId: 'studentId'
  };

  export type SchoolExamScalarFieldEnum = (typeof SchoolExamScalarFieldEnum)[keyof typeof SchoolExamScalarFieldEnum]


  export const TrialExamScalarFieldEnum: {
    id: 'id',
    title: 'title',
    date: 'date',
    category: 'category',
    publisher: 'publisher',
    studentId: 'studentId',
    totalNet: 'totalNet',
    totalScore: 'totalScore'
  };

  export type TrialExamScalarFieldEnum = (typeof TrialExamScalarFieldEnum)[keyof typeof TrialExamScalarFieldEnum]


  export const TrialExamResultScalarFieldEnum: {
    id: 'id',
    trialExamId: 'trialExamId',
    lessonName: 'lessonName',
    correctCount: 'correctCount',
    incorrectCount: 'incorrectCount',
    emptyCount: 'emptyCount',
    net: 'net',
    mistakeTopics: 'mistakeTopics',
    mistakeAnalysis: 'mistakeAnalysis'
  };

  export type TrialExamResultScalarFieldEnum = (typeof TrialExamResultScalarFieldEnum)[keyof typeof TrialExamResultScalarFieldEnum]


  export const AttendanceScalarFieldEnum: {
    id: 'id',
    lessonId: 'lessonId',
    studentId: 'studentId',
    status: 'status',
    note: 'note'
  };

  export type AttendanceScalarFieldEnum = (typeof AttendanceScalarFieldEnum)[keyof typeof AttendanceScalarFieldEnum]


  export const PaymentScalarFieldEnum: {
    id: 'id',
    amount: 'amount',
    date: 'date',
    type: 'type',
    note: 'note',
    isVisibleToStudent: 'isVisibleToStudent',
    studentId: 'studentId',
    teacherId: 'teacherId'
  };

  export type PaymentScalarFieldEnum = (typeof PaymentScalarFieldEnum)[keyof typeof PaymentScalarFieldEnum]


  export const TodoScalarFieldEnum: {
    id: 'id',
    content: 'content',
    isCompleted: 'isCompleted',
    dueDate: 'dueDate',
    reminderTime: 'reminderTime',
    priority: 'priority',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type TodoScalarFieldEnum = (typeof TodoScalarFieldEnum)[keyof typeof TodoScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    startDate: 'startDate',
    endDate: 'endDate',
    isAllDay: 'isAllDay',
    remindAt: 'remindAt',
    color: 'color',
    userId: 'userId'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const MessageScalarFieldEnum: {
    id: 'id',
    content: 'content',
    fileId: 'fileId',
    createdAt: 'createdAt',
    isRead: 'isRead',
    readAt: 'readAt',
    senderId: 'senderId',
    receiverId: 'receiverId'
  };

  export type MessageScalarFieldEnum = (typeof MessageScalarFieldEnum)[keyof typeof MessageScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    title: 'title',
    body: 'body',
    route: 'route',
    relatedId: 'relatedId',
    type: 'type',
    isRead: 'isRead',
    userId: 'userId',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const FileScalarFieldEnum: {
    id: 'id',
    key: 'key',
    filename: 'filename',
    mimeType: 'mimeType',
    sizeBytes: 'sizeBytes',
    ownerId: 'ownerId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type FileScalarFieldEnum = (typeof FileScalarFieldEnum)[keyof typeof FileScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Role'
   */
  export type EnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role'>
    


  /**
   * Reference to a field of type 'Role[]'
   */
  export type ListEnumRoleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Role[]'>
    


  /**
   * Reference to a field of type 'DeviceType'
   */
  export type EnumDeviceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceType'>
    


  /**
   * Reference to a field of type 'DeviceType[]'
   */
  export type ListEnumDeviceTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DeviceType[]'>
    


  /**
   * Reference to a field of type 'RelationStatus'
   */
  export type EnumRelationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationStatus'>
    


  /**
   * Reference to a field of type 'RelationStatus[]'
   */
  export type ListEnumRelationStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'RelationStatus[]'>
    


  /**
   * Reference to a field of type 'LessonType'
   */
  export type EnumLessonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonType'>
    


  /**
   * Reference to a field of type 'LessonType[]'
   */
  export type ListEnumLessonTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonType[]'>
    


  /**
   * Reference to a field of type 'LessonLocation'
   */
  export type EnumLessonLocationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonLocation'>
    


  /**
   * Reference to a field of type 'LessonLocation[]'
   */
  export type ListEnumLessonLocationFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonLocation[]'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Decimal[]'
   */
  export type ListDecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal[]'>
    


  /**
   * Reference to a field of type 'LessonStatus'
   */
  export type EnumLessonStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonStatus'>
    


  /**
   * Reference to a field of type 'LessonStatus[]'
   */
  export type ListEnumLessonStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'LessonStatus[]'>
    


  /**
   * Reference to a field of type 'FileType'
   */
  export type EnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType'>
    


  /**
   * Reference to a field of type 'FileType[]'
   */
  export type ListEnumFileTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'FileType[]'>
    


  /**
   * Reference to a field of type 'HomeworkStatus'
   */
  export type EnumHomeworkStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HomeworkStatus'>
    


  /**
   * Reference to a field of type 'HomeworkStatus[]'
   */
  export type ListEnumHomeworkStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'HomeworkStatus[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'ExamCategory'
   */
  export type EnumExamCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamCategory'>
    


  /**
   * Reference to a field of type 'ExamCategory[]'
   */
  export type ListEnumExamCategoryFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'ExamCategory[]'>
    


  /**
   * Reference to a field of type 'AttendanceStatus'
   */
  export type EnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus'>
    


  /**
   * Reference to a field of type 'AttendanceStatus[]'
   */
  export type ListEnumAttendanceStatusFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'AttendanceStatus[]'>
    


  /**
   * Reference to a field of type 'PaymentType'
   */
  export type EnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType'>
    


  /**
   * Reference to a field of type 'PaymentType[]'
   */
  export type ListEnumPaymentTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'PaymentType[]'>
    


  /**
   * Reference to a field of type 'Priority'
   */
  export type EnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority'>
    


  /**
   * Reference to a field of type 'Priority[]'
   */
  export type ListEnumPriorityFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Priority[]'>
    


  /**
   * Reference to a field of type 'NotificationType'
   */
  export type EnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType'>
    


  /**
   * Reference to a field of type 'NotificationType[]'
   */
  export type ListEnumNotificationTypeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'NotificationType[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    name?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    username?: StringNullableFilter<"User"> | string | null
    email?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    avatarVersion?: IntFilter<"User"> | number
    password?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumRoleNullableFilter<"User"> | $Enums.Role | null
    isActive?: BoolFilter<"User"> | boolean
    isOnboardingCompleted?: BoolFilter<"User"> | boolean
    notificationEmailEnabled?: BoolFilter<"User"> | boolean
    notificationInAppEnabled?: BoolFilter<"User"> | boolean
    preferredCountry?: StringNullableFilter<"User"> | string | null
    preferredTimezone?: StringNullableFilter<"User"> | string | null
    cookieAnalyticsEnabled?: BoolFilter<"User"> | boolean
    isMarketingConsent?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    teacherProfile?: XOR<TeacherProfileNullableScalarRelationFilter, TeacherProfileWhereInput> | null
    studentProfile?: XOR<StudentProfileNullableScalarRelationFilter, StudentProfileWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    emailChangeRequests?: EmailChangeRequestListRelationFilter
    devices?: DeviceListRelationFilter
    notifications?: NotificationListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    todos?: TodoListRelationFilter
    calendarEvents?: EventListRelationFilter
    files?: FileListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    avatarVersion?: SortOrder
    password?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isOnboardingCompleted?: SortOrder
    notificationEmailEnabled?: SortOrder
    notificationInAppEnabled?: SortOrder
    preferredCountry?: SortOrderInput | SortOrder
    preferredTimezone?: SortOrderInput | SortOrder
    cookieAnalyticsEnabled?: SortOrder
    isMarketingConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    settings?: UserSettingsOrderByWithRelationInput
    teacherProfile?: TeacherProfileOrderByWithRelationInput
    studentProfile?: StudentProfileOrderByWithRelationInput
    accounts?: AccountOrderByRelationAggregateInput
    sessions?: SessionOrderByRelationAggregateInput
    emailChangeRequests?: EmailChangeRequestOrderByRelationAggregateInput
    devices?: DeviceOrderByRelationAggregateInput
    notifications?: NotificationOrderByRelationAggregateInput
    sentMessages?: MessageOrderByRelationAggregateInput
    receivedMessages?: MessageOrderByRelationAggregateInput
    todos?: TodoOrderByRelationAggregateInput
    calendarEvents?: EventOrderByRelationAggregateInput
    files?: FileOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    name?: StringNullableFilter<"User"> | string | null
    firstName?: StringNullableFilter<"User"> | string | null
    lastName?: StringNullableFilter<"User"> | string | null
    emailVerified?: DateTimeNullableFilter<"User"> | Date | string | null
    image?: StringNullableFilter<"User"> | string | null
    avatarVersion?: IntFilter<"User"> | number
    password?: StringNullableFilter<"User"> | string | null
    phoneNumber?: StringNullableFilter<"User"> | string | null
    isDeleted?: BoolFilter<"User"> | boolean
    deletedAt?: DateTimeNullableFilter<"User"> | Date | string | null
    role?: EnumRoleNullableFilter<"User"> | $Enums.Role | null
    isActive?: BoolFilter<"User"> | boolean
    isOnboardingCompleted?: BoolFilter<"User"> | boolean
    notificationEmailEnabled?: BoolFilter<"User"> | boolean
    notificationInAppEnabled?: BoolFilter<"User"> | boolean
    preferredCountry?: StringNullableFilter<"User"> | string | null
    preferredTimezone?: StringNullableFilter<"User"> | string | null
    cookieAnalyticsEnabled?: BoolFilter<"User"> | boolean
    isMarketingConsent?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    settings?: XOR<UserSettingsNullableScalarRelationFilter, UserSettingsWhereInput> | null
    teacherProfile?: XOR<TeacherProfileNullableScalarRelationFilter, TeacherProfileWhereInput> | null
    studentProfile?: XOR<StudentProfileNullableScalarRelationFilter, StudentProfileWhereInput> | null
    accounts?: AccountListRelationFilter
    sessions?: SessionListRelationFilter
    emailChangeRequests?: EmailChangeRequestListRelationFilter
    devices?: DeviceListRelationFilter
    notifications?: NotificationListRelationFilter
    sentMessages?: MessageListRelationFilter
    receivedMessages?: MessageListRelationFilter
    todos?: TodoListRelationFilter
    calendarEvents?: EventListRelationFilter
    files?: FileListRelationFilter
  }, "id" | "username" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrderInput | SortOrder
    firstName?: SortOrderInput | SortOrder
    lastName?: SortOrderInput | SortOrder
    username?: SortOrderInput | SortOrder
    email?: SortOrderInput | SortOrder
    emailVerified?: SortOrderInput | SortOrder
    image?: SortOrderInput | SortOrder
    avatarVersion?: SortOrder
    password?: SortOrderInput | SortOrder
    phoneNumber?: SortOrderInput | SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrderInput | SortOrder
    role?: SortOrderInput | SortOrder
    isActive?: SortOrder
    isOnboardingCompleted?: SortOrder
    notificationEmailEnabled?: SortOrder
    notificationInAppEnabled?: SortOrder
    preferredCountry?: SortOrderInput | SortOrder
    preferredTimezone?: SortOrderInput | SortOrder
    cookieAnalyticsEnabled?: SortOrder
    isMarketingConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    name?: StringNullableWithAggregatesFilter<"User"> | string | null
    firstName?: StringNullableWithAggregatesFilter<"User"> | string | null
    lastName?: StringNullableWithAggregatesFilter<"User"> | string | null
    username?: StringNullableWithAggregatesFilter<"User"> | string | null
    email?: StringNullableWithAggregatesFilter<"User"> | string | null
    emailVerified?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    image?: StringNullableWithAggregatesFilter<"User"> | string | null
    avatarVersion?: IntWithAggregatesFilter<"User"> | number
    password?: StringNullableWithAggregatesFilter<"User"> | string | null
    phoneNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    isDeleted?: BoolWithAggregatesFilter<"User"> | boolean
    deletedAt?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
    role?: EnumRoleNullableWithAggregatesFilter<"User"> | $Enums.Role | null
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    isOnboardingCompleted?: BoolWithAggregatesFilter<"User"> | boolean
    notificationEmailEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    notificationInAppEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    preferredCountry?: StringNullableWithAggregatesFilter<"User"> | string | null
    preferredTimezone?: StringNullableWithAggregatesFilter<"User"> | string | null
    cookieAnalyticsEnabled?: BoolWithAggregatesFilter<"User"> | boolean
    isMarketingConsent?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type UserSettingsWhereInput = {
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    id?: StringFilter<"UserSettings"> | string
    userId?: StringFilter<"UserSettings"> | string
    profileVisibility?: StringFilter<"UserSettings"> | string
    showAvatar?: BoolFilter<"UserSettings"> | boolean
    showEmail?: BoolFilter<"UserSettings"> | boolean
    showPhone?: BoolFilter<"UserSettings"> | boolean
    allowMessages?: BoolFilter<"UserSettings"> | boolean
    showCourses?: BoolFilter<"UserSettings"> | boolean
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type UserSettingsOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileVisibility?: SortOrder
    showAvatar?: SortOrder
    showEmail?: SortOrder
    showPhone?: SortOrder
    allowMessages?: SortOrder
    showCourses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserSettingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: UserSettingsWhereInput | UserSettingsWhereInput[]
    OR?: UserSettingsWhereInput[]
    NOT?: UserSettingsWhereInput | UserSettingsWhereInput[]
    profileVisibility?: StringFilter<"UserSettings"> | string
    showAvatar?: BoolFilter<"UserSettings"> | boolean
    showEmail?: BoolFilter<"UserSettings"> | boolean
    showPhone?: BoolFilter<"UserSettings"> | boolean
    allowMessages?: BoolFilter<"UserSettings"> | boolean
    showCourses?: BoolFilter<"UserSettings"> | boolean
    createdAt?: DateTimeFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeFilter<"UserSettings"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId">

  export type UserSettingsOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    profileVisibility?: SortOrder
    showAvatar?: SortOrder
    showEmail?: SortOrder
    showPhone?: SortOrder
    allowMessages?: SortOrder
    showCourses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserSettingsCountOrderByAggregateInput
    _max?: UserSettingsMaxOrderByAggregateInput
    _min?: UserSettingsMinOrderByAggregateInput
  }

  export type UserSettingsScalarWhereWithAggregatesInput = {
    AND?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    OR?: UserSettingsScalarWhereWithAggregatesInput[]
    NOT?: UserSettingsScalarWhereWithAggregatesInput | UserSettingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserSettings"> | string
    userId?: StringWithAggregatesFilter<"UserSettings"> | string
    profileVisibility?: StringWithAggregatesFilter<"UserSettings"> | string
    showAvatar?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    showEmail?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    showPhone?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    allowMessages?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    showCourses?: BoolWithAggregatesFilter<"UserSettings"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"UserSettings"> | Date | string
  }

  export type AccountWhereInput = {
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type AccountOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type AccountWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    provider_providerAccountId?: AccountProviderProviderAccountIdCompoundUniqueInput
    AND?: AccountWhereInput | AccountWhereInput[]
    OR?: AccountWhereInput[]
    NOT?: AccountWhereInput | AccountWhereInput[]
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "provider_providerAccountId">

  export type AccountOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrderInput | SortOrder
    access_token?: SortOrderInput | SortOrder
    expires_at?: SortOrderInput | SortOrder
    token_type?: SortOrderInput | SortOrder
    scope?: SortOrderInput | SortOrder
    id_token?: SortOrderInput | SortOrder
    session_state?: SortOrderInput | SortOrder
    _count?: AccountCountOrderByAggregateInput
    _avg?: AccountAvgOrderByAggregateInput
    _max?: AccountMaxOrderByAggregateInput
    _min?: AccountMinOrderByAggregateInput
    _sum?: AccountSumOrderByAggregateInput
  }

  export type AccountScalarWhereWithAggregatesInput = {
    AND?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    OR?: AccountScalarWhereWithAggregatesInput[]
    NOT?: AccountScalarWhereWithAggregatesInput | AccountScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Account"> | string
    userId?: StringWithAggregatesFilter<"Account"> | string
    type?: StringWithAggregatesFilter<"Account"> | string
    provider?: StringWithAggregatesFilter<"Account"> | string
    providerAccountId?: StringWithAggregatesFilter<"Account"> | string
    refresh_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    access_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    expires_at?: IntNullableWithAggregatesFilter<"Account"> | number | null
    token_type?: StringNullableWithAggregatesFilter<"Account"> | string | null
    scope?: StringNullableWithAggregatesFilter<"Account"> | string | null
    id_token?: StringNullableWithAggregatesFilter<"Account"> | string | null
    session_state?: StringNullableWithAggregatesFilter<"Account"> | string | null
  }

  export type SessionWhereInput = {
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type SessionOrderByWithRelationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type SessionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    sessionToken?: string
    AND?: SessionWhereInput | SessionWhereInput[]
    OR?: SessionWhereInput[]
    NOT?: SessionWhereInput | SessionWhereInput[]
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "sessionToken">

  export type SessionOrderByWithAggregationInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
    _count?: SessionCountOrderByAggregateInput
    _max?: SessionMaxOrderByAggregateInput
    _min?: SessionMinOrderByAggregateInput
  }

  export type SessionScalarWhereWithAggregatesInput = {
    AND?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    OR?: SessionScalarWhereWithAggregatesInput[]
    NOT?: SessionScalarWhereWithAggregatesInput | SessionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Session"> | string
    sessionToken?: StringWithAggregatesFilter<"Session"> | string
    userId?: StringWithAggregatesFilter<"Session"> | string
    expires?: DateTimeWithAggregatesFilter<"Session"> | Date | string
  }

  export type VerificationTokenWhereInput = {
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    token?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }

  export type VerificationTokenOrderByWithRelationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenWhereUniqueInput = Prisma.AtLeast<{
    token?: string
    identifier_token?: VerificationTokenIdentifierTokenCompoundUniqueInput
    AND?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    OR?: VerificationTokenWhereInput[]
    NOT?: VerificationTokenWhereInput | VerificationTokenWhereInput[]
    identifier?: StringFilter<"VerificationToken"> | string
    expires?: DateTimeFilter<"VerificationToken"> | Date | string
  }, "token" | "identifier_token">

  export type VerificationTokenOrderByWithAggregationInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: VerificationTokenCountOrderByAggregateInput
    _max?: VerificationTokenMaxOrderByAggregateInput
    _min?: VerificationTokenMinOrderByAggregateInput
  }

  export type VerificationTokenScalarWhereWithAggregatesInput = {
    AND?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    OR?: VerificationTokenScalarWhereWithAggregatesInput[]
    NOT?: VerificationTokenScalarWhereWithAggregatesInput | VerificationTokenScalarWhereWithAggregatesInput[]
    identifier?: StringWithAggregatesFilter<"VerificationToken"> | string
    token?: StringWithAggregatesFilter<"VerificationToken"> | string
    expires?: DateTimeWithAggregatesFilter<"VerificationToken"> | Date | string
  }

  export type PasswordResetTokenWhereInput = {
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    id?: StringFilter<"PasswordResetToken"> | string
    email?: StringFilter<"PasswordResetToken"> | string
    token?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }

  export type PasswordResetTokenOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    email_token?: PasswordResetTokenEmailTokenCompoundUniqueInput
    AND?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    OR?: PasswordResetTokenWhereInput[]
    NOT?: PasswordResetTokenWhereInput | PasswordResetTokenWhereInput[]
    email?: StringFilter<"PasswordResetToken"> | string
    expires?: DateTimeFilter<"PasswordResetToken"> | Date | string
  }, "id" | "token" | "email_token">

  export type PasswordResetTokenOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    _count?: PasswordResetTokenCountOrderByAggregateInput
    _max?: PasswordResetTokenMaxOrderByAggregateInput
    _min?: PasswordResetTokenMinOrderByAggregateInput
  }

  export type PasswordResetTokenScalarWhereWithAggregatesInput = {
    AND?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    OR?: PasswordResetTokenScalarWhereWithAggregatesInput[]
    NOT?: PasswordResetTokenScalarWhereWithAggregatesInput | PasswordResetTokenScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    email?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    token?: StringWithAggregatesFilter<"PasswordResetToken"> | string
    expires?: DateTimeWithAggregatesFilter<"PasswordResetToken"> | Date | string
  }

  export type EmailChangeRequestWhereInput = {
    AND?: EmailChangeRequestWhereInput | EmailChangeRequestWhereInput[]
    OR?: EmailChangeRequestWhereInput[]
    NOT?: EmailChangeRequestWhereInput | EmailChangeRequestWhereInput[]
    id?: StringFilter<"EmailChangeRequest"> | string
    userId?: StringFilter<"EmailChangeRequest"> | string
    newEmail?: StringFilter<"EmailChangeRequest"> | string
    token?: StringFilter<"EmailChangeRequest"> | string
    expires?: DateTimeFilter<"EmailChangeRequest"> | Date | string
    usedAt?: DateTimeNullableFilter<"EmailChangeRequest"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EmailChangeRequestOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    newEmail?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EmailChangeRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: EmailChangeRequestWhereInput | EmailChangeRequestWhereInput[]
    OR?: EmailChangeRequestWhereInput[]
    NOT?: EmailChangeRequestWhereInput | EmailChangeRequestWhereInput[]
    userId?: StringFilter<"EmailChangeRequest"> | string
    newEmail?: StringFilter<"EmailChangeRequest"> | string
    expires?: DateTimeFilter<"EmailChangeRequest"> | Date | string
    usedAt?: DateTimeNullableFilter<"EmailChangeRequest"> | Date | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "token">

  export type EmailChangeRequestOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    newEmail?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    usedAt?: SortOrderInput | SortOrder
    _count?: EmailChangeRequestCountOrderByAggregateInput
    _max?: EmailChangeRequestMaxOrderByAggregateInput
    _min?: EmailChangeRequestMinOrderByAggregateInput
  }

  export type EmailChangeRequestScalarWhereWithAggregatesInput = {
    AND?: EmailChangeRequestScalarWhereWithAggregatesInput | EmailChangeRequestScalarWhereWithAggregatesInput[]
    OR?: EmailChangeRequestScalarWhereWithAggregatesInput[]
    NOT?: EmailChangeRequestScalarWhereWithAggregatesInput | EmailChangeRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailChangeRequest"> | string
    userId?: StringWithAggregatesFilter<"EmailChangeRequest"> | string
    newEmail?: StringWithAggregatesFilter<"EmailChangeRequest"> | string
    token?: StringWithAggregatesFilter<"EmailChangeRequest"> | string
    expires?: DateTimeWithAggregatesFilter<"EmailChangeRequest"> | Date | string
    usedAt?: DateTimeNullableWithAggregatesFilter<"EmailChangeRequest"> | Date | string | null
  }

  export type DeviceWhereInput = {
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    id?: StringFilter<"Device"> | string
    userId?: StringFilter<"Device"> | string
    deviceType?: EnumDeviceTypeFilter<"Device"> | $Enums.DeviceType
    deviceId?: StringNullableFilter<"Device"> | string | null
    model?: StringNullableFilter<"Device"> | string | null
    fcmToken?: StringNullableFilter<"Device"> | string | null
    lastActive?: DateTimeFilter<"Device"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type DeviceOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    fcmToken?: SortOrderInput | SortOrder
    lastActive?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type DeviceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_deviceId?: DeviceUserIdDeviceIdCompoundUniqueInput
    AND?: DeviceWhereInput | DeviceWhereInput[]
    OR?: DeviceWhereInput[]
    NOT?: DeviceWhereInput | DeviceWhereInput[]
    userId?: StringFilter<"Device"> | string
    deviceType?: EnumDeviceTypeFilter<"Device"> | $Enums.DeviceType
    deviceId?: StringNullableFilter<"Device"> | string | null
    model?: StringNullableFilter<"Device"> | string | null
    fcmToken?: StringNullableFilter<"Device"> | string | null
    lastActive?: DateTimeFilter<"Device"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id" | "userId_deviceId">

  export type DeviceOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrderInput | SortOrder
    model?: SortOrderInput | SortOrder
    fcmToken?: SortOrderInput | SortOrder
    lastActive?: SortOrder
    _count?: DeviceCountOrderByAggregateInput
    _max?: DeviceMaxOrderByAggregateInput
    _min?: DeviceMinOrderByAggregateInput
  }

  export type DeviceScalarWhereWithAggregatesInput = {
    AND?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    OR?: DeviceScalarWhereWithAggregatesInput[]
    NOT?: DeviceScalarWhereWithAggregatesInput | DeviceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Device"> | string
    userId?: StringWithAggregatesFilter<"Device"> | string
    deviceType?: EnumDeviceTypeWithAggregatesFilter<"Device"> | $Enums.DeviceType
    deviceId?: StringNullableWithAggregatesFilter<"Device"> | string | null
    model?: StringNullableWithAggregatesFilter<"Device"> | string | null
    fcmToken?: StringNullableWithAggregatesFilter<"Device"> | string | null
    lastActive?: DateTimeWithAggregatesFilter<"Device"> | Date | string
  }

  export type TeacherProfileWhereInput = {
    AND?: TeacherProfileWhereInput | TeacherProfileWhereInput[]
    OR?: TeacherProfileWhereInput[]
    NOT?: TeacherProfileWhereInput | TeacherProfileWhereInput[]
    id?: StringFilter<"TeacherProfile"> | string
    userId?: StringFilter<"TeacherProfile"> | string
    branch?: StringFilter<"TeacherProfile"> | string
    bio?: StringNullableFilter<"TeacherProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    studentRelations?: StudentTeacherRelationListRelationFilter
    classes?: ClassroomListRelationFilter
    lessons?: LessonListRelationFilter
    payments?: PaymentListRelationFilter
    scheduleItems?: ScheduleItemListRelationFilter
  }

  export type TeacherProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    branch?: SortOrder
    bio?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    studentRelations?: StudentTeacherRelationOrderByRelationAggregateInput
    classes?: ClassroomOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    scheduleItems?: ScheduleItemOrderByRelationAggregateInput
  }

  export type TeacherProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    AND?: TeacherProfileWhereInput | TeacherProfileWhereInput[]
    OR?: TeacherProfileWhereInput[]
    NOT?: TeacherProfileWhereInput | TeacherProfileWhereInput[]
    branch?: StringFilter<"TeacherProfile"> | string
    bio?: StringNullableFilter<"TeacherProfile"> | string | null
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
    studentRelations?: StudentTeacherRelationListRelationFilter
    classes?: ClassroomListRelationFilter
    lessons?: LessonListRelationFilter
    payments?: PaymentListRelationFilter
    scheduleItems?: ScheduleItemListRelationFilter
  }, "id" | "userId">

  export type TeacherProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    branch?: SortOrder
    bio?: SortOrderInput | SortOrder
    _count?: TeacherProfileCountOrderByAggregateInput
    _max?: TeacherProfileMaxOrderByAggregateInput
    _min?: TeacherProfileMinOrderByAggregateInput
  }

  export type TeacherProfileScalarWhereWithAggregatesInput = {
    AND?: TeacherProfileScalarWhereWithAggregatesInput | TeacherProfileScalarWhereWithAggregatesInput[]
    OR?: TeacherProfileScalarWhereWithAggregatesInput[]
    NOT?: TeacherProfileScalarWhereWithAggregatesInput | TeacherProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeacherProfile"> | string
    userId?: StringWithAggregatesFilter<"TeacherProfile"> | string
    branch?: StringWithAggregatesFilter<"TeacherProfile"> | string
    bio?: StringNullableWithAggregatesFilter<"TeacherProfile"> | string | null
  }

  export type StudentProfileWhereInput = {
    AND?: StudentProfileWhereInput | StudentProfileWhereInput[]
    OR?: StudentProfileWhereInput[]
    NOT?: StudentProfileWhereInput | StudentProfileWhereInput[]
    id?: StringFilter<"StudentProfile"> | string
    userId?: StringNullableFilter<"StudentProfile"> | string | null
    tempFirstName?: StringNullableFilter<"StudentProfile"> | string | null
    tempLastName?: StringNullableFilter<"StudentProfile"> | string | null
    tempPhone?: StringNullableFilter<"StudentProfile"> | string | null
    tempEmail?: StringNullableFilter<"StudentProfile"> | string | null
    tempAvatarKey?: StringNullableFilter<"StudentProfile"> | string | null
    inviteToken?: StringNullableFilter<"StudentProfile"> | string | null
    inviteTokenExpires?: DateTimeNullableFilter<"StudentProfile"> | Date | string | null
    isClaimed?: BoolFilter<"StudentProfile"> | boolean
    creatorTeacherId?: StringNullableFilter<"StudentProfile"> | string | null
    studentNo?: StringNullableFilter<"StudentProfile"> | string | null
    gradeLevel?: StringNullableFilter<"StudentProfile"> | string | null
    parentName?: StringNullableFilter<"StudentProfile"> | string | null
    parentPhone?: StringNullableFilter<"StudentProfile"> | string | null
    parentEmail?: StringNullableFilter<"StudentProfile"> | string | null
    createdAt?: DateTimeFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StudentProfile"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    teacherRelations?: StudentTeacherRelationListRelationFilter
    classrooms?: ClassroomListRelationFilter
    recurringSchedules?: ScheduleItemListRelationFilter
    lessons?: LessonListRelationFilter
    homeworkTrackings?: HomeworkTrackingListRelationFilter
    submissions?: HomeworkSubmissionListRelationFilter
    payments?: PaymentListRelationFilter
    grades?: SchoolExamListRelationFilter
    trialExams?: TrialExamListRelationFilter
    attendances?: AttendanceListRelationFilter
  }

  export type StudentProfileOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    tempFirstName?: SortOrderInput | SortOrder
    tempLastName?: SortOrderInput | SortOrder
    tempPhone?: SortOrderInput | SortOrder
    tempEmail?: SortOrderInput | SortOrder
    tempAvatarKey?: SortOrderInput | SortOrder
    inviteToken?: SortOrderInput | SortOrder
    inviteTokenExpires?: SortOrderInput | SortOrder
    isClaimed?: SortOrder
    creatorTeacherId?: SortOrderInput | SortOrder
    studentNo?: SortOrderInput | SortOrder
    gradeLevel?: SortOrderInput | SortOrder
    parentName?: SortOrderInput | SortOrder
    parentPhone?: SortOrderInput | SortOrder
    parentEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
    teacherRelations?: StudentTeacherRelationOrderByRelationAggregateInput
    classrooms?: ClassroomOrderByRelationAggregateInput
    recurringSchedules?: ScheduleItemOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
    homeworkTrackings?: HomeworkTrackingOrderByRelationAggregateInput
    submissions?: HomeworkSubmissionOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
    grades?: SchoolExamOrderByRelationAggregateInput
    trialExams?: TrialExamOrderByRelationAggregateInput
    attendances?: AttendanceOrderByRelationAggregateInput
  }

  export type StudentProfileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId?: string
    inviteToken?: string
    AND?: StudentProfileWhereInput | StudentProfileWhereInput[]
    OR?: StudentProfileWhereInput[]
    NOT?: StudentProfileWhereInput | StudentProfileWhereInput[]
    tempFirstName?: StringNullableFilter<"StudentProfile"> | string | null
    tempLastName?: StringNullableFilter<"StudentProfile"> | string | null
    tempPhone?: StringNullableFilter<"StudentProfile"> | string | null
    tempEmail?: StringNullableFilter<"StudentProfile"> | string | null
    tempAvatarKey?: StringNullableFilter<"StudentProfile"> | string | null
    inviteTokenExpires?: DateTimeNullableFilter<"StudentProfile"> | Date | string | null
    isClaimed?: BoolFilter<"StudentProfile"> | boolean
    creatorTeacherId?: StringNullableFilter<"StudentProfile"> | string | null
    studentNo?: StringNullableFilter<"StudentProfile"> | string | null
    gradeLevel?: StringNullableFilter<"StudentProfile"> | string | null
    parentName?: StringNullableFilter<"StudentProfile"> | string | null
    parentPhone?: StringNullableFilter<"StudentProfile"> | string | null
    parentEmail?: StringNullableFilter<"StudentProfile"> | string | null
    createdAt?: DateTimeFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StudentProfile"> | Date | string
    user?: XOR<UserNullableScalarRelationFilter, UserWhereInput> | null
    teacherRelations?: StudentTeacherRelationListRelationFilter
    classrooms?: ClassroomListRelationFilter
    recurringSchedules?: ScheduleItemListRelationFilter
    lessons?: LessonListRelationFilter
    homeworkTrackings?: HomeworkTrackingListRelationFilter
    submissions?: HomeworkSubmissionListRelationFilter
    payments?: PaymentListRelationFilter
    grades?: SchoolExamListRelationFilter
    trialExams?: TrialExamListRelationFilter
    attendances?: AttendanceListRelationFilter
  }, "id" | "userId" | "inviteToken">

  export type StudentProfileOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    tempFirstName?: SortOrderInput | SortOrder
    tempLastName?: SortOrderInput | SortOrder
    tempPhone?: SortOrderInput | SortOrder
    tempEmail?: SortOrderInput | SortOrder
    tempAvatarKey?: SortOrderInput | SortOrder
    inviteToken?: SortOrderInput | SortOrder
    inviteTokenExpires?: SortOrderInput | SortOrder
    isClaimed?: SortOrder
    creatorTeacherId?: SortOrderInput | SortOrder
    studentNo?: SortOrderInput | SortOrder
    gradeLevel?: SortOrderInput | SortOrder
    parentName?: SortOrderInput | SortOrder
    parentPhone?: SortOrderInput | SortOrder
    parentEmail?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentProfileCountOrderByAggregateInput
    _max?: StudentProfileMaxOrderByAggregateInput
    _min?: StudentProfileMinOrderByAggregateInput
  }

  export type StudentProfileScalarWhereWithAggregatesInput = {
    AND?: StudentProfileScalarWhereWithAggregatesInput | StudentProfileScalarWhereWithAggregatesInput[]
    OR?: StudentProfileScalarWhereWithAggregatesInput[]
    NOT?: StudentProfileScalarWhereWithAggregatesInput | StudentProfileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentProfile"> | string
    userId?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    tempFirstName?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    tempLastName?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    tempPhone?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    tempEmail?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    tempAvatarKey?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    inviteToken?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    inviteTokenExpires?: DateTimeNullableWithAggregatesFilter<"StudentProfile"> | Date | string | null
    isClaimed?: BoolWithAggregatesFilter<"StudentProfile"> | boolean
    creatorTeacherId?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    studentNo?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    gradeLevel?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    parentName?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    parentPhone?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    parentEmail?: StringNullableWithAggregatesFilter<"StudentProfile"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentProfile"> | Date | string
  }

  export type StudentTeacherRelationWhereInput = {
    AND?: StudentTeacherRelationWhereInput | StudentTeacherRelationWhereInput[]
    OR?: StudentTeacherRelationWhereInput[]
    NOT?: StudentTeacherRelationWhereInput | StudentTeacherRelationWhereInput[]
    id?: StringFilter<"StudentTeacherRelation"> | string
    teacherId?: StringFilter<"StudentTeacherRelation"> | string
    studentId?: StringFilter<"StudentTeacherRelation"> | string
    status?: EnumRelationStatusFilter<"StudentTeacherRelation"> | $Enums.RelationStatus
    isCreator?: BoolFilter<"StudentTeacherRelation"> | boolean
    customName?: StringNullableFilter<"StudentTeacherRelation"> | string | null
    privateNotes?: StringNullableFilter<"StudentTeacherRelation"> | string | null
    createdAt?: DateTimeFilter<"StudentTeacherRelation"> | Date | string
    updatedAt?: DateTimeFilter<"StudentTeacherRelation"> | Date | string
    teacher?: XOR<TeacherProfileScalarRelationFilter, TeacherProfileWhereInput>
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
  }

  export type StudentTeacherRelationOrderByWithRelationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    isCreator?: SortOrder
    customName?: SortOrderInput | SortOrder
    privateNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacher?: TeacherProfileOrderByWithRelationInput
    student?: StudentProfileOrderByWithRelationInput
  }

  export type StudentTeacherRelationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teacherId_studentId?: StudentTeacherRelationTeacherIdStudentIdCompoundUniqueInput
    AND?: StudentTeacherRelationWhereInput | StudentTeacherRelationWhereInput[]
    OR?: StudentTeacherRelationWhereInput[]
    NOT?: StudentTeacherRelationWhereInput | StudentTeacherRelationWhereInput[]
    teacherId?: StringFilter<"StudentTeacherRelation"> | string
    studentId?: StringFilter<"StudentTeacherRelation"> | string
    status?: EnumRelationStatusFilter<"StudentTeacherRelation"> | $Enums.RelationStatus
    isCreator?: BoolFilter<"StudentTeacherRelation"> | boolean
    customName?: StringNullableFilter<"StudentTeacherRelation"> | string | null
    privateNotes?: StringNullableFilter<"StudentTeacherRelation"> | string | null
    createdAt?: DateTimeFilter<"StudentTeacherRelation"> | Date | string
    updatedAt?: DateTimeFilter<"StudentTeacherRelation"> | Date | string
    teacher?: XOR<TeacherProfileScalarRelationFilter, TeacherProfileWhereInput>
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
  }, "id" | "teacherId_studentId">

  export type StudentTeacherRelationOrderByWithAggregationInput = {
    id?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    isCreator?: SortOrder
    customName?: SortOrderInput | SortOrder
    privateNotes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: StudentTeacherRelationCountOrderByAggregateInput
    _max?: StudentTeacherRelationMaxOrderByAggregateInput
    _min?: StudentTeacherRelationMinOrderByAggregateInput
  }

  export type StudentTeacherRelationScalarWhereWithAggregatesInput = {
    AND?: StudentTeacherRelationScalarWhereWithAggregatesInput | StudentTeacherRelationScalarWhereWithAggregatesInput[]
    OR?: StudentTeacherRelationScalarWhereWithAggregatesInput[]
    NOT?: StudentTeacherRelationScalarWhereWithAggregatesInput | StudentTeacherRelationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"StudentTeacherRelation"> | string
    teacherId?: StringWithAggregatesFilter<"StudentTeacherRelation"> | string
    studentId?: StringWithAggregatesFilter<"StudentTeacherRelation"> | string
    status?: EnumRelationStatusWithAggregatesFilter<"StudentTeacherRelation"> | $Enums.RelationStatus
    isCreator?: BoolWithAggregatesFilter<"StudentTeacherRelation"> | boolean
    customName?: StringNullableWithAggregatesFilter<"StudentTeacherRelation"> | string | null
    privateNotes?: StringNullableWithAggregatesFilter<"StudentTeacherRelation"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"StudentTeacherRelation"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"StudentTeacherRelation"> | Date | string
  }

  export type ClassroomWhereInput = {
    AND?: ClassroomWhereInput | ClassroomWhereInput[]
    OR?: ClassroomWhereInput[]
    NOT?: ClassroomWhereInput | ClassroomWhereInput[]
    id?: StringFilter<"Classroom"> | string
    name?: StringFilter<"Classroom"> | string
    year?: IntFilter<"Classroom"> | number
    teacherId?: StringNullableFilter<"Classroom"> | string | null
    teacher?: XOR<TeacherProfileNullableScalarRelationFilter, TeacherProfileWhereInput> | null
    students?: StudentProfileListRelationFilter
    schedule?: ScheduleItemListRelationFilter
    lessons?: LessonListRelationFilter
  }

  export type ClassroomOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    teacher?: TeacherProfileOrderByWithRelationInput
    students?: StudentProfileOrderByRelationAggregateInput
    schedule?: ScheduleItemOrderByRelationAggregateInput
    lessons?: LessonOrderByRelationAggregateInput
  }

  export type ClassroomWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ClassroomWhereInput | ClassroomWhereInput[]
    OR?: ClassroomWhereInput[]
    NOT?: ClassroomWhereInput | ClassroomWhereInput[]
    name?: StringFilter<"Classroom"> | string
    year?: IntFilter<"Classroom"> | number
    teacherId?: StringNullableFilter<"Classroom"> | string | null
    teacher?: XOR<TeacherProfileNullableScalarRelationFilter, TeacherProfileWhereInput> | null
    students?: StudentProfileListRelationFilter
    schedule?: ScheduleItemListRelationFilter
    lessons?: LessonListRelationFilter
  }, "id">

  export type ClassroomOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    teacherId?: SortOrderInput | SortOrder
    _count?: ClassroomCountOrderByAggregateInput
    _avg?: ClassroomAvgOrderByAggregateInput
    _max?: ClassroomMaxOrderByAggregateInput
    _min?: ClassroomMinOrderByAggregateInput
    _sum?: ClassroomSumOrderByAggregateInput
  }

  export type ClassroomScalarWhereWithAggregatesInput = {
    AND?: ClassroomScalarWhereWithAggregatesInput | ClassroomScalarWhereWithAggregatesInput[]
    OR?: ClassroomScalarWhereWithAggregatesInput[]
    NOT?: ClassroomScalarWhereWithAggregatesInput | ClassroomScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Classroom"> | string
    name?: StringWithAggregatesFilter<"Classroom"> | string
    year?: IntWithAggregatesFilter<"Classroom"> | number
    teacherId?: StringNullableWithAggregatesFilter<"Classroom"> | string | null
  }

  export type ScheduleItemWhereInput = {
    AND?: ScheduleItemWhereInput | ScheduleItemWhereInput[]
    OR?: ScheduleItemWhereInput[]
    NOT?: ScheduleItemWhereInput | ScheduleItemWhereInput[]
    id?: StringFilter<"ScheduleItem"> | string
    dayOfWeek?: IntFilter<"ScheduleItem"> | number
    startTime?: StringFilter<"ScheduleItem"> | string
    endTime?: StringFilter<"ScheduleItem"> | string
    subject?: StringNullableFilter<"ScheduleItem"> | string | null
    type?: EnumLessonTypeFilter<"ScheduleItem"> | $Enums.LessonType
    location?: EnumLessonLocationFilter<"ScheduleItem"> | $Enums.LessonLocation
    locationUrl?: StringNullableFilter<"ScheduleItem"> | string | null
    address?: StringNullableFilter<"ScheduleItem"> | string | null
    price?: DecimalNullableFilter<"ScheduleItem"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"ScheduleItem"> | string
    teacherId?: StringFilter<"ScheduleItem"> | string
    classroomId?: StringNullableFilter<"ScheduleItem"> | string | null
    studentId?: StringNullableFilter<"ScheduleItem"> | string | null
    createdAt?: DateTimeFilter<"ScheduleItem"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleItem"> | Date | string
    teacher?: XOR<TeacherProfileScalarRelationFilter, TeacherProfileWhereInput>
    classroom?: XOR<ClassroomNullableScalarRelationFilter, ClassroomWhereInput> | null
    student?: XOR<StudentProfileNullableScalarRelationFilter, StudentProfileWhereInput> | null
    lessons?: LessonListRelationFilter
  }

  export type ScheduleItemOrderByWithRelationInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrderInput | SortOrder
    type?: SortOrder
    location?: SortOrder
    locationUrl?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrder
    teacherId?: SortOrder
    classroomId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    teacher?: TeacherProfileOrderByWithRelationInput
    classroom?: ClassroomOrderByWithRelationInput
    student?: StudentProfileOrderByWithRelationInput
    lessons?: LessonOrderByRelationAggregateInput
  }

  export type ScheduleItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ScheduleItemWhereInput | ScheduleItemWhereInput[]
    OR?: ScheduleItemWhereInput[]
    NOT?: ScheduleItemWhereInput | ScheduleItemWhereInput[]
    dayOfWeek?: IntFilter<"ScheduleItem"> | number
    startTime?: StringFilter<"ScheduleItem"> | string
    endTime?: StringFilter<"ScheduleItem"> | string
    subject?: StringNullableFilter<"ScheduleItem"> | string | null
    type?: EnumLessonTypeFilter<"ScheduleItem"> | $Enums.LessonType
    location?: EnumLessonLocationFilter<"ScheduleItem"> | $Enums.LessonLocation
    locationUrl?: StringNullableFilter<"ScheduleItem"> | string | null
    address?: StringNullableFilter<"ScheduleItem"> | string | null
    price?: DecimalNullableFilter<"ScheduleItem"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"ScheduleItem"> | string
    teacherId?: StringFilter<"ScheduleItem"> | string
    classroomId?: StringNullableFilter<"ScheduleItem"> | string | null
    studentId?: StringNullableFilter<"ScheduleItem"> | string | null
    createdAt?: DateTimeFilter<"ScheduleItem"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleItem"> | Date | string
    teacher?: XOR<TeacherProfileScalarRelationFilter, TeacherProfileWhereInput>
    classroom?: XOR<ClassroomNullableScalarRelationFilter, ClassroomWhereInput> | null
    student?: XOR<StudentProfileNullableScalarRelationFilter, StudentProfileWhereInput> | null
    lessons?: LessonListRelationFilter
  }, "id">

  export type ScheduleItemOrderByWithAggregationInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrderInput | SortOrder
    type?: SortOrder
    location?: SortOrder
    locationUrl?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrder
    teacherId?: SortOrder
    classroomId?: SortOrderInput | SortOrder
    studentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ScheduleItemCountOrderByAggregateInput
    _avg?: ScheduleItemAvgOrderByAggregateInput
    _max?: ScheduleItemMaxOrderByAggregateInput
    _min?: ScheduleItemMinOrderByAggregateInput
    _sum?: ScheduleItemSumOrderByAggregateInput
  }

  export type ScheduleItemScalarWhereWithAggregatesInput = {
    AND?: ScheduleItemScalarWhereWithAggregatesInput | ScheduleItemScalarWhereWithAggregatesInput[]
    OR?: ScheduleItemScalarWhereWithAggregatesInput[]
    NOT?: ScheduleItemScalarWhereWithAggregatesInput | ScheduleItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ScheduleItem"> | string
    dayOfWeek?: IntWithAggregatesFilter<"ScheduleItem"> | number
    startTime?: StringWithAggregatesFilter<"ScheduleItem"> | string
    endTime?: StringWithAggregatesFilter<"ScheduleItem"> | string
    subject?: StringNullableWithAggregatesFilter<"ScheduleItem"> | string | null
    type?: EnumLessonTypeWithAggregatesFilter<"ScheduleItem"> | $Enums.LessonType
    location?: EnumLessonLocationWithAggregatesFilter<"ScheduleItem"> | $Enums.LessonLocation
    locationUrl?: StringNullableWithAggregatesFilter<"ScheduleItem"> | string | null
    address?: StringNullableWithAggregatesFilter<"ScheduleItem"> | string | null
    price?: DecimalNullableWithAggregatesFilter<"ScheduleItem"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"ScheduleItem"> | string
    teacherId?: StringWithAggregatesFilter<"ScheduleItem"> | string
    classroomId?: StringNullableWithAggregatesFilter<"ScheduleItem"> | string | null
    studentId?: StringNullableWithAggregatesFilter<"ScheduleItem"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ScheduleItem"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"ScheduleItem"> | Date | string
  }

  export type LessonWhereInput = {
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    id?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    startTime?: DateTimeFilter<"Lesson"> | Date | string
    endTime?: DateTimeFilter<"Lesson"> | Date | string
    scheduleItemId?: StringNullableFilter<"Lesson"> | string | null
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    status?: EnumLessonStatusFilter<"Lesson"> | $Enums.LessonStatus
    cancelReason?: StringNullableFilter<"Lesson"> | string | null
    location?: EnumLessonLocationFilter<"Lesson"> | $Enums.LessonLocation
    locationUrl?: StringNullableFilter<"Lesson"> | string | null
    address?: StringNullableFilter<"Lesson"> | string | null
    publicNote?: StringNullableFilter<"Lesson"> | string | null
    privateNote?: StringNullableFilter<"Lesson"> | string | null
    price?: DecimalNullableFilter<"Lesson"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Lesson"> | string
    isPaid?: BoolFilter<"Lesson"> | boolean
    teacherId?: StringFilter<"Lesson"> | string
    classroomId?: StringNullableFilter<"Lesson"> | string | null
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    scheduleItem?: XOR<ScheduleItemNullableScalarRelationFilter, ScheduleItemWhereInput> | null
    teacher?: XOR<TeacherProfileScalarRelationFilter, TeacherProfileWhereInput>
    students?: StudentProfileListRelationFilter
    classroom?: XOR<ClassroomNullableScalarRelationFilter, ClassroomWhereInput> | null
    attendances?: AttendanceListRelationFilter
    homeworks?: HomeworkListRelationFilter
    materials?: MaterialListRelationFilter
    payments?: PaymentListRelationFilter
  }

  export type LessonOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    scheduleItemId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    cancelReason?: SortOrderInput | SortOrder
    location?: SortOrder
    locationUrl?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    publicNote?: SortOrderInput | SortOrder
    privateNote?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrder
    isPaid?: SortOrder
    teacherId?: SortOrder
    classroomId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    scheduleItem?: ScheduleItemOrderByWithRelationInput
    teacher?: TeacherProfileOrderByWithRelationInput
    students?: StudentProfileOrderByRelationAggregateInput
    classroom?: ClassroomOrderByWithRelationInput
    attendances?: AttendanceOrderByRelationAggregateInput
    homeworks?: HomeworkOrderByRelationAggregateInput
    materials?: MaterialOrderByRelationAggregateInput
    payments?: PaymentOrderByRelationAggregateInput
  }

  export type LessonWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LessonWhereInput | LessonWhereInput[]
    OR?: LessonWhereInput[]
    NOT?: LessonWhereInput | LessonWhereInput[]
    title?: StringFilter<"Lesson"> | string
    startTime?: DateTimeFilter<"Lesson"> | Date | string
    endTime?: DateTimeFilter<"Lesson"> | Date | string
    scheduleItemId?: StringNullableFilter<"Lesson"> | string | null
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    status?: EnumLessonStatusFilter<"Lesson"> | $Enums.LessonStatus
    cancelReason?: StringNullableFilter<"Lesson"> | string | null
    location?: EnumLessonLocationFilter<"Lesson"> | $Enums.LessonLocation
    locationUrl?: StringNullableFilter<"Lesson"> | string | null
    address?: StringNullableFilter<"Lesson"> | string | null
    publicNote?: StringNullableFilter<"Lesson"> | string | null
    privateNote?: StringNullableFilter<"Lesson"> | string | null
    price?: DecimalNullableFilter<"Lesson"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Lesson"> | string
    isPaid?: BoolFilter<"Lesson"> | boolean
    teacherId?: StringFilter<"Lesson"> | string
    classroomId?: StringNullableFilter<"Lesson"> | string | null
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
    scheduleItem?: XOR<ScheduleItemNullableScalarRelationFilter, ScheduleItemWhereInput> | null
    teacher?: XOR<TeacherProfileScalarRelationFilter, TeacherProfileWhereInput>
    students?: StudentProfileListRelationFilter
    classroom?: XOR<ClassroomNullableScalarRelationFilter, ClassroomWhereInput> | null
    attendances?: AttendanceListRelationFilter
    homeworks?: HomeworkListRelationFilter
    materials?: MaterialListRelationFilter
    payments?: PaymentListRelationFilter
  }, "id">

  export type LessonOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    scheduleItemId?: SortOrderInput | SortOrder
    type?: SortOrder
    status?: SortOrder
    cancelReason?: SortOrderInput | SortOrder
    location?: SortOrder
    locationUrl?: SortOrderInput | SortOrder
    address?: SortOrderInput | SortOrder
    publicNote?: SortOrderInput | SortOrder
    privateNote?: SortOrderInput | SortOrder
    price?: SortOrderInput | SortOrder
    currency?: SortOrder
    isPaid?: SortOrder
    teacherId?: SortOrder
    classroomId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LessonCountOrderByAggregateInput
    _avg?: LessonAvgOrderByAggregateInput
    _max?: LessonMaxOrderByAggregateInput
    _min?: LessonMinOrderByAggregateInput
    _sum?: LessonSumOrderByAggregateInput
  }

  export type LessonScalarWhereWithAggregatesInput = {
    AND?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    OR?: LessonScalarWhereWithAggregatesInput[]
    NOT?: LessonScalarWhereWithAggregatesInput | LessonScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Lesson"> | string
    title?: StringWithAggregatesFilter<"Lesson"> | string
    startTime?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    endTime?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    scheduleItemId?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    type?: EnumLessonTypeWithAggregatesFilter<"Lesson"> | $Enums.LessonType
    status?: EnumLessonStatusWithAggregatesFilter<"Lesson"> | $Enums.LessonStatus
    cancelReason?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    location?: EnumLessonLocationWithAggregatesFilter<"Lesson"> | $Enums.LessonLocation
    locationUrl?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    address?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    publicNote?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    privateNote?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    price?: DecimalNullableWithAggregatesFilter<"Lesson"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"Lesson"> | string
    isPaid?: BoolWithAggregatesFilter<"Lesson"> | boolean
    teacherId?: StringWithAggregatesFilter<"Lesson"> | string
    classroomId?: StringNullableWithAggregatesFilter<"Lesson"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Lesson"> | Date | string
  }

  export type MaterialWhereInput = {
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    id?: StringFilter<"Material"> | string
    title?: StringFilter<"Material"> | string
    fileId?: StringNullableFilter<"Material"> | string | null
    linkUrl?: StringNullableFilter<"Material"> | string | null
    type?: EnumFileTypeFilter<"Material"> | $Enums.FileType
    lessonId?: StringFilter<"Material"> | string
    createdAt?: DateTimeFilter<"Material"> | Date | string
    file?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }

  export type MaterialOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    fileId?: SortOrderInput | SortOrder
    linkUrl?: SortOrderInput | SortOrder
    type?: SortOrder
    lessonId?: SortOrder
    createdAt?: SortOrder
    file?: FileOrderByWithRelationInput
    lesson?: LessonOrderByWithRelationInput
  }

  export type MaterialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MaterialWhereInput | MaterialWhereInput[]
    OR?: MaterialWhereInput[]
    NOT?: MaterialWhereInput | MaterialWhereInput[]
    title?: StringFilter<"Material"> | string
    fileId?: StringNullableFilter<"Material"> | string | null
    linkUrl?: StringNullableFilter<"Material"> | string | null
    type?: EnumFileTypeFilter<"Material"> | $Enums.FileType
    lessonId?: StringFilter<"Material"> | string
    createdAt?: DateTimeFilter<"Material"> | Date | string
    file?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
  }, "id">

  export type MaterialOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    fileId?: SortOrderInput | SortOrder
    linkUrl?: SortOrderInput | SortOrder
    type?: SortOrder
    lessonId?: SortOrder
    createdAt?: SortOrder
    _count?: MaterialCountOrderByAggregateInput
    _max?: MaterialMaxOrderByAggregateInput
    _min?: MaterialMinOrderByAggregateInput
  }

  export type MaterialScalarWhereWithAggregatesInput = {
    AND?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    OR?: MaterialScalarWhereWithAggregatesInput[]
    NOT?: MaterialScalarWhereWithAggregatesInput | MaterialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Material"> | string
    title?: StringWithAggregatesFilter<"Material"> | string
    fileId?: StringNullableWithAggregatesFilter<"Material"> | string | null
    linkUrl?: StringNullableWithAggregatesFilter<"Material"> | string | null
    type?: EnumFileTypeWithAggregatesFilter<"Material"> | $Enums.FileType
    lessonId?: StringWithAggregatesFilter<"Material"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Material"> | Date | string
  }

  export type HomeworkWhereInput = {
    AND?: HomeworkWhereInput | HomeworkWhereInput[]
    OR?: HomeworkWhereInput[]
    NOT?: HomeworkWhereInput | HomeworkWhereInput[]
    id?: StringFilter<"Homework"> | string
    title?: StringFilter<"Homework"> | string
    content?: StringNullableFilter<"Homework"> | string | null
    assignedDate?: DateTimeFilter<"Homework"> | Date | string
    dueDate?: DateTimeFilter<"Homework"> | Date | string
    lessonId?: StringFilter<"Homework"> | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    trackings?: HomeworkTrackingListRelationFilter
  }

  export type HomeworkOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    assignedDate?: SortOrder
    dueDate?: SortOrder
    lessonId?: SortOrder
    lesson?: LessonOrderByWithRelationInput
    trackings?: HomeworkTrackingOrderByRelationAggregateInput
  }

  export type HomeworkWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HomeworkWhereInput | HomeworkWhereInput[]
    OR?: HomeworkWhereInput[]
    NOT?: HomeworkWhereInput | HomeworkWhereInput[]
    title?: StringFilter<"Homework"> | string
    content?: StringNullableFilter<"Homework"> | string | null
    assignedDate?: DateTimeFilter<"Homework"> | Date | string
    dueDate?: DateTimeFilter<"Homework"> | Date | string
    lessonId?: StringFilter<"Homework"> | string
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    trackings?: HomeworkTrackingListRelationFilter
  }, "id">

  export type HomeworkOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrderInput | SortOrder
    assignedDate?: SortOrder
    dueDate?: SortOrder
    lessonId?: SortOrder
    _count?: HomeworkCountOrderByAggregateInput
    _max?: HomeworkMaxOrderByAggregateInput
    _min?: HomeworkMinOrderByAggregateInput
  }

  export type HomeworkScalarWhereWithAggregatesInput = {
    AND?: HomeworkScalarWhereWithAggregatesInput | HomeworkScalarWhereWithAggregatesInput[]
    OR?: HomeworkScalarWhereWithAggregatesInput[]
    NOT?: HomeworkScalarWhereWithAggregatesInput | HomeworkScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Homework"> | string
    title?: StringWithAggregatesFilter<"Homework"> | string
    content?: StringNullableWithAggregatesFilter<"Homework"> | string | null
    assignedDate?: DateTimeWithAggregatesFilter<"Homework"> | Date | string
    dueDate?: DateTimeWithAggregatesFilter<"Homework"> | Date | string
    lessonId?: StringWithAggregatesFilter<"Homework"> | string
  }

  export type HomeworkTrackingWhereInput = {
    AND?: HomeworkTrackingWhereInput | HomeworkTrackingWhereInput[]
    OR?: HomeworkTrackingWhereInput[]
    NOT?: HomeworkTrackingWhereInput | HomeworkTrackingWhereInput[]
    id?: StringFilter<"HomeworkTracking"> | string
    homeworkId?: StringFilter<"HomeworkTracking"> | string
    studentId?: StringFilter<"HomeworkTracking"> | string
    status?: EnumHomeworkStatusFilter<"HomeworkTracking"> | $Enums.HomeworkStatus
    studentNote?: StringNullableFilter<"HomeworkTracking"> | string | null
    teacherNote?: StringNullableFilter<"HomeworkTracking"> | string | null
    fileId?: StringNullableFilter<"HomeworkTracking"> | string | null
    checkedAt?: DateTimeNullableFilter<"HomeworkTracking"> | Date | string | null
    file?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
    homework?: XOR<HomeworkScalarRelationFilter, HomeworkWhereInput>
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
  }

  export type HomeworkTrackingOrderByWithRelationInput = {
    id?: SortOrder
    homeworkId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    studentNote?: SortOrderInput | SortOrder
    teacherNote?: SortOrderInput | SortOrder
    fileId?: SortOrderInput | SortOrder
    checkedAt?: SortOrderInput | SortOrder
    file?: FileOrderByWithRelationInput
    homework?: HomeworkOrderByWithRelationInput
    student?: StudentProfileOrderByWithRelationInput
  }

  export type HomeworkTrackingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HomeworkTrackingWhereInput | HomeworkTrackingWhereInput[]
    OR?: HomeworkTrackingWhereInput[]
    NOT?: HomeworkTrackingWhereInput | HomeworkTrackingWhereInput[]
    homeworkId?: StringFilter<"HomeworkTracking"> | string
    studentId?: StringFilter<"HomeworkTracking"> | string
    status?: EnumHomeworkStatusFilter<"HomeworkTracking"> | $Enums.HomeworkStatus
    studentNote?: StringNullableFilter<"HomeworkTracking"> | string | null
    teacherNote?: StringNullableFilter<"HomeworkTracking"> | string | null
    fileId?: StringNullableFilter<"HomeworkTracking"> | string | null
    checkedAt?: DateTimeNullableFilter<"HomeworkTracking"> | Date | string | null
    file?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
    homework?: XOR<HomeworkScalarRelationFilter, HomeworkWhereInput>
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
  }, "id">

  export type HomeworkTrackingOrderByWithAggregationInput = {
    id?: SortOrder
    homeworkId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    studentNote?: SortOrderInput | SortOrder
    teacherNote?: SortOrderInput | SortOrder
    fileId?: SortOrderInput | SortOrder
    checkedAt?: SortOrderInput | SortOrder
    _count?: HomeworkTrackingCountOrderByAggregateInput
    _max?: HomeworkTrackingMaxOrderByAggregateInput
    _min?: HomeworkTrackingMinOrderByAggregateInput
  }

  export type HomeworkTrackingScalarWhereWithAggregatesInput = {
    AND?: HomeworkTrackingScalarWhereWithAggregatesInput | HomeworkTrackingScalarWhereWithAggregatesInput[]
    OR?: HomeworkTrackingScalarWhereWithAggregatesInput[]
    NOT?: HomeworkTrackingScalarWhereWithAggregatesInput | HomeworkTrackingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HomeworkTracking"> | string
    homeworkId?: StringWithAggregatesFilter<"HomeworkTracking"> | string
    studentId?: StringWithAggregatesFilter<"HomeworkTracking"> | string
    status?: EnumHomeworkStatusWithAggregatesFilter<"HomeworkTracking"> | $Enums.HomeworkStatus
    studentNote?: StringNullableWithAggregatesFilter<"HomeworkTracking"> | string | null
    teacherNote?: StringNullableWithAggregatesFilter<"HomeworkTracking"> | string | null
    fileId?: StringNullableWithAggregatesFilter<"HomeworkTracking"> | string | null
    checkedAt?: DateTimeNullableWithAggregatesFilter<"HomeworkTracking"> | Date | string | null
  }

  export type HomeworkSubmissionWhereInput = {
    AND?: HomeworkSubmissionWhereInput | HomeworkSubmissionWhereInput[]
    OR?: HomeworkSubmissionWhereInput[]
    NOT?: HomeworkSubmissionWhereInput | HomeworkSubmissionWhereInput[]
    id?: StringFilter<"HomeworkSubmission"> | string
    fileId?: StringNullableFilter<"HomeworkSubmission"> | string | null
    note?: StringNullableFilter<"HomeworkSubmission"> | string | null
    submittedAt?: DateTimeFilter<"HomeworkSubmission"> | Date | string
    studentId?: StringFilter<"HomeworkSubmission"> | string
    file?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
  }

  export type HomeworkSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    fileId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    studentId?: SortOrder
    file?: FileOrderByWithRelationInput
    student?: StudentProfileOrderByWithRelationInput
  }

  export type HomeworkSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HomeworkSubmissionWhereInput | HomeworkSubmissionWhereInput[]
    OR?: HomeworkSubmissionWhereInput[]
    NOT?: HomeworkSubmissionWhereInput | HomeworkSubmissionWhereInput[]
    fileId?: StringNullableFilter<"HomeworkSubmission"> | string | null
    note?: StringNullableFilter<"HomeworkSubmission"> | string | null
    submittedAt?: DateTimeFilter<"HomeworkSubmission"> | Date | string
    studentId?: StringFilter<"HomeworkSubmission"> | string
    file?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
  }, "id">

  export type HomeworkSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    fileId?: SortOrderInput | SortOrder
    note?: SortOrderInput | SortOrder
    submittedAt?: SortOrder
    studentId?: SortOrder
    _count?: HomeworkSubmissionCountOrderByAggregateInput
    _max?: HomeworkSubmissionMaxOrderByAggregateInput
    _min?: HomeworkSubmissionMinOrderByAggregateInput
  }

  export type HomeworkSubmissionScalarWhereWithAggregatesInput = {
    AND?: HomeworkSubmissionScalarWhereWithAggregatesInput | HomeworkSubmissionScalarWhereWithAggregatesInput[]
    OR?: HomeworkSubmissionScalarWhereWithAggregatesInput[]
    NOT?: HomeworkSubmissionScalarWhereWithAggregatesInput | HomeworkSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HomeworkSubmission"> | string
    fileId?: StringNullableWithAggregatesFilter<"HomeworkSubmission"> | string | null
    note?: StringNullableWithAggregatesFilter<"HomeworkSubmission"> | string | null
    submittedAt?: DateTimeWithAggregatesFilter<"HomeworkSubmission"> | Date | string
    studentId?: StringWithAggregatesFilter<"HomeworkSubmission"> | string
  }

  export type SchoolExamWhereInput = {
    AND?: SchoolExamWhereInput | SchoolExamWhereInput[]
    OR?: SchoolExamWhereInput[]
    NOT?: SchoolExamWhereInput | SchoolExamWhereInput[]
    id?: StringFilter<"SchoolExam"> | string
    title?: StringFilter<"SchoolExam"> | string
    score?: FloatFilter<"SchoolExam"> | number
    date?: DateTimeFilter<"SchoolExam"> | Date | string
    subject?: StringFilter<"SchoolExam"> | string
    studentId?: StringFilter<"SchoolExam"> | string
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
  }

  export type SchoolExamOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    score?: SortOrder
    date?: SortOrder
    subject?: SortOrder
    studentId?: SortOrder
    student?: StudentProfileOrderByWithRelationInput
  }

  export type SchoolExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SchoolExamWhereInput | SchoolExamWhereInput[]
    OR?: SchoolExamWhereInput[]
    NOT?: SchoolExamWhereInput | SchoolExamWhereInput[]
    title?: StringFilter<"SchoolExam"> | string
    score?: FloatFilter<"SchoolExam"> | number
    date?: DateTimeFilter<"SchoolExam"> | Date | string
    subject?: StringFilter<"SchoolExam"> | string
    studentId?: StringFilter<"SchoolExam"> | string
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
  }, "id">

  export type SchoolExamOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    score?: SortOrder
    date?: SortOrder
    subject?: SortOrder
    studentId?: SortOrder
    _count?: SchoolExamCountOrderByAggregateInput
    _avg?: SchoolExamAvgOrderByAggregateInput
    _max?: SchoolExamMaxOrderByAggregateInput
    _min?: SchoolExamMinOrderByAggregateInput
    _sum?: SchoolExamSumOrderByAggregateInput
  }

  export type SchoolExamScalarWhereWithAggregatesInput = {
    AND?: SchoolExamScalarWhereWithAggregatesInput | SchoolExamScalarWhereWithAggregatesInput[]
    OR?: SchoolExamScalarWhereWithAggregatesInput[]
    NOT?: SchoolExamScalarWhereWithAggregatesInput | SchoolExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SchoolExam"> | string
    title?: StringWithAggregatesFilter<"SchoolExam"> | string
    score?: FloatWithAggregatesFilter<"SchoolExam"> | number
    date?: DateTimeWithAggregatesFilter<"SchoolExam"> | Date | string
    subject?: StringWithAggregatesFilter<"SchoolExam"> | string
    studentId?: StringWithAggregatesFilter<"SchoolExam"> | string
  }

  export type TrialExamWhereInput = {
    AND?: TrialExamWhereInput | TrialExamWhereInput[]
    OR?: TrialExamWhereInput[]
    NOT?: TrialExamWhereInput | TrialExamWhereInput[]
    id?: StringFilter<"TrialExam"> | string
    title?: StringFilter<"TrialExam"> | string
    date?: DateTimeFilter<"TrialExam"> | Date | string
    category?: EnumExamCategoryFilter<"TrialExam"> | $Enums.ExamCategory
    publisher?: StringNullableFilter<"TrialExam"> | string | null
    studentId?: StringFilter<"TrialExam"> | string
    totalNet?: FloatNullableFilter<"TrialExam"> | number | null
    totalScore?: FloatNullableFilter<"TrialExam"> | number | null
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
    results?: TrialExamResultListRelationFilter
  }

  export type TrialExamOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    category?: SortOrder
    publisher?: SortOrderInput | SortOrder
    studentId?: SortOrder
    totalNet?: SortOrderInput | SortOrder
    totalScore?: SortOrderInput | SortOrder
    student?: StudentProfileOrderByWithRelationInput
    results?: TrialExamResultOrderByRelationAggregateInput
  }

  export type TrialExamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrialExamWhereInput | TrialExamWhereInput[]
    OR?: TrialExamWhereInput[]
    NOT?: TrialExamWhereInput | TrialExamWhereInput[]
    title?: StringFilter<"TrialExam"> | string
    date?: DateTimeFilter<"TrialExam"> | Date | string
    category?: EnumExamCategoryFilter<"TrialExam"> | $Enums.ExamCategory
    publisher?: StringNullableFilter<"TrialExam"> | string | null
    studentId?: StringFilter<"TrialExam"> | string
    totalNet?: FloatNullableFilter<"TrialExam"> | number | null
    totalScore?: FloatNullableFilter<"TrialExam"> | number | null
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
    results?: TrialExamResultListRelationFilter
  }, "id">

  export type TrialExamOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    category?: SortOrder
    publisher?: SortOrderInput | SortOrder
    studentId?: SortOrder
    totalNet?: SortOrderInput | SortOrder
    totalScore?: SortOrderInput | SortOrder
    _count?: TrialExamCountOrderByAggregateInput
    _avg?: TrialExamAvgOrderByAggregateInput
    _max?: TrialExamMaxOrderByAggregateInput
    _min?: TrialExamMinOrderByAggregateInput
    _sum?: TrialExamSumOrderByAggregateInput
  }

  export type TrialExamScalarWhereWithAggregatesInput = {
    AND?: TrialExamScalarWhereWithAggregatesInput | TrialExamScalarWhereWithAggregatesInput[]
    OR?: TrialExamScalarWhereWithAggregatesInput[]
    NOT?: TrialExamScalarWhereWithAggregatesInput | TrialExamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrialExam"> | string
    title?: StringWithAggregatesFilter<"TrialExam"> | string
    date?: DateTimeWithAggregatesFilter<"TrialExam"> | Date | string
    category?: EnumExamCategoryWithAggregatesFilter<"TrialExam"> | $Enums.ExamCategory
    publisher?: StringNullableWithAggregatesFilter<"TrialExam"> | string | null
    studentId?: StringWithAggregatesFilter<"TrialExam"> | string
    totalNet?: FloatNullableWithAggregatesFilter<"TrialExam"> | number | null
    totalScore?: FloatNullableWithAggregatesFilter<"TrialExam"> | number | null
  }

  export type TrialExamResultWhereInput = {
    AND?: TrialExamResultWhereInput | TrialExamResultWhereInput[]
    OR?: TrialExamResultWhereInput[]
    NOT?: TrialExamResultWhereInput | TrialExamResultWhereInput[]
    id?: StringFilter<"TrialExamResult"> | string
    trialExamId?: StringFilter<"TrialExamResult"> | string
    lessonName?: StringFilter<"TrialExamResult"> | string
    correctCount?: IntFilter<"TrialExamResult"> | number
    incorrectCount?: IntFilter<"TrialExamResult"> | number
    emptyCount?: IntFilter<"TrialExamResult"> | number
    net?: FloatFilter<"TrialExamResult"> | number
    mistakeTopics?: StringNullableListFilter<"TrialExamResult">
    mistakeAnalysis?: StringNullableFilter<"TrialExamResult"> | string | null
    trialExam?: XOR<TrialExamScalarRelationFilter, TrialExamWhereInput>
  }

  export type TrialExamResultOrderByWithRelationInput = {
    id?: SortOrder
    trialExamId?: SortOrder
    lessonName?: SortOrder
    correctCount?: SortOrder
    incorrectCount?: SortOrder
    emptyCount?: SortOrder
    net?: SortOrder
    mistakeTopics?: SortOrder
    mistakeAnalysis?: SortOrderInput | SortOrder
    trialExam?: TrialExamOrderByWithRelationInput
  }

  export type TrialExamResultWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TrialExamResultWhereInput | TrialExamResultWhereInput[]
    OR?: TrialExamResultWhereInput[]
    NOT?: TrialExamResultWhereInput | TrialExamResultWhereInput[]
    trialExamId?: StringFilter<"TrialExamResult"> | string
    lessonName?: StringFilter<"TrialExamResult"> | string
    correctCount?: IntFilter<"TrialExamResult"> | number
    incorrectCount?: IntFilter<"TrialExamResult"> | number
    emptyCount?: IntFilter<"TrialExamResult"> | number
    net?: FloatFilter<"TrialExamResult"> | number
    mistakeTopics?: StringNullableListFilter<"TrialExamResult">
    mistakeAnalysis?: StringNullableFilter<"TrialExamResult"> | string | null
    trialExam?: XOR<TrialExamScalarRelationFilter, TrialExamWhereInput>
  }, "id">

  export type TrialExamResultOrderByWithAggregationInput = {
    id?: SortOrder
    trialExamId?: SortOrder
    lessonName?: SortOrder
    correctCount?: SortOrder
    incorrectCount?: SortOrder
    emptyCount?: SortOrder
    net?: SortOrder
    mistakeTopics?: SortOrder
    mistakeAnalysis?: SortOrderInput | SortOrder
    _count?: TrialExamResultCountOrderByAggregateInput
    _avg?: TrialExamResultAvgOrderByAggregateInput
    _max?: TrialExamResultMaxOrderByAggregateInput
    _min?: TrialExamResultMinOrderByAggregateInput
    _sum?: TrialExamResultSumOrderByAggregateInput
  }

  export type TrialExamResultScalarWhereWithAggregatesInput = {
    AND?: TrialExamResultScalarWhereWithAggregatesInput | TrialExamResultScalarWhereWithAggregatesInput[]
    OR?: TrialExamResultScalarWhereWithAggregatesInput[]
    NOT?: TrialExamResultScalarWhereWithAggregatesInput | TrialExamResultScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TrialExamResult"> | string
    trialExamId?: StringWithAggregatesFilter<"TrialExamResult"> | string
    lessonName?: StringWithAggregatesFilter<"TrialExamResult"> | string
    correctCount?: IntWithAggregatesFilter<"TrialExamResult"> | number
    incorrectCount?: IntWithAggregatesFilter<"TrialExamResult"> | number
    emptyCount?: IntWithAggregatesFilter<"TrialExamResult"> | number
    net?: FloatWithAggregatesFilter<"TrialExamResult"> | number
    mistakeTopics?: StringNullableListFilter<"TrialExamResult">
    mistakeAnalysis?: StringNullableWithAggregatesFilter<"TrialExamResult"> | string | null
  }

  export type AttendanceWhereInput = {
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    id?: StringFilter<"Attendance"> | string
    lessonId?: StringFilter<"Attendance"> | string
    studentId?: StringFilter<"Attendance"> | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    note?: StringNullableFilter<"Attendance"> | string | null
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
  }

  export type AttendanceOrderByWithRelationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    lesson?: LessonOrderByWithRelationInput
    student?: StudentProfileOrderByWithRelationInput
  }

  export type AttendanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceWhereInput | AttendanceWhereInput[]
    OR?: AttendanceWhereInput[]
    NOT?: AttendanceWhereInput | AttendanceWhereInput[]
    lessonId?: StringFilter<"Attendance"> | string
    studentId?: StringFilter<"Attendance"> | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    note?: StringNullableFilter<"Attendance"> | string | null
    lesson?: XOR<LessonScalarRelationFilter, LessonWhereInput>
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
  }, "id">

  export type AttendanceOrderByWithAggregationInput = {
    id?: SortOrder
    lessonId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    note?: SortOrderInput | SortOrder
    _count?: AttendanceCountOrderByAggregateInput
    _max?: AttendanceMaxOrderByAggregateInput
    _min?: AttendanceMinOrderByAggregateInput
  }

  export type AttendanceScalarWhereWithAggregatesInput = {
    AND?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    OR?: AttendanceScalarWhereWithAggregatesInput[]
    NOT?: AttendanceScalarWhereWithAggregatesInput | AttendanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Attendance"> | string
    lessonId?: StringWithAggregatesFilter<"Attendance"> | string
    studentId?: StringWithAggregatesFilter<"Attendance"> | string
    status?: EnumAttendanceStatusWithAggregatesFilter<"Attendance"> | $Enums.AttendanceStatus
    note?: StringNullableWithAggregatesFilter<"Attendance"> | string | null
  }

  export type PaymentWhereInput = {
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"Payment"> | Date | string
    type?: EnumPaymentTypeFilter<"Payment"> | $Enums.PaymentType
    note?: StringNullableFilter<"Payment"> | string | null
    isVisibleToStudent?: BoolFilter<"Payment"> | boolean
    studentId?: StringFilter<"Payment"> | string
    teacherId?: StringFilter<"Payment"> | string
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
    teacher?: XOR<TeacherProfileScalarRelationFilter, TeacherProfileWhereInput>
    lessons?: LessonListRelationFilter
  }

  export type PaymentOrderByWithRelationInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    type?: SortOrder
    note?: SortOrderInput | SortOrder
    isVisibleToStudent?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
    student?: StudentProfileOrderByWithRelationInput
    teacher?: TeacherProfileOrderByWithRelationInput
    lessons?: LessonOrderByRelationAggregateInput
  }

  export type PaymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PaymentWhereInput | PaymentWhereInput[]
    OR?: PaymentWhereInput[]
    NOT?: PaymentWhereInput | PaymentWhereInput[]
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"Payment"> | Date | string
    type?: EnumPaymentTypeFilter<"Payment"> | $Enums.PaymentType
    note?: StringNullableFilter<"Payment"> | string | null
    isVisibleToStudent?: BoolFilter<"Payment"> | boolean
    studentId?: StringFilter<"Payment"> | string
    teacherId?: StringFilter<"Payment"> | string
    student?: XOR<StudentProfileScalarRelationFilter, StudentProfileWhereInput>
    teacher?: XOR<TeacherProfileScalarRelationFilter, TeacherProfileWhereInput>
    lessons?: LessonListRelationFilter
  }, "id">

  export type PaymentOrderByWithAggregationInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    type?: SortOrder
    note?: SortOrderInput | SortOrder
    isVisibleToStudent?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
    _count?: PaymentCountOrderByAggregateInput
    _avg?: PaymentAvgOrderByAggregateInput
    _max?: PaymentMaxOrderByAggregateInput
    _min?: PaymentMinOrderByAggregateInput
    _sum?: PaymentSumOrderByAggregateInput
  }

  export type PaymentScalarWhereWithAggregatesInput = {
    AND?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    OR?: PaymentScalarWhereWithAggregatesInput[]
    NOT?: PaymentScalarWhereWithAggregatesInput | PaymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Payment"> | string
    amount?: DecimalWithAggregatesFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeWithAggregatesFilter<"Payment"> | Date | string
    type?: EnumPaymentTypeWithAggregatesFilter<"Payment"> | $Enums.PaymentType
    note?: StringNullableWithAggregatesFilter<"Payment"> | string | null
    isVisibleToStudent?: BoolWithAggregatesFilter<"Payment"> | boolean
    studentId?: StringWithAggregatesFilter<"Payment"> | string
    teacherId?: StringWithAggregatesFilter<"Payment"> | string
  }

  export type TodoWhereInput = {
    AND?: TodoWhereInput | TodoWhereInput[]
    OR?: TodoWhereInput[]
    NOT?: TodoWhereInput | TodoWhereInput[]
    id?: StringFilter<"Todo"> | string
    content?: StringFilter<"Todo"> | string
    isCompleted?: BoolFilter<"Todo"> | boolean
    dueDate?: DateTimeNullableFilter<"Todo"> | Date | string | null
    reminderTime?: DateTimeNullableFilter<"Todo"> | Date | string | null
    priority?: EnumPriorityFilter<"Todo"> | $Enums.Priority
    userId?: StringFilter<"Todo"> | string
    createdAt?: DateTimeFilter<"Todo"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type TodoOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrder
    isCompleted?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    reminderTime?: SortOrderInput | SortOrder
    priority?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type TodoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TodoWhereInput | TodoWhereInput[]
    OR?: TodoWhereInput[]
    NOT?: TodoWhereInput | TodoWhereInput[]
    content?: StringFilter<"Todo"> | string
    isCompleted?: BoolFilter<"Todo"> | boolean
    dueDate?: DateTimeNullableFilter<"Todo"> | Date | string | null
    reminderTime?: DateTimeNullableFilter<"Todo"> | Date | string | null
    priority?: EnumPriorityFilter<"Todo"> | $Enums.Priority
    userId?: StringFilter<"Todo"> | string
    createdAt?: DateTimeFilter<"Todo"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type TodoOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrder
    isCompleted?: SortOrder
    dueDate?: SortOrderInput | SortOrder
    reminderTime?: SortOrderInput | SortOrder
    priority?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: TodoCountOrderByAggregateInput
    _max?: TodoMaxOrderByAggregateInput
    _min?: TodoMinOrderByAggregateInput
  }

  export type TodoScalarWhereWithAggregatesInput = {
    AND?: TodoScalarWhereWithAggregatesInput | TodoScalarWhereWithAggregatesInput[]
    OR?: TodoScalarWhereWithAggregatesInput[]
    NOT?: TodoScalarWhereWithAggregatesInput | TodoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Todo"> | string
    content?: StringWithAggregatesFilter<"Todo"> | string
    isCompleted?: BoolWithAggregatesFilter<"Todo"> | boolean
    dueDate?: DateTimeNullableWithAggregatesFilter<"Todo"> | Date | string | null
    reminderTime?: DateTimeNullableWithAggregatesFilter<"Todo"> | Date | string | null
    priority?: EnumPriorityWithAggregatesFilter<"Todo"> | $Enums.Priority
    userId?: StringWithAggregatesFilter<"Todo"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Todo"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeFilter<"Event"> | Date | string
    isAllDay?: BoolFilter<"Event"> | boolean
    remindAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    color?: StringNullableFilter<"Event"> | string | null
    userId?: StringFilter<"Event"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isAllDay?: SortOrder
    remindAt?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    userId?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeFilter<"Event"> | Date | string
    isAllDay?: BoolFilter<"Event"> | boolean
    remindAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    color?: StringNullableFilter<"Event"> | string | null
    userId?: StringFilter<"Event"> | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isAllDay?: SortOrder
    remindAt?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    userId?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    description?: StringNullableWithAggregatesFilter<"Event"> | string | null
    startDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    isAllDay?: BoolWithAggregatesFilter<"Event"> | boolean
    remindAt?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    color?: StringNullableWithAggregatesFilter<"Event"> | string | null
    userId?: StringWithAggregatesFilter<"Event"> | string
  }

  export type MessageWhereInput = {
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    fileId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    isRead?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    file?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type MessageOrderByWithRelationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    fileId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    file?: FileOrderByWithRelationInput
    receiver?: UserOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type MessageWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: MessageWhereInput | MessageWhereInput[]
    OR?: MessageWhereInput[]
    NOT?: MessageWhereInput | MessageWhereInput[]
    content?: StringNullableFilter<"Message"> | string | null
    fileId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    isRead?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
    file?: XOR<FileNullableScalarRelationFilter, FileWhereInput> | null
    receiver?: XOR<UserScalarRelationFilter, UserWhereInput>
    sender?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type MessageOrderByWithAggregationInput = {
    id?: SortOrder
    content?: SortOrderInput | SortOrder
    fileId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrderInput | SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
    _count?: MessageCountOrderByAggregateInput
    _max?: MessageMaxOrderByAggregateInput
    _min?: MessageMinOrderByAggregateInput
  }

  export type MessageScalarWhereWithAggregatesInput = {
    AND?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    OR?: MessageScalarWhereWithAggregatesInput[]
    NOT?: MessageScalarWhereWithAggregatesInput | MessageScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Message"> | string
    content?: StringNullableWithAggregatesFilter<"Message"> | string | null
    fileId?: StringNullableWithAggregatesFilter<"Message"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Message"> | Date | string
    isRead?: BoolWithAggregatesFilter<"Message"> | boolean
    readAt?: DateTimeNullableWithAggregatesFilter<"Message"> | Date | string | null
    senderId?: StringWithAggregatesFilter<"Message"> | string
    receiverId?: StringWithAggregatesFilter<"Message"> | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    route?: StringNullableFilter<"Notification"> | string | null
    relatedId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    userId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    route?: SortOrderInput | SortOrder
    relatedId?: SortOrderInput | SortOrder
    type?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    route?: StringNullableFilter<"Notification"> | string | null
    relatedId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    userId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    user?: XOR<UserScalarRelationFilter, UserWhereInput>
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    route?: SortOrderInput | SortOrder
    relatedId?: SortOrderInput | SortOrder
    type?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    body?: StringWithAggregatesFilter<"Notification"> | string
    route?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    relatedId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: EnumNotificationTypeWithAggregatesFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    userId?: StringWithAggregatesFilter<"Notification"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type FileWhereInput = {
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    id?: StringFilter<"File"> | string
    key?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    sizeBytes?: IntFilter<"File"> | number
    ownerId?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    materials?: MaterialListRelationFilter
    messages?: MessageListRelationFilter
    homeworkTrackings?: HomeworkTrackingListRelationFilter
    homeworkSubmissions?: HomeworkSubmissionListRelationFilter
  }

  export type FileOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    owner?: UserOrderByWithRelationInput
    materials?: MaterialOrderByRelationAggregateInput
    messages?: MessageOrderByRelationAggregateInput
    homeworkTrackings?: HomeworkTrackingOrderByRelationAggregateInput
    homeworkSubmissions?: HomeworkSubmissionOrderByRelationAggregateInput
  }

  export type FileWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: FileWhereInput | FileWhereInput[]
    OR?: FileWhereInput[]
    NOT?: FileWhereInput | FileWhereInput[]
    key?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    sizeBytes?: IntFilter<"File"> | number
    ownerId?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
    owner?: XOR<UserScalarRelationFilter, UserWhereInput>
    materials?: MaterialListRelationFilter
    messages?: MessageListRelationFilter
    homeworkTrackings?: HomeworkTrackingListRelationFilter
    homeworkSubmissions?: HomeworkSubmissionListRelationFilter
  }, "id">

  export type FileOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: FileCountOrderByAggregateInput
    _avg?: FileAvgOrderByAggregateInput
    _max?: FileMaxOrderByAggregateInput
    _min?: FileMinOrderByAggregateInput
    _sum?: FileSumOrderByAggregateInput
  }

  export type FileScalarWhereWithAggregatesInput = {
    AND?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    OR?: FileScalarWhereWithAggregatesInput[]
    NOT?: FileScalarWhereWithAggregatesInput | FileScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"File"> | string
    key?: StringWithAggregatesFilter<"File"> | string
    filename?: StringWithAggregatesFilter<"File"> | string
    mimeType?: StringWithAggregatesFilter<"File"> | string
    sizeBytes?: IntWithAggregatesFilter<"File"> | number
    ownerId?: StringWithAggregatesFilter<"File"> | string
    createdAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"File"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    todos?: TodoCreateNestedManyWithoutUserInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateInput = {
    id?: string
    profileVisibility?: string
    showAvatar?: boolean
    showEmail?: boolean
    showPhone?: boolean
    allowMessages?: boolean
    showCourses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutSettingsInput
  }

  export type UserSettingsUncheckedCreateInput = {
    id?: string
    userId: string
    profileVisibility?: string
    showAvatar?: boolean
    showEmail?: boolean
    showPhone?: boolean
    allowMessages?: boolean
    showCourses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileVisibility?: StringFieldUpdateOperationsInput | string
    showAvatar?: BoolFieldUpdateOperationsInput | boolean
    showEmail?: BoolFieldUpdateOperationsInput | boolean
    showPhone?: BoolFieldUpdateOperationsInput | boolean
    allowMessages?: BoolFieldUpdateOperationsInput | boolean
    showCourses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSettingsNestedInput
  }

  export type UserSettingsUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileVisibility?: StringFieldUpdateOperationsInput | string
    showAvatar?: BoolFieldUpdateOperationsInput | boolean
    showEmail?: BoolFieldUpdateOperationsInput | boolean
    showPhone?: BoolFieldUpdateOperationsInput | boolean
    allowMessages?: BoolFieldUpdateOperationsInput | boolean
    showCourses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsCreateManyInput = {
    id?: string
    userId: string
    profileVisibility?: string
    showAvatar?: boolean
    showEmail?: boolean
    showPhone?: boolean
    allowMessages?: boolean
    showCourses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileVisibility?: StringFieldUpdateOperationsInput | string
    showAvatar?: BoolFieldUpdateOperationsInput | boolean
    showEmail?: BoolFieldUpdateOperationsInput | boolean
    showPhone?: BoolFieldUpdateOperationsInput | boolean
    allowMessages?: BoolFieldUpdateOperationsInput | boolean
    showCourses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    profileVisibility?: StringFieldUpdateOperationsInput | string
    showAvatar?: BoolFieldUpdateOperationsInput | boolean
    showEmail?: BoolFieldUpdateOperationsInput | boolean
    showPhone?: BoolFieldUpdateOperationsInput | boolean
    allowMessages?: BoolFieldUpdateOperationsInput | boolean
    showCourses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AccountCreateInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
    user: UserCreateNestedOneWithoutAccountsInput
  }

  export type AccountUncheckedCreateInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutAccountsNestedInput
  }

  export type AccountUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountCreateManyInput = {
    id?: string
    userId: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionCreateInput = {
    id?: string
    sessionToken: string
    expires: Date | string
    user: UserCreateNestedOneWithoutSessionsInput
  }

  export type SessionUncheckedCreateInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutSessionsNestedInput
  }

  export type SessionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionCreateManyInput = {
    id?: string
    sessionToken: string
    userId: string
    expires: Date | string
  }

  export type SessionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUncheckedCreateInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenCreateManyInput = {
    identifier: string
    token: string
    expires: Date | string
  }

  export type VerificationTokenUpdateManyMutationInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type VerificationTokenUncheckedUpdateManyInput = {
    identifier?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUncheckedCreateInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenCreateManyInput = {
    id?: string
    email: string
    token: string
    expires: Date | string
  }

  export type PasswordResetTokenUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordResetTokenUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailChangeRequestCreateInput = {
    id?: string
    newEmail: string
    token: string
    expires: Date | string
    usedAt?: Date | string | null
    user: UserCreateNestedOneWithoutEmailChangeRequestsInput
  }

  export type EmailChangeRequestUncheckedCreateInput = {
    id?: string
    userId: string
    newEmail: string
    token: string
    expires: Date | string
    usedAt?: Date | string | null
  }

  export type EmailChangeRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutEmailChangeRequestsNestedInput
  }

  export type EmailChangeRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailChangeRequestCreateManyInput = {
    id?: string
    userId: string
    newEmail: string
    token: string
    expires: Date | string
    usedAt?: Date | string | null
  }

  export type EmailChangeRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailChangeRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceCreateInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceId?: string | null
    model?: string | null
    fcmToken?: string | null
    lastActive?: Date | string
    user: UserCreateNestedOneWithoutDevicesInput
  }

  export type DeviceUncheckedCreateInput = {
    id?: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceId?: string | null
    model?: string | null
    fcmToken?: string | null
    lastActive?: Date | string
  }

  export type DeviceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutDevicesNestedInput
  }

  export type DeviceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceCreateManyInput = {
    id?: string
    userId: string
    deviceType: $Enums.DeviceType
    deviceId?: string | null
    model?: string | null
    fcmToken?: string | null
    lastActive?: Date | string
  }

  export type DeviceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherProfileCreateInput = {
    id?: string
    branch: string
    bio?: string | null
    user: UserCreateNestedOneWithoutTeacherProfileInput
    studentRelations?: StudentTeacherRelationCreateNestedManyWithoutTeacherInput
    classes?: ClassroomCreateNestedManyWithoutTeacherInput
    lessons?: LessonCreateNestedManyWithoutTeacherInput
    payments?: PaymentCreateNestedManyWithoutTeacherInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileUncheckedCreateInput = {
    id?: string
    userId: string
    branch: string
    bio?: string | null
    studentRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutTeacherInput
    classes?: ClassroomUncheckedCreateNestedManyWithoutTeacherInput
    lessons?: LessonUncheckedCreateNestedManyWithoutTeacherInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTeacherInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherProfileNestedInput
    studentRelations?: StudentTeacherRelationUpdateManyWithoutTeacherNestedInput
    classes?: ClassroomUpdateManyWithoutTeacherNestedInput
    lessons?: LessonUpdateManyWithoutTeacherNestedInput
    payments?: PaymentUpdateManyWithoutTeacherNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    studentRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: ClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutTeacherNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTeacherNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherProfileCreateManyInput = {
    id?: string
    userId: string
    branch: string
    bio?: string | null
  }

  export type TeacherProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TeacherProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type StudentProfileCreateInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    teacherRelations?: StudentTeacherRelationCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemCreateNestedManyWithoutStudentInput
    lessons?: LessonCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutStudentInput
    grades?: SchoolExamCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUncheckedCreateInput = {
    id?: string
    userId?: string | null
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemUncheckedCreateNestedManyWithoutStudentInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentInput
    grades?: SchoolExamUncheckedCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    teacherRelations?: StudentTeacherRelationUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUpdateManyWithoutStudentNestedInput
    lessons?: LessonUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUncheckedUpdateManyWithoutStudentNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUncheckedUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileCreateManyInput = {
    id?: string
    userId?: string | null
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentProfileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentProfileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTeacherRelationCreateInput = {
    id?: string
    status?: $Enums.RelationStatus
    isCreator?: boolean
    customName?: string | null
    privateNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherProfileCreateNestedOneWithoutStudentRelationsInput
    student: StudentProfileCreateNestedOneWithoutTeacherRelationsInput
  }

  export type StudentTeacherRelationUncheckedCreateInput = {
    id?: string
    teacherId: string
    studentId: string
    status?: $Enums.RelationStatus
    isCreator?: boolean
    customName?: string | null
    privateNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTeacherRelationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRelationStatusFieldUpdateOperationsInput | $Enums.RelationStatus
    isCreator?: BoolFieldUpdateOperationsInput | boolean
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    privateNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherProfileUpdateOneRequiredWithoutStudentRelationsNestedInput
    student?: StudentProfileUpdateOneRequiredWithoutTeacherRelationsNestedInput
  }

  export type StudentTeacherRelationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumRelationStatusFieldUpdateOperationsInput | $Enums.RelationStatus
    isCreator?: BoolFieldUpdateOperationsInput | boolean
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    privateNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTeacherRelationCreateManyInput = {
    id?: string
    teacherId: string
    studentId: string
    status?: $Enums.RelationStatus
    isCreator?: boolean
    customName?: string | null
    privateNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTeacherRelationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRelationStatusFieldUpdateOperationsInput | $Enums.RelationStatus
    isCreator?: BoolFieldUpdateOperationsInput | boolean
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    privateNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTeacherRelationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumRelationStatusFieldUpdateOperationsInput | $Enums.RelationStatus
    isCreator?: BoolFieldUpdateOperationsInput | boolean
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    privateNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomCreateInput = {
    id?: string
    name: string
    year: number
    teacher?: TeacherProfileCreateNestedOneWithoutClassesInput
    students?: StudentProfileCreateNestedManyWithoutClassroomsInput
    schedule?: ScheduleItemCreateNestedManyWithoutClassroomInput
    lessons?: LessonCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateInput = {
    id?: string
    name: string
    year: number
    teacherId?: string | null
    students?: StudentProfileUncheckedCreateNestedManyWithoutClassroomsInput
    schedule?: ScheduleItemUncheckedCreateNestedManyWithoutClassroomInput
    lessons?: LessonUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    teacher?: TeacherProfileUpdateOneWithoutClassesNestedInput
    students?: StudentProfileUpdateManyWithoutClassroomsNestedInput
    schedule?: ScheduleItemUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentProfileUncheckedUpdateManyWithoutClassroomsNestedInput
    schedule?: ScheduleItemUncheckedUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomCreateManyInput = {
    id?: string
    name: string
    year: number
    teacherId?: string | null
  }

  export type ClassroomUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type ClassroomUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleItemCreateInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherProfileCreateNestedOneWithoutScheduleItemsInput
    classroom?: ClassroomCreateNestedOneWithoutScheduleInput
    student?: StudentProfileCreateNestedOneWithoutRecurringSchedulesInput
    lessons?: LessonCreateNestedManyWithoutScheduleItemInput
  }

  export type ScheduleItemUncheckedCreateInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    teacherId: string
    classroomId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonUncheckedCreateNestedManyWithoutScheduleItemInput
  }

  export type ScheduleItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherProfileUpdateOneRequiredWithoutScheduleItemsNestedInput
    classroom?: ClassroomUpdateOneWithoutScheduleNestedInput
    student?: StudentProfileUpdateOneWithoutRecurringSchedulesNestedInput
    lessons?: LessonUpdateManyWithoutScheduleItemNestedInput
  }

  export type ScheduleItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUncheckedUpdateManyWithoutScheduleItemNestedInput
  }

  export type ScheduleItemCreateManyInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    teacherId: string
    classroomId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduleItem?: ScheduleItemCreateNestedOneWithoutLessonsInput
    teacher: TeacherProfileCreateNestedOneWithoutLessonsInput
    students?: StudentProfileCreateNestedManyWithoutLessonsInput
    classroom?: ClassroomCreateNestedOneWithoutLessonsInput
    attendances?: AttendanceCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkCreateNestedManyWithoutLessonInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
    payments?: PaymentCreateNestedManyWithoutLessonsInput
  }

  export type LessonUncheckedCreateInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    scheduleItemId?: string | null
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    teacherId: string
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentProfileUncheckedCreateNestedManyWithoutLessonsInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkUncheckedCreateNestedManyWithoutLessonInput
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLessonsInput
  }

  export type LessonUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItem?: ScheduleItemUpdateOneWithoutLessonsNestedInput
    teacher?: TeacherProfileUpdateOneRequiredWithoutLessonsNestedInput
    students?: StudentProfileUpdateManyWithoutLessonsNestedInput
    classroom?: ClassroomUpdateOneWithoutLessonsNestedInput
    attendances?: AttendanceUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUpdateManyWithoutLessonNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    payments?: PaymentUpdateManyWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentProfileUncheckedUpdateManyWithoutLessonsNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUncheckedUpdateManyWithoutLessonNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLessonsNestedInput
  }

  export type LessonCreateManyInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    scheduleItemId?: string | null
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    teacherId: string
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateInput = {
    id?: string
    title: string
    linkUrl?: string | null
    type: $Enums.FileType
    createdAt?: Date | string
    file?: FileCreateNestedOneWithoutMaterialsInput
    lesson: LessonCreateNestedOneWithoutMaterialsInput
  }

  export type MaterialUncheckedCreateInput = {
    id?: string
    title: string
    fileId?: string | null
    linkUrl?: string | null
    type: $Enums.FileType
    lessonId: string
    createdAt?: Date | string
  }

  export type MaterialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileUpdateOneWithoutMaterialsNestedInput
    lesson?: LessonUpdateOneRequiredWithoutMaterialsNestedInput
  }

  export type MaterialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateManyInput = {
    id?: string
    title: string
    fileId?: string | null
    linkUrl?: string | null
    type: $Enums.FileType
    lessonId: string
    createdAt?: Date | string
  }

  export type MaterialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeworkCreateInput = {
    id?: string
    title: string
    content?: string | null
    assignedDate?: Date | string
    dueDate: Date | string
    lesson: LessonCreateNestedOneWithoutHomeworksInput
    trackings?: HomeworkTrackingCreateNestedManyWithoutHomeworkInput
  }

  export type HomeworkUncheckedCreateInput = {
    id?: string
    title: string
    content?: string | null
    assignedDate?: Date | string
    dueDate: Date | string
    lessonId: string
    trackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutHomeworkInput
  }

  export type HomeworkUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutHomeworksNestedInput
    trackings?: HomeworkTrackingUpdateManyWithoutHomeworkNestedInput
  }

  export type HomeworkUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonId?: StringFieldUpdateOperationsInput | string
    trackings?: HomeworkTrackingUncheckedUpdateManyWithoutHomeworkNestedInput
  }

  export type HomeworkCreateManyInput = {
    id?: string
    title: string
    content?: string | null
    assignedDate?: Date | string
    dueDate: Date | string
    lessonId: string
  }

  export type HomeworkUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeworkUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonId?: StringFieldUpdateOperationsInput | string
  }

  export type HomeworkTrackingCreateInput = {
    id?: string
    status?: $Enums.HomeworkStatus
    studentNote?: string | null
    teacherNote?: string | null
    checkedAt?: Date | string | null
    file?: FileCreateNestedOneWithoutHomeworkTrackingsInput
    homework: HomeworkCreateNestedOneWithoutTrackingsInput
    student: StudentProfileCreateNestedOneWithoutHomeworkTrackingsInput
  }

  export type HomeworkTrackingUncheckedCreateInput = {
    id?: string
    homeworkId: string
    studentId: string
    status?: $Enums.HomeworkStatus
    studentNote?: string | null
    teacherNote?: string | null
    fileId?: string | null
    checkedAt?: Date | string | null
  }

  export type HomeworkTrackingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file?: FileUpdateOneWithoutHomeworkTrackingsNestedInput
    homework?: HomeworkUpdateOneRequiredWithoutTrackingsNestedInput
    student?: StudentProfileUpdateOneRequiredWithoutHomeworkTrackingsNestedInput
  }

  export type HomeworkTrackingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeworkId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HomeworkTrackingCreateManyInput = {
    id?: string
    homeworkId: string
    studentId: string
    status?: $Enums.HomeworkStatus
    studentNote?: string | null
    teacherNote?: string | null
    fileId?: string | null
    checkedAt?: Date | string | null
  }

  export type HomeworkTrackingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HomeworkTrackingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeworkId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HomeworkSubmissionCreateInput = {
    id?: string
    note?: string | null
    submittedAt?: Date | string
    file?: FileCreateNestedOneWithoutHomeworkSubmissionsInput
    student: StudentProfileCreateNestedOneWithoutSubmissionsInput
  }

  export type HomeworkSubmissionUncheckedCreateInput = {
    id?: string
    fileId?: string | null
    note?: string | null
    submittedAt?: Date | string
    studentId: string
  }

  export type HomeworkSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileUpdateOneWithoutHomeworkSubmissionsNestedInput
    student?: StudentProfileUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type HomeworkSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type HomeworkSubmissionCreateManyInput = {
    id?: string
    fileId?: string | null
    note?: string | null
    submittedAt?: Date | string
    studentId: string
  }

  export type HomeworkSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeworkSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolExamCreateInput = {
    id?: string
    title: string
    score: number
    date: Date | string
    subject: string
    student: StudentProfileCreateNestedOneWithoutGradesInput
  }

  export type SchoolExamUncheckedCreateInput = {
    id?: string
    title: string
    score: number
    date: Date | string
    subject: string
    studentId: string
  }

  export type SchoolExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    student?: StudentProfileUpdateOneRequiredWithoutGradesNestedInput
  }

  export type SchoolExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolExamCreateManyInput = {
    id?: string
    title: string
    score: number
    date: Date | string
    subject: string
    studentId: string
  }

  export type SchoolExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type TrialExamCreateInput = {
    id?: string
    title: string
    date: Date | string
    category: $Enums.ExamCategory
    publisher?: string | null
    totalNet?: number | null
    totalScore?: number | null
    student: StudentProfileCreateNestedOneWithoutTrialExamsInput
    results?: TrialExamResultCreateNestedManyWithoutTrialExamInput
  }

  export type TrialExamUncheckedCreateInput = {
    id?: string
    title: string
    date: Date | string
    category: $Enums.ExamCategory
    publisher?: string | null
    studentId: string
    totalNet?: number | null
    totalScore?: number | null
    results?: TrialExamResultUncheckedCreateNestedManyWithoutTrialExamInput
  }

  export type TrialExamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumExamCategoryFieldUpdateOperationsInput | $Enums.ExamCategory
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    student?: StudentProfileUpdateOneRequiredWithoutTrialExamsNestedInput
    results?: TrialExamResultUpdateManyWithoutTrialExamNestedInput
  }

  export type TrialExamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumExamCategoryFieldUpdateOperationsInput | $Enums.ExamCategory
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    results?: TrialExamResultUncheckedUpdateManyWithoutTrialExamNestedInput
  }

  export type TrialExamCreateManyInput = {
    id?: string
    title: string
    date: Date | string
    category: $Enums.ExamCategory
    publisher?: string | null
    studentId: string
    totalNet?: number | null
    totalScore?: number | null
  }

  export type TrialExamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumExamCategoryFieldUpdateOperationsInput | $Enums.ExamCategory
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TrialExamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumExamCategoryFieldUpdateOperationsInput | $Enums.ExamCategory
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type TrialExamResultCreateInput = {
    id?: string
    lessonName: string
    correctCount: number
    incorrectCount: number
    emptyCount: number
    net: number
    mistakeTopics?: TrialExamResultCreatemistakeTopicsInput | string[]
    mistakeAnalysis?: string | null
    trialExam: TrialExamCreateNestedOneWithoutResultsInput
  }

  export type TrialExamResultUncheckedCreateInput = {
    id?: string
    trialExamId: string
    lessonName: string
    correctCount: number
    incorrectCount: number
    emptyCount: number
    net: number
    mistakeTopics?: TrialExamResultCreatemistakeTopicsInput | string[]
    mistakeAnalysis?: string | null
  }

  export type TrialExamResultUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonName?: StringFieldUpdateOperationsInput | string
    correctCount?: IntFieldUpdateOperationsInput | number
    incorrectCount?: IntFieldUpdateOperationsInput | number
    emptyCount?: IntFieldUpdateOperationsInput | number
    net?: FloatFieldUpdateOperationsInput | number
    mistakeTopics?: TrialExamResultUpdatemistakeTopicsInput | string[]
    mistakeAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
    trialExam?: TrialExamUpdateOneRequiredWithoutResultsNestedInput
  }

  export type TrialExamResultUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    trialExamId?: StringFieldUpdateOperationsInput | string
    lessonName?: StringFieldUpdateOperationsInput | string
    correctCount?: IntFieldUpdateOperationsInput | number
    incorrectCount?: IntFieldUpdateOperationsInput | number
    emptyCount?: IntFieldUpdateOperationsInput | number
    net?: FloatFieldUpdateOperationsInput | number
    mistakeTopics?: TrialExamResultUpdatemistakeTopicsInput | string[]
    mistakeAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrialExamResultCreateManyInput = {
    id?: string
    trialExamId: string
    lessonName: string
    correctCount: number
    incorrectCount: number
    emptyCount: number
    net: number
    mistakeTopics?: TrialExamResultCreatemistakeTopicsInput | string[]
    mistakeAnalysis?: string | null
  }

  export type TrialExamResultUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonName?: StringFieldUpdateOperationsInput | string
    correctCount?: IntFieldUpdateOperationsInput | number
    incorrectCount?: IntFieldUpdateOperationsInput | number
    emptyCount?: IntFieldUpdateOperationsInput | number
    net?: FloatFieldUpdateOperationsInput | number
    mistakeTopics?: TrialExamResultUpdatemistakeTopicsInput | string[]
    mistakeAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrialExamResultUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    trialExamId?: StringFieldUpdateOperationsInput | string
    lessonName?: StringFieldUpdateOperationsInput | string
    correctCount?: IntFieldUpdateOperationsInput | number
    incorrectCount?: IntFieldUpdateOperationsInput | number
    emptyCount?: IntFieldUpdateOperationsInput | number
    net?: FloatFieldUpdateOperationsInput | number
    mistakeTopics?: TrialExamResultUpdatemistakeTopicsInput | string[]
    mistakeAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceCreateInput = {
    id?: string
    status: $Enums.AttendanceStatus
    note?: string | null
    lesson: LessonCreateNestedOneWithoutAttendancesInput
    student: StudentProfileCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateInput = {
    id?: string
    lessonId: string
    studentId: string
    status: $Enums.AttendanceStatus
    note?: string | null
  }

  export type AttendanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    lesson?: LessonUpdateOneRequiredWithoutAttendancesNestedInput
    student?: StudentProfileUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceCreateManyInput = {
    id?: string
    lessonId: string
    studentId: string
    status: $Enums.AttendanceStatus
    note?: string | null
  }

  export type AttendanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PaymentCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    type: $Enums.PaymentType
    note?: string | null
    isVisibleToStudent?: boolean
    student: StudentProfileCreateNestedOneWithoutPaymentsInput
    teacher: TeacherProfileCreateNestedOneWithoutPaymentsInput
    lessons?: LessonCreateNestedManyWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    type: $Enums.PaymentType
    note?: string | null
    isVisibleToStudent?: boolean
    studentId: string
    teacherId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutPaymentsInput
  }

  export type PaymentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentProfileUpdateOneRequiredWithoutPaymentsNestedInput
    teacher?: TeacherProfileUpdateOneRequiredWithoutPaymentsNestedInput
    lessons?: LessonUpdateManyWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutPaymentsNestedInput
  }

  export type PaymentCreateManyInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    type: $Enums.PaymentType
    note?: string | null
    isVisibleToStudent?: boolean
    studentId: string
    teacherId: string
  }

  export type PaymentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
  }

  export type PaymentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type TodoCreateInput = {
    id?: string
    content: string
    isCompleted?: boolean
    dueDate?: Date | string | null
    reminderTime?: Date | string | null
    priority?: $Enums.Priority
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutTodosInput
  }

  export type TodoUncheckedCreateInput = {
    id?: string
    content: string
    isCompleted?: boolean
    dueDate?: Date | string | null
    reminderTime?: Date | string | null
    priority?: $Enums.Priority
    userId: string
    createdAt?: Date | string
  }

  export type TodoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutTodosNestedInput
  }

  export type TodoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoCreateManyInput = {
    id?: string
    content: string
    isCompleted?: boolean
    dueDate?: Date | string | null
    reminderTime?: Date | string | null
    priority?: $Enums.Priority
    userId: string
    createdAt?: Date | string
  }

  export type TodoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isAllDay?: boolean
    remindAt?: Date | string | null
    color?: string | null
    user: UserCreateNestedOneWithoutCalendarEventsInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isAllDay?: boolean
    remindAt?: Date | string | null
    color?: string | null
    userId: string
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    remindAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutCalendarEventsNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    remindAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isAllDay?: boolean
    remindAt?: Date | string | null
    color?: string | null
    userId: string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    remindAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    remindAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    userId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    isRead?: boolean
    readAt?: Date | string | null
    file?: FileCreateNestedOneWithoutMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateInput = {
    id?: string
    content?: string | null
    fileId?: string | null
    createdAt?: Date | string
    isRead?: boolean
    readAt?: Date | string | null
    senderId: string
    receiverId: string
  }

  export type MessageUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file?: FileUpdateOneWithoutMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageCreateManyInput = {
    id?: string
    content?: string | null
    fileId?: string | null
    createdAt?: Date | string
    isRead?: boolean
    readAt?: Date | string | null
    senderId: string
    receiverId: string
  }

  export type MessageUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type MessageUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type NotificationCreateInput = {
    id?: string
    title: string
    body: string
    route?: string | null
    relatedId?: string | null
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
    user: UserCreateNestedOneWithoutNotificationsInput
  }

  export type NotificationUncheckedCreateInput = {
    id?: string
    title: string
    body: string
    route?: string | null
    relatedId?: string | null
    type: $Enums.NotificationType
    isRead?: boolean
    userId: string
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutNotificationsNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id?: string
    title: string
    body: string
    route?: string | null
    relatedId?: string | null
    type: $Enums.NotificationType
    isRead?: boolean
    userId: string
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    userId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileCreateInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutFilesInput
    materials?: MaterialCreateNestedManyWithoutFileInput
    messages?: MessageCreateNestedManyWithoutFileInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutFileInput
    homeworkSubmissions?: HomeworkSubmissionCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: MaterialUncheckedCreateNestedManyWithoutFileInput
    messages?: MessageUncheckedCreateNestedManyWithoutFileInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutFileInput
    homeworkSubmissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutFilesNestedInput
    materials?: MaterialUpdateManyWithoutFileNestedInput
    messages?: MessageUpdateManyWithoutFileNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutFileNestedInput
    homeworkSubmissions?: HomeworkSubmissionUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: MaterialUncheckedUpdateManyWithoutFileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutFileNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutFileNestedInput
    homeworkSubmissions?: HomeworkSubmissionUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileCreateManyInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type FileUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type FileUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type EnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UserSettingsNullableScalarRelationFilter = {
    is?: UserSettingsWhereInput | null
    isNot?: UserSettingsWhereInput | null
  }

  export type TeacherProfileNullableScalarRelationFilter = {
    is?: TeacherProfileWhereInput | null
    isNot?: TeacherProfileWhereInput | null
  }

  export type StudentProfileNullableScalarRelationFilter = {
    is?: StudentProfileWhereInput | null
    isNot?: StudentProfileWhereInput | null
  }

  export type AccountListRelationFilter = {
    every?: AccountWhereInput
    some?: AccountWhereInput
    none?: AccountWhereInput
  }

  export type SessionListRelationFilter = {
    every?: SessionWhereInput
    some?: SessionWhereInput
    none?: SessionWhereInput
  }

  export type EmailChangeRequestListRelationFilter = {
    every?: EmailChangeRequestWhereInput
    some?: EmailChangeRequestWhereInput
    none?: EmailChangeRequestWhereInput
  }

  export type DeviceListRelationFilter = {
    every?: DeviceWhereInput
    some?: DeviceWhereInput
    none?: DeviceWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type MessageListRelationFilter = {
    every?: MessageWhereInput
    some?: MessageWhereInput
    none?: MessageWhereInput
  }

  export type TodoListRelationFilter = {
    every?: TodoWhereInput
    some?: TodoWhereInput
    none?: TodoWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type FileListRelationFilter = {
    every?: FileWhereInput
    some?: FileWhereInput
    none?: FileWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type AccountOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SessionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailChangeRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DeviceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MessageOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TodoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type FileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    avatarVersion?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isOnboardingCompleted?: SortOrder
    notificationEmailEnabled?: SortOrder
    notificationInAppEnabled?: SortOrder
    preferredCountry?: SortOrder
    preferredTimezone?: SortOrder
    cookieAnalyticsEnabled?: SortOrder
    isMarketingConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    avatarVersion?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    avatarVersion?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isOnboardingCompleted?: SortOrder
    notificationEmailEnabled?: SortOrder
    notificationInAppEnabled?: SortOrder
    preferredCountry?: SortOrder
    preferredTimezone?: SortOrder
    cookieAnalyticsEnabled?: SortOrder
    isMarketingConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    username?: SortOrder
    email?: SortOrder
    emailVerified?: SortOrder
    image?: SortOrder
    avatarVersion?: SortOrder
    password?: SortOrder
    phoneNumber?: SortOrder
    isDeleted?: SortOrder
    deletedAt?: SortOrder
    role?: SortOrder
    isActive?: SortOrder
    isOnboardingCompleted?: SortOrder
    notificationEmailEnabled?: SortOrder
    notificationInAppEnabled?: SortOrder
    preferredCountry?: SortOrder
    preferredTimezone?: SortOrder
    cookieAnalyticsEnabled?: SortOrder
    isMarketingConsent?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    avatarVersion?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type EnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UserScalarRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type UserSettingsCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileVisibility?: SortOrder
    showAvatar?: SortOrder
    showEmail?: SortOrder
    showPhone?: SortOrder
    allowMessages?: SortOrder
    showCourses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileVisibility?: SortOrder
    showAvatar?: SortOrder
    showEmail?: SortOrder
    showPhone?: SortOrder
    allowMessages?: SortOrder
    showCourses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserSettingsMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    profileVisibility?: SortOrder
    showAvatar?: SortOrder
    showEmail?: SortOrder
    showPhone?: SortOrder
    allowMessages?: SortOrder
    showCourses?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type AccountProviderProviderAccountIdCompoundUniqueInput = {
    provider: string
    providerAccountId: string
  }

  export type AccountCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountAvgOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type AccountMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    type?: SortOrder
    provider?: SortOrder
    providerAccountId?: SortOrder
    refresh_token?: SortOrder
    access_token?: SortOrder
    expires_at?: SortOrder
    token_type?: SortOrder
    scope?: SortOrder
    id_token?: SortOrder
    session_state?: SortOrder
  }

  export type AccountSumOrderByAggregateInput = {
    expires_at?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type SessionCountOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMaxOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type SessionMinOrderByAggregateInput = {
    id?: SortOrder
    sessionToken?: SortOrder
    userId?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenIdentifierTokenCompoundUniqueInput = {
    identifier: string
    token: string
  }

  export type VerificationTokenCountOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMaxOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type VerificationTokenMinOrderByAggregateInput = {
    identifier?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenEmailTokenCompoundUniqueInput = {
    email: string
    token: string
  }

  export type PasswordResetTokenCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type PasswordResetTokenMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    token?: SortOrder
    expires?: SortOrder
  }

  export type EmailChangeRequestCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    newEmail?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    usedAt?: SortOrder
  }

  export type EmailChangeRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    newEmail?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    usedAt?: SortOrder
  }

  export type EmailChangeRequestMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    newEmail?: SortOrder
    token?: SortOrder
    expires?: SortOrder
    usedAt?: SortOrder
  }

  export type EnumDeviceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceTypeFilter<$PrismaModel> | $Enums.DeviceType
  }

  export type DeviceUserIdDeviceIdCompoundUniqueInput = {
    userId: string
    deviceId: string
  }

  export type DeviceCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    model?: SortOrder
    fcmToken?: SortOrder
    lastActive?: SortOrder
  }

  export type DeviceMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    model?: SortOrder
    fcmToken?: SortOrder
    lastActive?: SortOrder
  }

  export type DeviceMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    deviceType?: SortOrder
    deviceId?: SortOrder
    model?: SortOrder
    fcmToken?: SortOrder
    lastActive?: SortOrder
  }

  export type EnumDeviceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeviceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceTypeFilter<$PrismaModel>
    _max?: NestedEnumDeviceTypeFilter<$PrismaModel>
  }

  export type StudentTeacherRelationListRelationFilter = {
    every?: StudentTeacherRelationWhereInput
    some?: StudentTeacherRelationWhereInput
    none?: StudentTeacherRelationWhereInput
  }

  export type ClassroomListRelationFilter = {
    every?: ClassroomWhereInput
    some?: ClassroomWhereInput
    none?: ClassroomWhereInput
  }

  export type LessonListRelationFilter = {
    every?: LessonWhereInput
    some?: LessonWhereInput
    none?: LessonWhereInput
  }

  export type PaymentListRelationFilter = {
    every?: PaymentWhereInput
    some?: PaymentWhereInput
    none?: PaymentWhereInput
  }

  export type ScheduleItemListRelationFilter = {
    every?: ScheduleItemWhereInput
    some?: ScheduleItemWhereInput
    none?: ScheduleItemWhereInput
  }

  export type StudentTeacherRelationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassroomOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PaymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ScheduleItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeacherProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branch?: SortOrder
    bio?: SortOrder
  }

  export type TeacherProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branch?: SortOrder
    bio?: SortOrder
  }

  export type TeacherProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    branch?: SortOrder
    bio?: SortOrder
  }

  export type UserNullableScalarRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type HomeworkTrackingListRelationFilter = {
    every?: HomeworkTrackingWhereInput
    some?: HomeworkTrackingWhereInput
    none?: HomeworkTrackingWhereInput
  }

  export type HomeworkSubmissionListRelationFilter = {
    every?: HomeworkSubmissionWhereInput
    some?: HomeworkSubmissionWhereInput
    none?: HomeworkSubmissionWhereInput
  }

  export type SchoolExamListRelationFilter = {
    every?: SchoolExamWhereInput
    some?: SchoolExamWhereInput
    none?: SchoolExamWhereInput
  }

  export type TrialExamListRelationFilter = {
    every?: TrialExamWhereInput
    some?: TrialExamWhereInput
    none?: TrialExamWhereInput
  }

  export type AttendanceListRelationFilter = {
    every?: AttendanceWhereInput
    some?: AttendanceWhereInput
    none?: AttendanceWhereInput
  }

  export type HomeworkTrackingOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type HomeworkSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SchoolExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrialExamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type AttendanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type StudentProfileCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tempFirstName?: SortOrder
    tempLastName?: SortOrder
    tempPhone?: SortOrder
    tempEmail?: SortOrder
    tempAvatarKey?: SortOrder
    inviteToken?: SortOrder
    inviteTokenExpires?: SortOrder
    isClaimed?: SortOrder
    creatorTeacherId?: SortOrder
    studentNo?: SortOrder
    gradeLevel?: SortOrder
    parentName?: SortOrder
    parentPhone?: SortOrder
    parentEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProfileMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tempFirstName?: SortOrder
    tempLastName?: SortOrder
    tempPhone?: SortOrder
    tempEmail?: SortOrder
    tempAvatarKey?: SortOrder
    inviteToken?: SortOrder
    inviteTokenExpires?: SortOrder
    isClaimed?: SortOrder
    creatorTeacherId?: SortOrder
    studentNo?: SortOrder
    gradeLevel?: SortOrder
    parentName?: SortOrder
    parentPhone?: SortOrder
    parentEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentProfileMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    tempFirstName?: SortOrder
    tempLastName?: SortOrder
    tempPhone?: SortOrder
    tempEmail?: SortOrder
    tempAvatarKey?: SortOrder
    inviteToken?: SortOrder
    inviteTokenExpires?: SortOrder
    isClaimed?: SortOrder
    creatorTeacherId?: SortOrder
    studentNo?: SortOrder
    gradeLevel?: SortOrder
    parentName?: SortOrder
    parentPhone?: SortOrder
    parentEmail?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRelationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationStatus | EnumRelationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RelationStatus[] | ListEnumRelationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationStatus[] | ListEnumRelationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationStatusFilter<$PrismaModel> | $Enums.RelationStatus
  }

  export type TeacherProfileScalarRelationFilter = {
    is?: TeacherProfileWhereInput
    isNot?: TeacherProfileWhereInput
  }

  export type StudentProfileScalarRelationFilter = {
    is?: StudentProfileWhereInput
    isNot?: StudentProfileWhereInput
  }

  export type StudentTeacherRelationTeacherIdStudentIdCompoundUniqueInput = {
    teacherId: string
    studentId: string
  }

  export type StudentTeacherRelationCountOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    isCreator?: SortOrder
    customName?: SortOrder
    privateNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentTeacherRelationMaxOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    isCreator?: SortOrder
    customName?: SortOrder
    privateNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StudentTeacherRelationMinOrderByAggregateInput = {
    id?: SortOrder
    teacherId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    isCreator?: SortOrder
    customName?: SortOrder
    privateNotes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EnumRelationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationStatus | EnumRelationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RelationStatus[] | ListEnumRelationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationStatus[] | ListEnumRelationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationStatusWithAggregatesFilter<$PrismaModel> | $Enums.RelationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationStatusFilter<$PrismaModel>
    _max?: NestedEnumRelationStatusFilter<$PrismaModel>
  }

  export type StudentProfileListRelationFilter = {
    every?: StudentProfileWhereInput
    some?: StudentProfileWhereInput
    none?: StudentProfileWhereInput
  }

  export type StudentProfileOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ClassroomCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    teacherId?: SortOrder
  }

  export type ClassroomAvgOrderByAggregateInput = {
    year?: SortOrder
  }

  export type ClassroomMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    teacherId?: SortOrder
  }

  export type ClassroomMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    year?: SortOrder
    teacherId?: SortOrder
  }

  export type ClassroomSumOrderByAggregateInput = {
    year?: SortOrder
  }

  export type EnumLessonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeFilter<$PrismaModel> | $Enums.LessonType
  }

  export type EnumLessonLocationFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonLocation | EnumLessonLocationFieldRefInput<$PrismaModel>
    in?: $Enums.LessonLocation[] | ListEnumLessonLocationFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonLocation[] | ListEnumLessonLocationFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonLocationFilter<$PrismaModel> | $Enums.LessonLocation
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type ClassroomNullableScalarRelationFilter = {
    is?: ClassroomWhereInput | null
    isNot?: ClassroomWhereInput | null
  }

  export type ScheduleItemCountOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    type?: SortOrder
    location?: SortOrder
    locationUrl?: SortOrder
    address?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    teacherId?: SortOrder
    classroomId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleItemAvgOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    price?: SortOrder
  }

  export type ScheduleItemMaxOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    type?: SortOrder
    location?: SortOrder
    locationUrl?: SortOrder
    address?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    teacherId?: SortOrder
    classroomId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleItemMinOrderByAggregateInput = {
    id?: SortOrder
    dayOfWeek?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    subject?: SortOrder
    type?: SortOrder
    location?: SortOrder
    locationUrl?: SortOrder
    address?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    teacherId?: SortOrder
    classroomId?: SortOrder
    studentId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ScheduleItemSumOrderByAggregateInput = {
    dayOfWeek?: SortOrder
    price?: SortOrder
  }

  export type EnumLessonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel> | $Enums.LessonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonTypeFilter<$PrismaModel>
    _max?: NestedEnumLessonTypeFilter<$PrismaModel>
  }

  export type EnumLessonLocationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonLocation | EnumLessonLocationFieldRefInput<$PrismaModel>
    in?: $Enums.LessonLocation[] | ListEnumLessonLocationFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonLocation[] | ListEnumLessonLocationFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonLocationWithAggregatesFilter<$PrismaModel> | $Enums.LessonLocation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonLocationFilter<$PrismaModel>
    _max?: NestedEnumLessonLocationFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EnumLessonStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonStatus | EnumLessonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonStatusFilter<$PrismaModel> | $Enums.LessonStatus
  }

  export type ScheduleItemNullableScalarRelationFilter = {
    is?: ScheduleItemWhereInput | null
    isNot?: ScheduleItemWhereInput | null
  }

  export type HomeworkListRelationFilter = {
    every?: HomeworkWhereInput
    some?: HomeworkWhereInput
    none?: HomeworkWhereInput
  }

  export type MaterialListRelationFilter = {
    every?: MaterialWhereInput
    some?: MaterialWhereInput
    none?: MaterialWhereInput
  }

  export type HomeworkOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type MaterialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LessonCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    scheduleItemId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    cancelReason?: SortOrder
    location?: SortOrder
    locationUrl?: SortOrder
    address?: SortOrder
    publicNote?: SortOrder
    privateNote?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    isPaid?: SortOrder
    teacherId?: SortOrder
    classroomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonAvgOrderByAggregateInput = {
    price?: SortOrder
  }

  export type LessonMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    scheduleItemId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    cancelReason?: SortOrder
    location?: SortOrder
    locationUrl?: SortOrder
    address?: SortOrder
    publicNote?: SortOrder
    privateNote?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    isPaid?: SortOrder
    teacherId?: SortOrder
    classroomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    scheduleItemId?: SortOrder
    type?: SortOrder
    status?: SortOrder
    cancelReason?: SortOrder
    location?: SortOrder
    locationUrl?: SortOrder
    address?: SortOrder
    publicNote?: SortOrder
    privateNote?: SortOrder
    price?: SortOrder
    currency?: SortOrder
    isPaid?: SortOrder
    teacherId?: SortOrder
    classroomId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LessonSumOrderByAggregateInput = {
    price?: SortOrder
  }

  export type EnumLessonStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonStatus | EnumLessonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonStatusWithAggregatesFilter<$PrismaModel> | $Enums.LessonStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonStatusFilter<$PrismaModel>
    _max?: NestedEnumLessonStatusFilter<$PrismaModel>
  }

  export type EnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type FileNullableScalarRelationFilter = {
    is?: FileWhereInput | null
    isNot?: FileWhereInput | null
  }

  export type LessonScalarRelationFilter = {
    is?: LessonWhereInput
    isNot?: LessonWhereInput
  }

  export type MaterialCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    fileId?: SortOrder
    linkUrl?: SortOrder
    type?: SortOrder
    lessonId?: SortOrder
    createdAt?: SortOrder
  }

  export type MaterialMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    fileId?: SortOrder
    linkUrl?: SortOrder
    type?: SortOrder
    lessonId?: SortOrder
    createdAt?: SortOrder
  }

  export type MaterialMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    fileId?: SortOrder
    linkUrl?: SortOrder
    type?: SortOrder
    lessonId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type HomeworkCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    assignedDate?: SortOrder
    dueDate?: SortOrder
    lessonId?: SortOrder
  }

  export type HomeworkMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    assignedDate?: SortOrder
    dueDate?: SortOrder
    lessonId?: SortOrder
  }

  export type HomeworkMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    content?: SortOrder
    assignedDate?: SortOrder
    dueDate?: SortOrder
    lessonId?: SortOrder
  }

  export type EnumHomeworkStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HomeworkStatus | EnumHomeworkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HomeworkStatus[] | ListEnumHomeworkStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HomeworkStatus[] | ListEnumHomeworkStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHomeworkStatusFilter<$PrismaModel> | $Enums.HomeworkStatus
  }

  export type HomeworkScalarRelationFilter = {
    is?: HomeworkWhereInput
    isNot?: HomeworkWhereInput
  }

  export type HomeworkTrackingCountOrderByAggregateInput = {
    id?: SortOrder
    homeworkId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    studentNote?: SortOrder
    teacherNote?: SortOrder
    fileId?: SortOrder
    checkedAt?: SortOrder
  }

  export type HomeworkTrackingMaxOrderByAggregateInput = {
    id?: SortOrder
    homeworkId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    studentNote?: SortOrder
    teacherNote?: SortOrder
    fileId?: SortOrder
    checkedAt?: SortOrder
  }

  export type HomeworkTrackingMinOrderByAggregateInput = {
    id?: SortOrder
    homeworkId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    studentNote?: SortOrder
    teacherNote?: SortOrder
    fileId?: SortOrder
    checkedAt?: SortOrder
  }

  export type EnumHomeworkStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HomeworkStatus | EnumHomeworkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HomeworkStatus[] | ListEnumHomeworkStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HomeworkStatus[] | ListEnumHomeworkStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHomeworkStatusWithAggregatesFilter<$PrismaModel> | $Enums.HomeworkStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHomeworkStatusFilter<$PrismaModel>
    _max?: NestedEnumHomeworkStatusFilter<$PrismaModel>
  }

  export type HomeworkSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    note?: SortOrder
    submittedAt?: SortOrder
    studentId?: SortOrder
  }

  export type HomeworkSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    note?: SortOrder
    submittedAt?: SortOrder
    studentId?: SortOrder
  }

  export type HomeworkSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    fileId?: SortOrder
    note?: SortOrder
    submittedAt?: SortOrder
    studentId?: SortOrder
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type SchoolExamCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    score?: SortOrder
    date?: SortOrder
    subject?: SortOrder
    studentId?: SortOrder
  }

  export type SchoolExamAvgOrderByAggregateInput = {
    score?: SortOrder
  }

  export type SchoolExamMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    score?: SortOrder
    date?: SortOrder
    subject?: SortOrder
    studentId?: SortOrder
  }

  export type SchoolExamMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    score?: SortOrder
    date?: SortOrder
    subject?: SortOrder
    studentId?: SortOrder
  }

  export type SchoolExamSumOrderByAggregateInput = {
    score?: SortOrder
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type EnumExamCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamCategory | EnumExamCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExamCategory[] | ListEnumExamCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamCategory[] | ListEnumExamCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExamCategoryFilter<$PrismaModel> | $Enums.ExamCategory
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type TrialExamResultListRelationFilter = {
    every?: TrialExamResultWhereInput
    some?: TrialExamResultWhereInput
    none?: TrialExamResultWhereInput
  }

  export type TrialExamResultOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TrialExamCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    category?: SortOrder
    publisher?: SortOrder
    studentId?: SortOrder
    totalNet?: SortOrder
    totalScore?: SortOrder
  }

  export type TrialExamAvgOrderByAggregateInput = {
    totalNet?: SortOrder
    totalScore?: SortOrder
  }

  export type TrialExamMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    category?: SortOrder
    publisher?: SortOrder
    studentId?: SortOrder
    totalNet?: SortOrder
    totalScore?: SortOrder
  }

  export type TrialExamMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    date?: SortOrder
    category?: SortOrder
    publisher?: SortOrder
    studentId?: SortOrder
    totalNet?: SortOrder
    totalScore?: SortOrder
  }

  export type TrialExamSumOrderByAggregateInput = {
    totalNet?: SortOrder
    totalScore?: SortOrder
  }

  export type EnumExamCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamCategory | EnumExamCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExamCategory[] | ListEnumExamCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamCategory[] | ListEnumExamCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExamCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExamCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamCategoryFilter<$PrismaModel>
    _max?: NestedEnumExamCategoryFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type TrialExamScalarRelationFilter = {
    is?: TrialExamWhereInput
    isNot?: TrialExamWhereInput
  }

  export type TrialExamResultCountOrderByAggregateInput = {
    id?: SortOrder
    trialExamId?: SortOrder
    lessonName?: SortOrder
    correctCount?: SortOrder
    incorrectCount?: SortOrder
    emptyCount?: SortOrder
    net?: SortOrder
    mistakeTopics?: SortOrder
    mistakeAnalysis?: SortOrder
  }

  export type TrialExamResultAvgOrderByAggregateInput = {
    correctCount?: SortOrder
    incorrectCount?: SortOrder
    emptyCount?: SortOrder
    net?: SortOrder
  }

  export type TrialExamResultMaxOrderByAggregateInput = {
    id?: SortOrder
    trialExamId?: SortOrder
    lessonName?: SortOrder
    correctCount?: SortOrder
    incorrectCount?: SortOrder
    emptyCount?: SortOrder
    net?: SortOrder
    mistakeAnalysis?: SortOrder
  }

  export type TrialExamResultMinOrderByAggregateInput = {
    id?: SortOrder
    trialExamId?: SortOrder
    lessonName?: SortOrder
    correctCount?: SortOrder
    incorrectCount?: SortOrder
    emptyCount?: SortOrder
    net?: SortOrder
    mistakeAnalysis?: SortOrder
  }

  export type TrialExamResultSumOrderByAggregateInput = {
    correctCount?: SortOrder
    incorrectCount?: SortOrder
    emptyCount?: SortOrder
    net?: SortOrder
  }

  export type EnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type AttendanceCountOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    note?: SortOrder
  }

  export type AttendanceMaxOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    note?: SortOrder
  }

  export type AttendanceMinOrderByAggregateInput = {
    id?: SortOrder
    lessonId?: SortOrder
    studentId?: SortOrder
    status?: SortOrder
    note?: SortOrder
  }

  export type EnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type EnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type PaymentCountOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    type?: SortOrder
    note?: SortOrder
    isVisibleToStudent?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
  }

  export type PaymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PaymentMaxOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    type?: SortOrder
    note?: SortOrder
    isVisibleToStudent?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
  }

  export type PaymentMinOrderByAggregateInput = {
    id?: SortOrder
    amount?: SortOrder
    date?: SortOrder
    type?: SortOrder
    note?: SortOrder
    isVisibleToStudent?: SortOrder
    studentId?: SortOrder
    teacherId?: SortOrder
  }

  export type PaymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type EnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type TodoCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isCompleted?: SortOrder
    dueDate?: SortOrder
    reminderTime?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type TodoMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isCompleted?: SortOrder
    dueDate?: SortOrder
    reminderTime?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type TodoMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    isCompleted?: SortOrder
    dueDate?: SortOrder
    reminderTime?: SortOrder
    priority?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isAllDay?: SortOrder
    remindAt?: SortOrder
    color?: SortOrder
    userId?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isAllDay?: SortOrder
    remindAt?: SortOrder
    color?: SortOrder
    userId?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isAllDay?: SortOrder
    remindAt?: SortOrder
    color?: SortOrder
    userId?: SortOrder
  }

  export type MessageCountOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    fileId?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type MessageMaxOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    fileId?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type MessageMinOrderByAggregateInput = {
    id?: SortOrder
    content?: SortOrder
    fileId?: SortOrder
    createdAt?: SortOrder
    isRead?: SortOrder
    readAt?: SortOrder
    senderId?: SortOrder
    receiverId?: SortOrder
  }

  export type EnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    route?: SortOrder
    relatedId?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    route?: SortOrder
    relatedId?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    body?: SortOrder
    route?: SortOrder
    relatedId?: SortOrder
    type?: SortOrder
    isRead?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
  }

  export type EnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type FileCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileAvgOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type FileMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    filename?: SortOrder
    mimeType?: SortOrder
    sizeBytes?: SortOrder
    ownerId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type FileSumOrderByAggregateInput = {
    sizeBytes?: SortOrder
  }

  export type UserSettingsCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type TeacherProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherProfileCreateWithoutUserInput, TeacherProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutUserInput
    connect?: TeacherProfileWhereUniqueInput
  }

  export type StudentProfileCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutUserInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type AccountCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type EmailChangeRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailChangeRequestCreateWithoutUserInput, EmailChangeRequestUncheckedCreateWithoutUserInput> | EmailChangeRequestCreateWithoutUserInput[] | EmailChangeRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailChangeRequestCreateOrConnectWithoutUserInput | EmailChangeRequestCreateOrConnectWithoutUserInput[]
    createMany?: EmailChangeRequestCreateManyUserInputEnvelope
    connect?: EmailChangeRequestWhereUniqueInput | EmailChangeRequestWhereUniqueInput[]
  }

  export type DeviceCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TodoCreateNestedManyWithoutUserInput = {
    create?: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput> | TodoCreateWithoutUserInput[] | TodoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TodoCreateOrConnectWithoutUserInput | TodoCreateOrConnectWithoutUserInput[]
    createMany?: TodoCreateManyUserInputEnvelope
    connect?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutUserInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type FileCreateNestedManyWithoutOwnerInput = {
    create?: XOR<FileCreateWithoutOwnerInput, FileUncheckedCreateWithoutOwnerInput> | FileCreateWithoutOwnerInput[] | FileUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: FileCreateOrConnectWithoutOwnerInput | FileCreateOrConnectWithoutOwnerInput[]
    createMany?: FileCreateManyOwnerInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type UserSettingsUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    connect?: UserSettingsWhereUniqueInput
  }

  export type TeacherProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<TeacherProfileCreateWithoutUserInput, TeacherProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutUserInput
    connect?: TeacherProfileWhereUniqueInput
  }

  export type StudentProfileUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutUserInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type AccountUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
  }

  export type SessionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
  }

  export type EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EmailChangeRequestCreateWithoutUserInput, EmailChangeRequestUncheckedCreateWithoutUserInput> | EmailChangeRequestCreateWithoutUserInput[] | EmailChangeRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailChangeRequestCreateOrConnectWithoutUserInput | EmailChangeRequestCreateOrConnectWithoutUserInput[]
    createMany?: EmailChangeRequestCreateManyUserInputEnvelope
    connect?: EmailChangeRequestWhereUniqueInput | EmailChangeRequestWhereUniqueInput[]
  }

  export type DeviceUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutReceiverInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type TodoUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput> | TodoCreateWithoutUserInput[] | TodoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TodoCreateOrConnectWithoutUserInput | TodoCreateOrConnectWithoutUserInput[]
    createMany?: TodoCreateManyUserInputEnvelope
    connect?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type FileUncheckedCreateNestedManyWithoutOwnerInput = {
    create?: XOR<FileCreateWithoutOwnerInput, FileUncheckedCreateWithoutOwnerInput> | FileCreateWithoutOwnerInput[] | FileUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: FileCreateOrConnectWithoutOwnerInput | FileCreateOrConnectWithoutOwnerInput[]
    createMany?: FileCreateManyOwnerInputEnvelope
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableEnumRoleFieldUpdateOperationsInput = {
    set?: $Enums.Role | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UserSettingsUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type TeacherProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherProfileCreateWithoutUserInput, TeacherProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutUserInput
    upsert?: TeacherProfileUpsertWithoutUserInput
    disconnect?: TeacherProfileWhereInput | boolean
    delete?: TeacherProfileWhereInput | boolean
    connect?: TeacherProfileWhereUniqueInput
    update?: XOR<XOR<TeacherProfileUpdateToOneWithWhereWithoutUserInput, TeacherProfileUpdateWithoutUserInput>, TeacherProfileUncheckedUpdateWithoutUserInput>
  }

  export type StudentProfileUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutUserInput
    upsert?: StudentProfileUpsertWithoutUserInput
    disconnect?: StudentProfileWhereInput | boolean
    delete?: StudentProfileWhereInput | boolean
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutUserInput, StudentProfileUpdateWithoutUserInput>, StudentProfileUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type EmailChangeRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailChangeRequestCreateWithoutUserInput, EmailChangeRequestUncheckedCreateWithoutUserInput> | EmailChangeRequestCreateWithoutUserInput[] | EmailChangeRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailChangeRequestCreateOrConnectWithoutUserInput | EmailChangeRequestCreateOrConnectWithoutUserInput[]
    upsert?: EmailChangeRequestUpsertWithWhereUniqueWithoutUserInput | EmailChangeRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailChangeRequestCreateManyUserInputEnvelope
    set?: EmailChangeRequestWhereUniqueInput | EmailChangeRequestWhereUniqueInput[]
    disconnect?: EmailChangeRequestWhereUniqueInput | EmailChangeRequestWhereUniqueInput[]
    delete?: EmailChangeRequestWhereUniqueInput | EmailChangeRequestWhereUniqueInput[]
    connect?: EmailChangeRequestWhereUniqueInput | EmailChangeRequestWhereUniqueInput[]
    update?: EmailChangeRequestUpdateWithWhereUniqueWithoutUserInput | EmailChangeRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailChangeRequestUpdateManyWithWhereWithoutUserInput | EmailChangeRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailChangeRequestScalarWhereInput | EmailChangeRequestScalarWhereInput[]
  }

  export type DeviceUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutUserInput | DeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutUserInput | DeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutUserInput | DeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TodoUpdateManyWithoutUserNestedInput = {
    create?: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput> | TodoCreateWithoutUserInput[] | TodoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TodoCreateOrConnectWithoutUserInput | TodoCreateOrConnectWithoutUserInput[]
    upsert?: TodoUpsertWithWhereUniqueWithoutUserInput | TodoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TodoCreateManyUserInputEnvelope
    set?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    disconnect?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    delete?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    connect?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    update?: TodoUpdateWithWhereUniqueWithoutUserInput | TodoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TodoUpdateManyWithWhereWithoutUserInput | TodoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TodoScalarWhereInput | TodoScalarWhereInput[]
  }

  export type EventUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUserInput | EventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUserInput | EventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUserInput | EventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type FileUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<FileCreateWithoutOwnerInput, FileUncheckedCreateWithoutOwnerInput> | FileCreateWithoutOwnerInput[] | FileUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: FileCreateOrConnectWithoutOwnerInput | FileCreateOrConnectWithoutOwnerInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutOwnerInput | FileUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: FileCreateManyOwnerInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutOwnerInput | FileUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: FileUpdateManyWithWhereWithoutOwnerInput | FileUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type UserSettingsUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    connectOrCreate?: UserSettingsCreateOrConnectWithoutUserInput
    upsert?: UserSettingsUpsertWithoutUserInput
    disconnect?: UserSettingsWhereInput | boolean
    delete?: UserSettingsWhereInput | boolean
    connect?: UserSettingsWhereUniqueInput
    update?: XOR<XOR<UserSettingsUpdateToOneWithWhereWithoutUserInput, UserSettingsUpdateWithoutUserInput>, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type TeacherProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<TeacherProfileCreateWithoutUserInput, TeacherProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutUserInput
    upsert?: TeacherProfileUpsertWithoutUserInput
    disconnect?: TeacherProfileWhereInput | boolean
    delete?: TeacherProfileWhereInput | boolean
    connect?: TeacherProfileWhereUniqueInput
    update?: XOR<XOR<TeacherProfileUpdateToOneWithWhereWithoutUserInput, TeacherProfileUpdateWithoutUserInput>, TeacherProfileUncheckedUpdateWithoutUserInput>
  }

  export type StudentProfileUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutUserInput
    upsert?: StudentProfileUpsertWithoutUserInput
    disconnect?: StudentProfileWhereInput | boolean
    delete?: StudentProfileWhereInput | boolean
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutUserInput, StudentProfileUpdateWithoutUserInput>, StudentProfileUncheckedUpdateWithoutUserInput>
  }

  export type AccountUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput> | AccountCreateWithoutUserInput[] | AccountUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AccountCreateOrConnectWithoutUserInput | AccountCreateOrConnectWithoutUserInput[]
    upsert?: AccountUpsertWithWhereUniqueWithoutUserInput | AccountUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AccountCreateManyUserInputEnvelope
    set?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    disconnect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    delete?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    connect?: AccountWhereUniqueInput | AccountWhereUniqueInput[]
    update?: AccountUpdateWithWhereUniqueWithoutUserInput | AccountUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AccountUpdateManyWithWhereWithoutUserInput | AccountUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AccountScalarWhereInput | AccountScalarWhereInput[]
  }

  export type SessionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput> | SessionCreateWithoutUserInput[] | SessionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: SessionCreateOrConnectWithoutUserInput | SessionCreateOrConnectWithoutUserInput[]
    upsert?: SessionUpsertWithWhereUniqueWithoutUserInput | SessionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: SessionCreateManyUserInputEnvelope
    set?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    disconnect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    delete?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    connect?: SessionWhereUniqueInput | SessionWhereUniqueInput[]
    update?: SessionUpdateWithWhereUniqueWithoutUserInput | SessionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: SessionUpdateManyWithWhereWithoutUserInput | SessionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: SessionScalarWhereInput | SessionScalarWhereInput[]
  }

  export type EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EmailChangeRequestCreateWithoutUserInput, EmailChangeRequestUncheckedCreateWithoutUserInput> | EmailChangeRequestCreateWithoutUserInput[] | EmailChangeRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EmailChangeRequestCreateOrConnectWithoutUserInput | EmailChangeRequestCreateOrConnectWithoutUserInput[]
    upsert?: EmailChangeRequestUpsertWithWhereUniqueWithoutUserInput | EmailChangeRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EmailChangeRequestCreateManyUserInputEnvelope
    set?: EmailChangeRequestWhereUniqueInput | EmailChangeRequestWhereUniqueInput[]
    disconnect?: EmailChangeRequestWhereUniqueInput | EmailChangeRequestWhereUniqueInput[]
    delete?: EmailChangeRequestWhereUniqueInput | EmailChangeRequestWhereUniqueInput[]
    connect?: EmailChangeRequestWhereUniqueInput | EmailChangeRequestWhereUniqueInput[]
    update?: EmailChangeRequestUpdateWithWhereUniqueWithoutUserInput | EmailChangeRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EmailChangeRequestUpdateManyWithWhereWithoutUserInput | EmailChangeRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EmailChangeRequestScalarWhereInput | EmailChangeRequestScalarWhereInput[]
  }

  export type DeviceUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput> | DeviceCreateWithoutUserInput[] | DeviceUncheckedCreateWithoutUserInput[]
    connectOrCreate?: DeviceCreateOrConnectWithoutUserInput | DeviceCreateOrConnectWithoutUserInput[]
    upsert?: DeviceUpsertWithWhereUniqueWithoutUserInput | DeviceUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: DeviceCreateManyUserInputEnvelope
    set?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    disconnect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    delete?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    connect?: DeviceWhereUniqueInput | DeviceWhereUniqueInput[]
    update?: DeviceUpdateWithWhereUniqueWithoutUserInput | DeviceUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: DeviceUpdateManyWithWhereWithoutUserInput | DeviceUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput> | NotificationCreateWithoutUserInput[] | NotificationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutUserInput | NotificationCreateOrConnectWithoutUserInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutUserInput | NotificationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: NotificationCreateManyUserInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutUserInput | NotificationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutUserInput | NotificationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput> | MessageCreateWithoutSenderInput[] | MessageUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutSenderInput | MessageCreateOrConnectWithoutSenderInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutSenderInput | MessageUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: MessageCreateManySenderInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutSenderInput | MessageUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutSenderInput | MessageUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutReceiverNestedInput = {
    create?: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput> | MessageCreateWithoutReceiverInput[] | MessageUncheckedCreateWithoutReceiverInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutReceiverInput | MessageCreateOrConnectWithoutReceiverInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutReceiverInput | MessageUpsertWithWhereUniqueWithoutReceiverInput[]
    createMany?: MessageCreateManyReceiverInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutReceiverInput | MessageUpdateWithWhereUniqueWithoutReceiverInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutReceiverInput | MessageUpdateManyWithWhereWithoutReceiverInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type TodoUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput> | TodoCreateWithoutUserInput[] | TodoUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TodoCreateOrConnectWithoutUserInput | TodoCreateOrConnectWithoutUserInput[]
    upsert?: TodoUpsertWithWhereUniqueWithoutUserInput | TodoUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TodoCreateManyUserInputEnvelope
    set?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    disconnect?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    delete?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    connect?: TodoWhereUniqueInput | TodoWhereUniqueInput[]
    update?: TodoUpdateWithWhereUniqueWithoutUserInput | TodoUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TodoUpdateManyWithWhereWithoutUserInput | TodoUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TodoScalarWhereInput | TodoScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput> | EventCreateWithoutUserInput[] | EventUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventCreateOrConnectWithoutUserInput | EventCreateOrConnectWithoutUserInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutUserInput | EventUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventCreateManyUserInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutUserInput | EventUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventUpdateManyWithWhereWithoutUserInput | EventUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type FileUncheckedUpdateManyWithoutOwnerNestedInput = {
    create?: XOR<FileCreateWithoutOwnerInput, FileUncheckedCreateWithoutOwnerInput> | FileCreateWithoutOwnerInput[] | FileUncheckedCreateWithoutOwnerInput[]
    connectOrCreate?: FileCreateOrConnectWithoutOwnerInput | FileCreateOrConnectWithoutOwnerInput[]
    upsert?: FileUpsertWithWhereUniqueWithoutOwnerInput | FileUpsertWithWhereUniqueWithoutOwnerInput[]
    createMany?: FileCreateManyOwnerInputEnvelope
    set?: FileWhereUniqueInput | FileWhereUniqueInput[]
    disconnect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    delete?: FileWhereUniqueInput | FileWhereUniqueInput[]
    connect?: FileWhereUniqueInput | FileWhereUniqueInput[]
    update?: FileUpdateWithWhereUniqueWithoutOwnerInput | FileUpdateWithWhereUniqueWithoutOwnerInput[]
    updateMany?: FileUpdateManyWithWhereWithoutOwnerInput | FileUpdateManyWithWhereWithoutOwnerInput[]
    deleteMany?: FileScalarWhereInput | FileScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutSettingsInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSettingsNestedInput = {
    create?: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSettingsInput
    upsert?: UserUpsertWithoutSettingsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSettingsInput, UserUpdateWithoutSettingsInput>, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserCreateNestedOneWithoutAccountsInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    connect?: UserWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneRequiredWithoutAccountsNestedInput = {
    create?: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAccountsInput
    upsert?: UserUpsertWithoutAccountsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAccountsInput, UserUpdateWithoutAccountsInput>, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserCreateNestedOneWithoutSessionsInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutSessionsNestedInput = {
    create?: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSessionsInput
    upsert?: UserUpsertWithoutSessionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSessionsInput, UserUpdateWithoutSessionsInput>, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserCreateNestedOneWithoutEmailChangeRequestsInput = {
    create?: XOR<UserCreateWithoutEmailChangeRequestsInput, UserUncheckedCreateWithoutEmailChangeRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailChangeRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutEmailChangeRequestsNestedInput = {
    create?: XOR<UserCreateWithoutEmailChangeRequestsInput, UserUncheckedCreateWithoutEmailChangeRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailChangeRequestsInput
    upsert?: UserUpsertWithoutEmailChangeRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailChangeRequestsInput, UserUpdateWithoutEmailChangeRequestsInput>, UserUncheckedUpdateWithoutEmailChangeRequestsInput>
  }

  export type UserCreateNestedOneWithoutDevicesInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    connect?: UserWhereUniqueInput
  }

  export type EnumDeviceTypeFieldUpdateOperationsInput = {
    set?: $Enums.DeviceType
  }

  export type UserUpdateOneRequiredWithoutDevicesNestedInput = {
    create?: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    connectOrCreate?: UserCreateOrConnectWithoutDevicesInput
    upsert?: UserUpsertWithoutDevicesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDevicesInput, UserUpdateWithoutDevicesInput>, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type UserCreateNestedOneWithoutTeacherProfileInput = {
    create?: XOR<UserCreateWithoutTeacherProfileInput, UserUncheckedCreateWithoutTeacherProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherProfileInput
    connect?: UserWhereUniqueInput
  }

  export type StudentTeacherRelationCreateNestedManyWithoutTeacherInput = {
    create?: XOR<StudentTeacherRelationCreateWithoutTeacherInput, StudentTeacherRelationUncheckedCreateWithoutTeacherInput> | StudentTeacherRelationCreateWithoutTeacherInput[] | StudentTeacherRelationUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: StudentTeacherRelationCreateOrConnectWithoutTeacherInput | StudentTeacherRelationCreateOrConnectWithoutTeacherInput[]
    createMany?: StudentTeacherRelationCreateManyTeacherInputEnvelope
    connect?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
  }

  export type ClassroomCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ClassroomCreateWithoutTeacherInput, ClassroomUncheckedCreateWithoutTeacherInput> | ClassroomCreateWithoutTeacherInput[] | ClassroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutTeacherInput | ClassroomCreateOrConnectWithoutTeacherInput[]
    createMany?: ClassroomCreateManyTeacherInputEnvelope
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutTeacherInput = {
    create?: XOR<LessonCreateWithoutTeacherInput, LessonUncheckedCreateWithoutTeacherInput> | LessonCreateWithoutTeacherInput[] | LessonUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutTeacherInput | LessonCreateOrConnectWithoutTeacherInput[]
    createMany?: LessonCreateManyTeacherInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutTeacherInput = {
    create?: XOR<PaymentCreateWithoutTeacherInput, PaymentUncheckedCreateWithoutTeacherInput> | PaymentCreateWithoutTeacherInput[] | PaymentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTeacherInput | PaymentCreateOrConnectWithoutTeacherInput[]
    createMany?: PaymentCreateManyTeacherInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ScheduleItemCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ScheduleItemCreateWithoutTeacherInput, ScheduleItemUncheckedCreateWithoutTeacherInput> | ScheduleItemCreateWithoutTeacherInput[] | ScheduleItemUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutTeacherInput | ScheduleItemCreateOrConnectWithoutTeacherInput[]
    createMany?: ScheduleItemCreateManyTeacherInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type StudentTeacherRelationUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<StudentTeacherRelationCreateWithoutTeacherInput, StudentTeacherRelationUncheckedCreateWithoutTeacherInput> | StudentTeacherRelationCreateWithoutTeacherInput[] | StudentTeacherRelationUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: StudentTeacherRelationCreateOrConnectWithoutTeacherInput | StudentTeacherRelationCreateOrConnectWithoutTeacherInput[]
    createMany?: StudentTeacherRelationCreateManyTeacherInputEnvelope
    connect?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
  }

  export type ClassroomUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ClassroomCreateWithoutTeacherInput, ClassroomUncheckedCreateWithoutTeacherInput> | ClassroomCreateWithoutTeacherInput[] | ClassroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutTeacherInput | ClassroomCreateOrConnectWithoutTeacherInput[]
    createMany?: ClassroomCreateManyTeacherInputEnvelope
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<LessonCreateWithoutTeacherInput, LessonUncheckedCreateWithoutTeacherInput> | LessonCreateWithoutTeacherInput[] | LessonUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutTeacherInput | LessonCreateOrConnectWithoutTeacherInput[]
    createMany?: LessonCreateManyTeacherInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<PaymentCreateWithoutTeacherInput, PaymentUncheckedCreateWithoutTeacherInput> | PaymentCreateWithoutTeacherInput[] | PaymentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTeacherInput | PaymentCreateOrConnectWithoutTeacherInput[]
    createMany?: PaymentCreateManyTeacherInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type ScheduleItemUncheckedCreateNestedManyWithoutTeacherInput = {
    create?: XOR<ScheduleItemCreateWithoutTeacherInput, ScheduleItemUncheckedCreateWithoutTeacherInput> | ScheduleItemCreateWithoutTeacherInput[] | ScheduleItemUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutTeacherInput | ScheduleItemCreateOrConnectWithoutTeacherInput[]
    createMany?: ScheduleItemCreateManyTeacherInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutTeacherProfileNestedInput = {
    create?: XOR<UserCreateWithoutTeacherProfileInput, UserUncheckedCreateWithoutTeacherProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeacherProfileInput
    upsert?: UserUpsertWithoutTeacherProfileInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeacherProfileInput, UserUpdateWithoutTeacherProfileInput>, UserUncheckedUpdateWithoutTeacherProfileInput>
  }

  export type StudentTeacherRelationUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<StudentTeacherRelationCreateWithoutTeacherInput, StudentTeacherRelationUncheckedCreateWithoutTeacherInput> | StudentTeacherRelationCreateWithoutTeacherInput[] | StudentTeacherRelationUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: StudentTeacherRelationCreateOrConnectWithoutTeacherInput | StudentTeacherRelationCreateOrConnectWithoutTeacherInput[]
    upsert?: StudentTeacherRelationUpsertWithWhereUniqueWithoutTeacherInput | StudentTeacherRelationUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: StudentTeacherRelationCreateManyTeacherInputEnvelope
    set?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    disconnect?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    delete?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    connect?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    update?: StudentTeacherRelationUpdateWithWhereUniqueWithoutTeacherInput | StudentTeacherRelationUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: StudentTeacherRelationUpdateManyWithWhereWithoutTeacherInput | StudentTeacherRelationUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: StudentTeacherRelationScalarWhereInput | StudentTeacherRelationScalarWhereInput[]
  }

  export type ClassroomUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ClassroomCreateWithoutTeacherInput, ClassroomUncheckedCreateWithoutTeacherInput> | ClassroomCreateWithoutTeacherInput[] | ClassroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutTeacherInput | ClassroomCreateOrConnectWithoutTeacherInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutTeacherInput | ClassroomUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ClassroomCreateManyTeacherInputEnvelope
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutTeacherInput | ClassroomUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutTeacherInput | ClassroomUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<LessonCreateWithoutTeacherInput, LessonUncheckedCreateWithoutTeacherInput> | LessonCreateWithoutTeacherInput[] | LessonUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutTeacherInput | LessonCreateOrConnectWithoutTeacherInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutTeacherInput | LessonUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: LessonCreateManyTeacherInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutTeacherInput | LessonUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutTeacherInput | LessonUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<PaymentCreateWithoutTeacherInput, PaymentUncheckedCreateWithoutTeacherInput> | PaymentCreateWithoutTeacherInput[] | PaymentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTeacherInput | PaymentCreateOrConnectWithoutTeacherInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTeacherInput | PaymentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: PaymentCreateManyTeacherInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTeacherInput | PaymentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTeacherInput | PaymentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ScheduleItemUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutTeacherInput, ScheduleItemUncheckedCreateWithoutTeacherInput> | ScheduleItemCreateWithoutTeacherInput[] | ScheduleItemUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutTeacherInput | ScheduleItemCreateOrConnectWithoutTeacherInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutTeacherInput | ScheduleItemUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ScheduleItemCreateManyTeacherInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutTeacherInput | ScheduleItemUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutTeacherInput | ScheduleItemUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type StudentTeacherRelationUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<StudentTeacherRelationCreateWithoutTeacherInput, StudentTeacherRelationUncheckedCreateWithoutTeacherInput> | StudentTeacherRelationCreateWithoutTeacherInput[] | StudentTeacherRelationUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: StudentTeacherRelationCreateOrConnectWithoutTeacherInput | StudentTeacherRelationCreateOrConnectWithoutTeacherInput[]
    upsert?: StudentTeacherRelationUpsertWithWhereUniqueWithoutTeacherInput | StudentTeacherRelationUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: StudentTeacherRelationCreateManyTeacherInputEnvelope
    set?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    disconnect?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    delete?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    connect?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    update?: StudentTeacherRelationUpdateWithWhereUniqueWithoutTeacherInput | StudentTeacherRelationUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: StudentTeacherRelationUpdateManyWithWhereWithoutTeacherInput | StudentTeacherRelationUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: StudentTeacherRelationScalarWhereInput | StudentTeacherRelationScalarWhereInput[]
  }

  export type ClassroomUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ClassroomCreateWithoutTeacherInput, ClassroomUncheckedCreateWithoutTeacherInput> | ClassroomCreateWithoutTeacherInput[] | ClassroomUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutTeacherInput | ClassroomCreateOrConnectWithoutTeacherInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutTeacherInput | ClassroomUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ClassroomCreateManyTeacherInputEnvelope
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutTeacherInput | ClassroomUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutTeacherInput | ClassroomUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<LessonCreateWithoutTeacherInput, LessonUncheckedCreateWithoutTeacherInput> | LessonCreateWithoutTeacherInput[] | LessonUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutTeacherInput | LessonCreateOrConnectWithoutTeacherInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutTeacherInput | LessonUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: LessonCreateManyTeacherInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutTeacherInput | LessonUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutTeacherInput | LessonUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<PaymentCreateWithoutTeacherInput, PaymentUncheckedCreateWithoutTeacherInput> | PaymentCreateWithoutTeacherInput[] | PaymentUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutTeacherInput | PaymentCreateOrConnectWithoutTeacherInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutTeacherInput | PaymentUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: PaymentCreateManyTeacherInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutTeacherInput | PaymentUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutTeacherInput | PaymentUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type ScheduleItemUncheckedUpdateManyWithoutTeacherNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutTeacherInput, ScheduleItemUncheckedCreateWithoutTeacherInput> | ScheduleItemCreateWithoutTeacherInput[] | ScheduleItemUncheckedCreateWithoutTeacherInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutTeacherInput | ScheduleItemCreateOrConnectWithoutTeacherInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutTeacherInput | ScheduleItemUpsertWithWhereUniqueWithoutTeacherInput[]
    createMany?: ScheduleItemCreateManyTeacherInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutTeacherInput | ScheduleItemUpdateWithWhereUniqueWithoutTeacherInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutTeacherInput | ScheduleItemUpdateManyWithWhereWithoutTeacherInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutStudentProfileInput = {
    create?: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentProfileInput
    connect?: UserWhereUniqueInput
  }

  export type StudentTeacherRelationCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentTeacherRelationCreateWithoutStudentInput, StudentTeacherRelationUncheckedCreateWithoutStudentInput> | StudentTeacherRelationCreateWithoutStudentInput[] | StudentTeacherRelationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTeacherRelationCreateOrConnectWithoutStudentInput | StudentTeacherRelationCreateOrConnectWithoutStudentInput[]
    createMany?: StudentTeacherRelationCreateManyStudentInputEnvelope
    connect?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
  }

  export type ClassroomCreateNestedManyWithoutStudentsInput = {
    create?: XOR<ClassroomCreateWithoutStudentsInput, ClassroomUncheckedCreateWithoutStudentsInput> | ClassroomCreateWithoutStudentsInput[] | ClassroomUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutStudentsInput | ClassroomCreateOrConnectWithoutStudentsInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type ScheduleItemCreateNestedManyWithoutStudentInput = {
    create?: XOR<ScheduleItemCreateWithoutStudentInput, ScheduleItemUncheckedCreateWithoutStudentInput> | ScheduleItemCreateWithoutStudentInput[] | ScheduleItemUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutStudentInput | ScheduleItemCreateOrConnectWithoutStudentInput[]
    createMany?: ScheduleItemCreateManyStudentInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutStudentsInput = {
    create?: XOR<LessonCreateWithoutStudentsInput, LessonUncheckedCreateWithoutStudentsInput> | LessonCreateWithoutStudentsInput[] | LessonUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutStudentsInput | LessonCreateOrConnectWithoutStudentsInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type HomeworkTrackingCreateNestedManyWithoutStudentInput = {
    create?: XOR<HomeworkTrackingCreateWithoutStudentInput, HomeworkTrackingUncheckedCreateWithoutStudentInput> | HomeworkTrackingCreateWithoutStudentInput[] | HomeworkTrackingUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HomeworkTrackingCreateOrConnectWithoutStudentInput | HomeworkTrackingCreateOrConnectWithoutStudentInput[]
    createMany?: HomeworkTrackingCreateManyStudentInputEnvelope
    connect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
  }

  export type HomeworkSubmissionCreateNestedManyWithoutStudentInput = {
    create?: XOR<HomeworkSubmissionCreateWithoutStudentInput, HomeworkSubmissionUncheckedCreateWithoutStudentInput> | HomeworkSubmissionCreateWithoutStudentInput[] | HomeworkSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HomeworkSubmissionCreateOrConnectWithoutStudentInput | HomeworkSubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: HomeworkSubmissionCreateManyStudentInputEnvelope
    connect?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutStudentInput = {
    create?: XOR<PaymentCreateWithoutStudentInput, PaymentUncheckedCreateWithoutStudentInput> | PaymentCreateWithoutStudentInput[] | PaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStudentInput | PaymentCreateOrConnectWithoutStudentInput[]
    createMany?: PaymentCreateManyStudentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SchoolExamCreateNestedManyWithoutStudentInput = {
    create?: XOR<SchoolExamCreateWithoutStudentInput, SchoolExamUncheckedCreateWithoutStudentInput> | SchoolExamCreateWithoutStudentInput[] | SchoolExamUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SchoolExamCreateOrConnectWithoutStudentInput | SchoolExamCreateOrConnectWithoutStudentInput[]
    createMany?: SchoolExamCreateManyStudentInputEnvelope
    connect?: SchoolExamWhereUniqueInput | SchoolExamWhereUniqueInput[]
  }

  export type TrialExamCreateNestedManyWithoutStudentInput = {
    create?: XOR<TrialExamCreateWithoutStudentInput, TrialExamUncheckedCreateWithoutStudentInput> | TrialExamCreateWithoutStudentInput[] | TrialExamUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TrialExamCreateOrConnectWithoutStudentInput | TrialExamCreateOrConnectWithoutStudentInput[]
    createMany?: TrialExamCreateManyStudentInputEnvelope
    connect?: TrialExamWhereUniqueInput | TrialExamWhereUniqueInput[]
  }

  export type AttendanceCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type StudentTeacherRelationUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<StudentTeacherRelationCreateWithoutStudentInput, StudentTeacherRelationUncheckedCreateWithoutStudentInput> | StudentTeacherRelationCreateWithoutStudentInput[] | StudentTeacherRelationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTeacherRelationCreateOrConnectWithoutStudentInput | StudentTeacherRelationCreateOrConnectWithoutStudentInput[]
    createMany?: StudentTeacherRelationCreateManyStudentInputEnvelope
    connect?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
  }

  export type ClassroomUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<ClassroomCreateWithoutStudentsInput, ClassroomUncheckedCreateWithoutStudentsInput> | ClassroomCreateWithoutStudentsInput[] | ClassroomUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutStudentsInput | ClassroomCreateOrConnectWithoutStudentsInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
  }

  export type ScheduleItemUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<ScheduleItemCreateWithoutStudentInput, ScheduleItemUncheckedCreateWithoutStudentInput> | ScheduleItemCreateWithoutStudentInput[] | ScheduleItemUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutStudentInput | ScheduleItemCreateOrConnectWithoutStudentInput[]
    createMany?: ScheduleItemCreateManyStudentInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutStudentsInput = {
    create?: XOR<LessonCreateWithoutStudentsInput, LessonUncheckedCreateWithoutStudentsInput> | LessonCreateWithoutStudentsInput[] | LessonUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutStudentsInput | LessonCreateOrConnectWithoutStudentsInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type HomeworkTrackingUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<HomeworkTrackingCreateWithoutStudentInput, HomeworkTrackingUncheckedCreateWithoutStudentInput> | HomeworkTrackingCreateWithoutStudentInput[] | HomeworkTrackingUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HomeworkTrackingCreateOrConnectWithoutStudentInput | HomeworkTrackingCreateOrConnectWithoutStudentInput[]
    createMany?: HomeworkTrackingCreateManyStudentInputEnvelope
    connect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
  }

  export type HomeworkSubmissionUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<HomeworkSubmissionCreateWithoutStudentInput, HomeworkSubmissionUncheckedCreateWithoutStudentInput> | HomeworkSubmissionCreateWithoutStudentInput[] | HomeworkSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HomeworkSubmissionCreateOrConnectWithoutStudentInput | HomeworkSubmissionCreateOrConnectWithoutStudentInput[]
    createMany?: HomeworkSubmissionCreateManyStudentInputEnvelope
    connect?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<PaymentCreateWithoutStudentInput, PaymentUncheckedCreateWithoutStudentInput> | PaymentCreateWithoutStudentInput[] | PaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStudentInput | PaymentCreateOrConnectWithoutStudentInput[]
    createMany?: PaymentCreateManyStudentInputEnvelope
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type SchoolExamUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<SchoolExamCreateWithoutStudentInput, SchoolExamUncheckedCreateWithoutStudentInput> | SchoolExamCreateWithoutStudentInput[] | SchoolExamUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SchoolExamCreateOrConnectWithoutStudentInput | SchoolExamCreateOrConnectWithoutStudentInput[]
    createMany?: SchoolExamCreateManyStudentInputEnvelope
    connect?: SchoolExamWhereUniqueInput | SchoolExamWhereUniqueInput[]
  }

  export type TrialExamUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<TrialExamCreateWithoutStudentInput, TrialExamUncheckedCreateWithoutStudentInput> | TrialExamCreateWithoutStudentInput[] | TrialExamUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TrialExamCreateOrConnectWithoutStudentInput | TrialExamCreateOrConnectWithoutStudentInput[]
    createMany?: TrialExamCreateManyStudentInputEnvelope
    connect?: TrialExamWhereUniqueInput | TrialExamWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutStudentInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutStudentProfileNestedInput = {
    create?: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    connectOrCreate?: UserCreateOrConnectWithoutStudentProfileInput
    upsert?: UserUpsertWithoutStudentProfileInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutStudentProfileInput, UserUpdateWithoutStudentProfileInput>, UserUncheckedUpdateWithoutStudentProfileInput>
  }

  export type StudentTeacherRelationUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentTeacherRelationCreateWithoutStudentInput, StudentTeacherRelationUncheckedCreateWithoutStudentInput> | StudentTeacherRelationCreateWithoutStudentInput[] | StudentTeacherRelationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTeacherRelationCreateOrConnectWithoutStudentInput | StudentTeacherRelationCreateOrConnectWithoutStudentInput[]
    upsert?: StudentTeacherRelationUpsertWithWhereUniqueWithoutStudentInput | StudentTeacherRelationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentTeacherRelationCreateManyStudentInputEnvelope
    set?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    disconnect?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    delete?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    connect?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    update?: StudentTeacherRelationUpdateWithWhereUniqueWithoutStudentInput | StudentTeacherRelationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentTeacherRelationUpdateManyWithWhereWithoutStudentInput | StudentTeacherRelationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentTeacherRelationScalarWhereInput | StudentTeacherRelationScalarWhereInput[]
  }

  export type ClassroomUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<ClassroomCreateWithoutStudentsInput, ClassroomUncheckedCreateWithoutStudentsInput> | ClassroomCreateWithoutStudentsInput[] | ClassroomUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutStudentsInput | ClassroomCreateOrConnectWithoutStudentsInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutStudentsInput | ClassroomUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutStudentsInput | ClassroomUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutStudentsInput | ClassroomUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type ScheduleItemUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutStudentInput, ScheduleItemUncheckedCreateWithoutStudentInput> | ScheduleItemCreateWithoutStudentInput[] | ScheduleItemUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutStudentInput | ScheduleItemCreateOrConnectWithoutStudentInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutStudentInput | ScheduleItemUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ScheduleItemCreateManyStudentInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutStudentInput | ScheduleItemUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutStudentInput | ScheduleItemUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<LessonCreateWithoutStudentsInput, LessonUncheckedCreateWithoutStudentsInput> | LessonCreateWithoutStudentsInput[] | LessonUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutStudentsInput | LessonCreateOrConnectWithoutStudentsInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutStudentsInput | LessonUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutStudentsInput | LessonUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutStudentsInput | LessonUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type HomeworkTrackingUpdateManyWithoutStudentNestedInput = {
    create?: XOR<HomeworkTrackingCreateWithoutStudentInput, HomeworkTrackingUncheckedCreateWithoutStudentInput> | HomeworkTrackingCreateWithoutStudentInput[] | HomeworkTrackingUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HomeworkTrackingCreateOrConnectWithoutStudentInput | HomeworkTrackingCreateOrConnectWithoutStudentInput[]
    upsert?: HomeworkTrackingUpsertWithWhereUniqueWithoutStudentInput | HomeworkTrackingUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: HomeworkTrackingCreateManyStudentInputEnvelope
    set?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    disconnect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    delete?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    connect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    update?: HomeworkTrackingUpdateWithWhereUniqueWithoutStudentInput | HomeworkTrackingUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: HomeworkTrackingUpdateManyWithWhereWithoutStudentInput | HomeworkTrackingUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: HomeworkTrackingScalarWhereInput | HomeworkTrackingScalarWhereInput[]
  }

  export type HomeworkSubmissionUpdateManyWithoutStudentNestedInput = {
    create?: XOR<HomeworkSubmissionCreateWithoutStudentInput, HomeworkSubmissionUncheckedCreateWithoutStudentInput> | HomeworkSubmissionCreateWithoutStudentInput[] | HomeworkSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HomeworkSubmissionCreateOrConnectWithoutStudentInput | HomeworkSubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: HomeworkSubmissionUpsertWithWhereUniqueWithoutStudentInput | HomeworkSubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: HomeworkSubmissionCreateManyStudentInputEnvelope
    set?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    disconnect?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    delete?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    connect?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    update?: HomeworkSubmissionUpdateWithWhereUniqueWithoutStudentInput | HomeworkSubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: HomeworkSubmissionUpdateManyWithWhereWithoutStudentInput | HomeworkSubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: HomeworkSubmissionScalarWhereInput | HomeworkSubmissionScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PaymentCreateWithoutStudentInput, PaymentUncheckedCreateWithoutStudentInput> | PaymentCreateWithoutStudentInput[] | PaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStudentInput | PaymentCreateOrConnectWithoutStudentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutStudentInput | PaymentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PaymentCreateManyStudentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutStudentInput | PaymentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutStudentInput | PaymentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SchoolExamUpdateManyWithoutStudentNestedInput = {
    create?: XOR<SchoolExamCreateWithoutStudentInput, SchoolExamUncheckedCreateWithoutStudentInput> | SchoolExamCreateWithoutStudentInput[] | SchoolExamUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SchoolExamCreateOrConnectWithoutStudentInput | SchoolExamCreateOrConnectWithoutStudentInput[]
    upsert?: SchoolExamUpsertWithWhereUniqueWithoutStudentInput | SchoolExamUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: SchoolExamCreateManyStudentInputEnvelope
    set?: SchoolExamWhereUniqueInput | SchoolExamWhereUniqueInput[]
    disconnect?: SchoolExamWhereUniqueInput | SchoolExamWhereUniqueInput[]
    delete?: SchoolExamWhereUniqueInput | SchoolExamWhereUniqueInput[]
    connect?: SchoolExamWhereUniqueInput | SchoolExamWhereUniqueInput[]
    update?: SchoolExamUpdateWithWhereUniqueWithoutStudentInput | SchoolExamUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: SchoolExamUpdateManyWithWhereWithoutStudentInput | SchoolExamUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: SchoolExamScalarWhereInput | SchoolExamScalarWhereInput[]
  }

  export type TrialExamUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TrialExamCreateWithoutStudentInput, TrialExamUncheckedCreateWithoutStudentInput> | TrialExamCreateWithoutStudentInput[] | TrialExamUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TrialExamCreateOrConnectWithoutStudentInput | TrialExamCreateOrConnectWithoutStudentInput[]
    upsert?: TrialExamUpsertWithWhereUniqueWithoutStudentInput | TrialExamUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TrialExamCreateManyStudentInputEnvelope
    set?: TrialExamWhereUniqueInput | TrialExamWhereUniqueInput[]
    disconnect?: TrialExamWhereUniqueInput | TrialExamWhereUniqueInput[]
    delete?: TrialExamWhereUniqueInput | TrialExamWhereUniqueInput[]
    connect?: TrialExamWhereUniqueInput | TrialExamWhereUniqueInput[]
    update?: TrialExamUpdateWithWhereUniqueWithoutStudentInput | TrialExamUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TrialExamUpdateManyWithWhereWithoutStudentInput | TrialExamUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TrialExamScalarWhereInput | TrialExamScalarWhereInput[]
  }

  export type AttendanceUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStudentInput | AttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStudentInput | AttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStudentInput | AttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type StudentTeacherRelationUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<StudentTeacherRelationCreateWithoutStudentInput, StudentTeacherRelationUncheckedCreateWithoutStudentInput> | StudentTeacherRelationCreateWithoutStudentInput[] | StudentTeacherRelationUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: StudentTeacherRelationCreateOrConnectWithoutStudentInput | StudentTeacherRelationCreateOrConnectWithoutStudentInput[]
    upsert?: StudentTeacherRelationUpsertWithWhereUniqueWithoutStudentInput | StudentTeacherRelationUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: StudentTeacherRelationCreateManyStudentInputEnvelope
    set?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    disconnect?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    delete?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    connect?: StudentTeacherRelationWhereUniqueInput | StudentTeacherRelationWhereUniqueInput[]
    update?: StudentTeacherRelationUpdateWithWhereUniqueWithoutStudentInput | StudentTeacherRelationUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: StudentTeacherRelationUpdateManyWithWhereWithoutStudentInput | StudentTeacherRelationUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: StudentTeacherRelationScalarWhereInput | StudentTeacherRelationScalarWhereInput[]
  }

  export type ClassroomUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<ClassroomCreateWithoutStudentsInput, ClassroomUncheckedCreateWithoutStudentsInput> | ClassroomCreateWithoutStudentsInput[] | ClassroomUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: ClassroomCreateOrConnectWithoutStudentsInput | ClassroomCreateOrConnectWithoutStudentsInput[]
    upsert?: ClassroomUpsertWithWhereUniqueWithoutStudentsInput | ClassroomUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    disconnect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    delete?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    connect?: ClassroomWhereUniqueInput | ClassroomWhereUniqueInput[]
    update?: ClassroomUpdateWithWhereUniqueWithoutStudentsInput | ClassroomUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: ClassroomUpdateManyWithWhereWithoutStudentsInput | ClassroomUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
  }

  export type ScheduleItemUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutStudentInput, ScheduleItemUncheckedCreateWithoutStudentInput> | ScheduleItemCreateWithoutStudentInput[] | ScheduleItemUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutStudentInput | ScheduleItemCreateOrConnectWithoutStudentInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutStudentInput | ScheduleItemUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: ScheduleItemCreateManyStudentInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutStudentInput | ScheduleItemUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutStudentInput | ScheduleItemUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutStudentsNestedInput = {
    create?: XOR<LessonCreateWithoutStudentsInput, LessonUncheckedCreateWithoutStudentsInput> | LessonCreateWithoutStudentsInput[] | LessonUncheckedCreateWithoutStudentsInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutStudentsInput | LessonCreateOrConnectWithoutStudentsInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutStudentsInput | LessonUpsertWithWhereUniqueWithoutStudentsInput[]
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutStudentsInput | LessonUpdateWithWhereUniqueWithoutStudentsInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutStudentsInput | LessonUpdateManyWithWhereWithoutStudentsInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type HomeworkTrackingUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<HomeworkTrackingCreateWithoutStudentInput, HomeworkTrackingUncheckedCreateWithoutStudentInput> | HomeworkTrackingCreateWithoutStudentInput[] | HomeworkTrackingUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HomeworkTrackingCreateOrConnectWithoutStudentInput | HomeworkTrackingCreateOrConnectWithoutStudentInput[]
    upsert?: HomeworkTrackingUpsertWithWhereUniqueWithoutStudentInput | HomeworkTrackingUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: HomeworkTrackingCreateManyStudentInputEnvelope
    set?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    disconnect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    delete?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    connect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    update?: HomeworkTrackingUpdateWithWhereUniqueWithoutStudentInput | HomeworkTrackingUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: HomeworkTrackingUpdateManyWithWhereWithoutStudentInput | HomeworkTrackingUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: HomeworkTrackingScalarWhereInput | HomeworkTrackingScalarWhereInput[]
  }

  export type HomeworkSubmissionUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<HomeworkSubmissionCreateWithoutStudentInput, HomeworkSubmissionUncheckedCreateWithoutStudentInput> | HomeworkSubmissionCreateWithoutStudentInput[] | HomeworkSubmissionUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: HomeworkSubmissionCreateOrConnectWithoutStudentInput | HomeworkSubmissionCreateOrConnectWithoutStudentInput[]
    upsert?: HomeworkSubmissionUpsertWithWhereUniqueWithoutStudentInput | HomeworkSubmissionUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: HomeworkSubmissionCreateManyStudentInputEnvelope
    set?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    disconnect?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    delete?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    connect?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    update?: HomeworkSubmissionUpdateWithWhereUniqueWithoutStudentInput | HomeworkSubmissionUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: HomeworkSubmissionUpdateManyWithWhereWithoutStudentInput | HomeworkSubmissionUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: HomeworkSubmissionScalarWhereInput | HomeworkSubmissionScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<PaymentCreateWithoutStudentInput, PaymentUncheckedCreateWithoutStudentInput> | PaymentCreateWithoutStudentInput[] | PaymentUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutStudentInput | PaymentCreateOrConnectWithoutStudentInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutStudentInput | PaymentUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: PaymentCreateManyStudentInputEnvelope
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutStudentInput | PaymentUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutStudentInput | PaymentUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type SchoolExamUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<SchoolExamCreateWithoutStudentInput, SchoolExamUncheckedCreateWithoutStudentInput> | SchoolExamCreateWithoutStudentInput[] | SchoolExamUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: SchoolExamCreateOrConnectWithoutStudentInput | SchoolExamCreateOrConnectWithoutStudentInput[]
    upsert?: SchoolExamUpsertWithWhereUniqueWithoutStudentInput | SchoolExamUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: SchoolExamCreateManyStudentInputEnvelope
    set?: SchoolExamWhereUniqueInput | SchoolExamWhereUniqueInput[]
    disconnect?: SchoolExamWhereUniqueInput | SchoolExamWhereUniqueInput[]
    delete?: SchoolExamWhereUniqueInput | SchoolExamWhereUniqueInput[]
    connect?: SchoolExamWhereUniqueInput | SchoolExamWhereUniqueInput[]
    update?: SchoolExamUpdateWithWhereUniqueWithoutStudentInput | SchoolExamUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: SchoolExamUpdateManyWithWhereWithoutStudentInput | SchoolExamUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: SchoolExamScalarWhereInput | SchoolExamScalarWhereInput[]
  }

  export type TrialExamUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<TrialExamCreateWithoutStudentInput, TrialExamUncheckedCreateWithoutStudentInput> | TrialExamCreateWithoutStudentInput[] | TrialExamUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: TrialExamCreateOrConnectWithoutStudentInput | TrialExamCreateOrConnectWithoutStudentInput[]
    upsert?: TrialExamUpsertWithWhereUniqueWithoutStudentInput | TrialExamUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: TrialExamCreateManyStudentInputEnvelope
    set?: TrialExamWhereUniqueInput | TrialExamWhereUniqueInput[]
    disconnect?: TrialExamWhereUniqueInput | TrialExamWhereUniqueInput[]
    delete?: TrialExamWhereUniqueInput | TrialExamWhereUniqueInput[]
    connect?: TrialExamWhereUniqueInput | TrialExamWhereUniqueInput[]
    update?: TrialExamUpdateWithWhereUniqueWithoutStudentInput | TrialExamUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: TrialExamUpdateManyWithWhereWithoutStudentInput | TrialExamUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: TrialExamScalarWhereInput | TrialExamScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutStudentNestedInput = {
    create?: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput> | AttendanceCreateWithoutStudentInput[] | AttendanceUncheckedCreateWithoutStudentInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutStudentInput | AttendanceCreateOrConnectWithoutStudentInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutStudentInput | AttendanceUpsertWithWhereUniqueWithoutStudentInput[]
    createMany?: AttendanceCreateManyStudentInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutStudentInput | AttendanceUpdateWithWhereUniqueWithoutStudentInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutStudentInput | AttendanceUpdateManyWithWhereWithoutStudentInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type TeacherProfileCreateNestedOneWithoutStudentRelationsInput = {
    create?: XOR<TeacherProfileCreateWithoutStudentRelationsInput, TeacherProfileUncheckedCreateWithoutStudentRelationsInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutStudentRelationsInput
    connect?: TeacherProfileWhereUniqueInput
  }

  export type StudentProfileCreateNestedOneWithoutTeacherRelationsInput = {
    create?: XOR<StudentProfileCreateWithoutTeacherRelationsInput, StudentProfileUncheckedCreateWithoutTeacherRelationsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutTeacherRelationsInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type EnumRelationStatusFieldUpdateOperationsInput = {
    set?: $Enums.RelationStatus
  }

  export type TeacherProfileUpdateOneRequiredWithoutStudentRelationsNestedInput = {
    create?: XOR<TeacherProfileCreateWithoutStudentRelationsInput, TeacherProfileUncheckedCreateWithoutStudentRelationsInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutStudentRelationsInput
    upsert?: TeacherProfileUpsertWithoutStudentRelationsInput
    connect?: TeacherProfileWhereUniqueInput
    update?: XOR<XOR<TeacherProfileUpdateToOneWithWhereWithoutStudentRelationsInput, TeacherProfileUpdateWithoutStudentRelationsInput>, TeacherProfileUncheckedUpdateWithoutStudentRelationsInput>
  }

  export type StudentProfileUpdateOneRequiredWithoutTeacherRelationsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutTeacherRelationsInput, StudentProfileUncheckedCreateWithoutTeacherRelationsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutTeacherRelationsInput
    upsert?: StudentProfileUpsertWithoutTeacherRelationsInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutTeacherRelationsInput, StudentProfileUpdateWithoutTeacherRelationsInput>, StudentProfileUncheckedUpdateWithoutTeacherRelationsInput>
  }

  export type TeacherProfileCreateNestedOneWithoutClassesInput = {
    create?: XOR<TeacherProfileCreateWithoutClassesInput, TeacherProfileUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutClassesInput
    connect?: TeacherProfileWhereUniqueInput
  }

  export type StudentProfileCreateNestedManyWithoutClassroomsInput = {
    create?: XOR<StudentProfileCreateWithoutClassroomsInput, StudentProfileUncheckedCreateWithoutClassroomsInput> | StudentProfileCreateWithoutClassroomsInput[] | StudentProfileUncheckedCreateWithoutClassroomsInput[]
    connectOrCreate?: StudentProfileCreateOrConnectWithoutClassroomsInput | StudentProfileCreateOrConnectWithoutClassroomsInput[]
    connect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
  }

  export type ScheduleItemCreateNestedManyWithoutClassroomInput = {
    create?: XOR<ScheduleItemCreateWithoutClassroomInput, ScheduleItemUncheckedCreateWithoutClassroomInput> | ScheduleItemCreateWithoutClassroomInput[] | ScheduleItemUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutClassroomInput | ScheduleItemCreateOrConnectWithoutClassroomInput[]
    createMany?: ScheduleItemCreateManyClassroomInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type LessonCreateNestedManyWithoutClassroomInput = {
    create?: XOR<LessonCreateWithoutClassroomInput, LessonUncheckedCreateWithoutClassroomInput> | LessonCreateWithoutClassroomInput[] | LessonUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutClassroomInput | LessonCreateOrConnectWithoutClassroomInput[]
    createMany?: LessonCreateManyClassroomInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type StudentProfileUncheckedCreateNestedManyWithoutClassroomsInput = {
    create?: XOR<StudentProfileCreateWithoutClassroomsInput, StudentProfileUncheckedCreateWithoutClassroomsInput> | StudentProfileCreateWithoutClassroomsInput[] | StudentProfileUncheckedCreateWithoutClassroomsInput[]
    connectOrCreate?: StudentProfileCreateOrConnectWithoutClassroomsInput | StudentProfileCreateOrConnectWithoutClassroomsInput[]
    connect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
  }

  export type ScheduleItemUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<ScheduleItemCreateWithoutClassroomInput, ScheduleItemUncheckedCreateWithoutClassroomInput> | ScheduleItemCreateWithoutClassroomInput[] | ScheduleItemUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutClassroomInput | ScheduleItemCreateOrConnectWithoutClassroomInput[]
    createMany?: ScheduleItemCreateManyClassroomInputEnvelope
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutClassroomInput = {
    create?: XOR<LessonCreateWithoutClassroomInput, LessonUncheckedCreateWithoutClassroomInput> | LessonCreateWithoutClassroomInput[] | LessonUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutClassroomInput | LessonCreateOrConnectWithoutClassroomInput[]
    createMany?: LessonCreateManyClassroomInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type TeacherProfileUpdateOneWithoutClassesNestedInput = {
    create?: XOR<TeacherProfileCreateWithoutClassesInput, TeacherProfileUncheckedCreateWithoutClassesInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutClassesInput
    upsert?: TeacherProfileUpsertWithoutClassesInput
    disconnect?: TeacherProfileWhereInput | boolean
    delete?: TeacherProfileWhereInput | boolean
    connect?: TeacherProfileWhereUniqueInput
    update?: XOR<XOR<TeacherProfileUpdateToOneWithWhereWithoutClassesInput, TeacherProfileUpdateWithoutClassesInput>, TeacherProfileUncheckedUpdateWithoutClassesInput>
  }

  export type StudentProfileUpdateManyWithoutClassroomsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutClassroomsInput, StudentProfileUncheckedCreateWithoutClassroomsInput> | StudentProfileCreateWithoutClassroomsInput[] | StudentProfileUncheckedCreateWithoutClassroomsInput[]
    connectOrCreate?: StudentProfileCreateOrConnectWithoutClassroomsInput | StudentProfileCreateOrConnectWithoutClassroomsInput[]
    upsert?: StudentProfileUpsertWithWhereUniqueWithoutClassroomsInput | StudentProfileUpsertWithWhereUniqueWithoutClassroomsInput[]
    set?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    disconnect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    delete?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    connect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    update?: StudentProfileUpdateWithWhereUniqueWithoutClassroomsInput | StudentProfileUpdateWithWhereUniqueWithoutClassroomsInput[]
    updateMany?: StudentProfileUpdateManyWithWhereWithoutClassroomsInput | StudentProfileUpdateManyWithWhereWithoutClassroomsInput[]
    deleteMany?: StudentProfileScalarWhereInput | StudentProfileScalarWhereInput[]
  }

  export type ScheduleItemUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutClassroomInput, ScheduleItemUncheckedCreateWithoutClassroomInput> | ScheduleItemCreateWithoutClassroomInput[] | ScheduleItemUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutClassroomInput | ScheduleItemCreateOrConnectWithoutClassroomInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutClassroomInput | ScheduleItemUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: ScheduleItemCreateManyClassroomInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutClassroomInput | ScheduleItemUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutClassroomInput | ScheduleItemUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type LessonUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<LessonCreateWithoutClassroomInput, LessonUncheckedCreateWithoutClassroomInput> | LessonCreateWithoutClassroomInput[] | LessonUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutClassroomInput | LessonCreateOrConnectWithoutClassroomInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutClassroomInput | LessonUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: LessonCreateManyClassroomInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutClassroomInput | LessonUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutClassroomInput | LessonUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type StudentProfileUncheckedUpdateManyWithoutClassroomsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutClassroomsInput, StudentProfileUncheckedCreateWithoutClassroomsInput> | StudentProfileCreateWithoutClassroomsInput[] | StudentProfileUncheckedCreateWithoutClassroomsInput[]
    connectOrCreate?: StudentProfileCreateOrConnectWithoutClassroomsInput | StudentProfileCreateOrConnectWithoutClassroomsInput[]
    upsert?: StudentProfileUpsertWithWhereUniqueWithoutClassroomsInput | StudentProfileUpsertWithWhereUniqueWithoutClassroomsInput[]
    set?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    disconnect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    delete?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    connect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    update?: StudentProfileUpdateWithWhereUniqueWithoutClassroomsInput | StudentProfileUpdateWithWhereUniqueWithoutClassroomsInput[]
    updateMany?: StudentProfileUpdateManyWithWhereWithoutClassroomsInput | StudentProfileUpdateManyWithWhereWithoutClassroomsInput[]
    deleteMany?: StudentProfileScalarWhereInput | StudentProfileScalarWhereInput[]
  }

  export type ScheduleItemUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutClassroomInput, ScheduleItemUncheckedCreateWithoutClassroomInput> | ScheduleItemCreateWithoutClassroomInput[] | ScheduleItemUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutClassroomInput | ScheduleItemCreateOrConnectWithoutClassroomInput[]
    upsert?: ScheduleItemUpsertWithWhereUniqueWithoutClassroomInput | ScheduleItemUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: ScheduleItemCreateManyClassroomInputEnvelope
    set?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    disconnect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    delete?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    connect?: ScheduleItemWhereUniqueInput | ScheduleItemWhereUniqueInput[]
    update?: ScheduleItemUpdateWithWhereUniqueWithoutClassroomInput | ScheduleItemUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: ScheduleItemUpdateManyWithWhereWithoutClassroomInput | ScheduleItemUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutClassroomNestedInput = {
    create?: XOR<LessonCreateWithoutClassroomInput, LessonUncheckedCreateWithoutClassroomInput> | LessonCreateWithoutClassroomInput[] | LessonUncheckedCreateWithoutClassroomInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutClassroomInput | LessonCreateOrConnectWithoutClassroomInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutClassroomInput | LessonUpsertWithWhereUniqueWithoutClassroomInput[]
    createMany?: LessonCreateManyClassroomInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutClassroomInput | LessonUpdateWithWhereUniqueWithoutClassroomInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutClassroomInput | LessonUpdateManyWithWhereWithoutClassroomInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type TeacherProfileCreateNestedOneWithoutScheduleItemsInput = {
    create?: XOR<TeacherProfileCreateWithoutScheduleItemsInput, TeacherProfileUncheckedCreateWithoutScheduleItemsInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutScheduleItemsInput
    connect?: TeacherProfileWhereUniqueInput
  }

  export type ClassroomCreateNestedOneWithoutScheduleInput = {
    create?: XOR<ClassroomCreateWithoutScheduleInput, ClassroomUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutScheduleInput
    connect?: ClassroomWhereUniqueInput
  }

  export type StudentProfileCreateNestedOneWithoutRecurringSchedulesInput = {
    create?: XOR<StudentProfileCreateWithoutRecurringSchedulesInput, StudentProfileUncheckedCreateWithoutRecurringSchedulesInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutRecurringSchedulesInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type LessonCreateNestedManyWithoutScheduleItemInput = {
    create?: XOR<LessonCreateWithoutScheduleItemInput, LessonUncheckedCreateWithoutScheduleItemInput> | LessonCreateWithoutScheduleItemInput[] | LessonUncheckedCreateWithoutScheduleItemInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutScheduleItemInput | LessonCreateOrConnectWithoutScheduleItemInput[]
    createMany?: LessonCreateManyScheduleItemInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutScheduleItemInput = {
    create?: XOR<LessonCreateWithoutScheduleItemInput, LessonUncheckedCreateWithoutScheduleItemInput> | LessonCreateWithoutScheduleItemInput[] | LessonUncheckedCreateWithoutScheduleItemInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutScheduleItemInput | LessonCreateOrConnectWithoutScheduleItemInput[]
    createMany?: LessonCreateManyScheduleItemInputEnvelope
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type EnumLessonTypeFieldUpdateOperationsInput = {
    set?: $Enums.LessonType
  }

  export type EnumLessonLocationFieldUpdateOperationsInput = {
    set?: $Enums.LessonLocation
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type TeacherProfileUpdateOneRequiredWithoutScheduleItemsNestedInput = {
    create?: XOR<TeacherProfileCreateWithoutScheduleItemsInput, TeacherProfileUncheckedCreateWithoutScheduleItemsInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutScheduleItemsInput
    upsert?: TeacherProfileUpsertWithoutScheduleItemsInput
    connect?: TeacherProfileWhereUniqueInput
    update?: XOR<XOR<TeacherProfileUpdateToOneWithWhereWithoutScheduleItemsInput, TeacherProfileUpdateWithoutScheduleItemsInput>, TeacherProfileUncheckedUpdateWithoutScheduleItemsInput>
  }

  export type ClassroomUpdateOneWithoutScheduleNestedInput = {
    create?: XOR<ClassroomCreateWithoutScheduleInput, ClassroomUncheckedCreateWithoutScheduleInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutScheduleInput
    upsert?: ClassroomUpsertWithoutScheduleInput
    disconnect?: ClassroomWhereInput | boolean
    delete?: ClassroomWhereInput | boolean
    connect?: ClassroomWhereUniqueInput
    update?: XOR<XOR<ClassroomUpdateToOneWithWhereWithoutScheduleInput, ClassroomUpdateWithoutScheduleInput>, ClassroomUncheckedUpdateWithoutScheduleInput>
  }

  export type StudentProfileUpdateOneWithoutRecurringSchedulesNestedInput = {
    create?: XOR<StudentProfileCreateWithoutRecurringSchedulesInput, StudentProfileUncheckedCreateWithoutRecurringSchedulesInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutRecurringSchedulesInput
    upsert?: StudentProfileUpsertWithoutRecurringSchedulesInput
    disconnect?: StudentProfileWhereInput | boolean
    delete?: StudentProfileWhereInput | boolean
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutRecurringSchedulesInput, StudentProfileUpdateWithoutRecurringSchedulesInput>, StudentProfileUncheckedUpdateWithoutRecurringSchedulesInput>
  }

  export type LessonUpdateManyWithoutScheduleItemNestedInput = {
    create?: XOR<LessonCreateWithoutScheduleItemInput, LessonUncheckedCreateWithoutScheduleItemInput> | LessonCreateWithoutScheduleItemInput[] | LessonUncheckedCreateWithoutScheduleItemInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutScheduleItemInput | LessonCreateOrConnectWithoutScheduleItemInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutScheduleItemInput | LessonUpsertWithWhereUniqueWithoutScheduleItemInput[]
    createMany?: LessonCreateManyScheduleItemInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutScheduleItemInput | LessonUpdateWithWhereUniqueWithoutScheduleItemInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutScheduleItemInput | LessonUpdateManyWithWhereWithoutScheduleItemInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutScheduleItemNestedInput = {
    create?: XOR<LessonCreateWithoutScheduleItemInput, LessonUncheckedCreateWithoutScheduleItemInput> | LessonCreateWithoutScheduleItemInput[] | LessonUncheckedCreateWithoutScheduleItemInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutScheduleItemInput | LessonCreateOrConnectWithoutScheduleItemInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutScheduleItemInput | LessonUpsertWithWhereUniqueWithoutScheduleItemInput[]
    createMany?: LessonCreateManyScheduleItemInputEnvelope
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutScheduleItemInput | LessonUpdateWithWhereUniqueWithoutScheduleItemInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutScheduleItemInput | LessonUpdateManyWithWhereWithoutScheduleItemInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type ScheduleItemCreateNestedOneWithoutLessonsInput = {
    create?: XOR<ScheduleItemCreateWithoutLessonsInput, ScheduleItemUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutLessonsInput
    connect?: ScheduleItemWhereUniqueInput
  }

  export type TeacherProfileCreateNestedOneWithoutLessonsInput = {
    create?: XOR<TeacherProfileCreateWithoutLessonsInput, TeacherProfileUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutLessonsInput
    connect?: TeacherProfileWhereUniqueInput
  }

  export type StudentProfileCreateNestedManyWithoutLessonsInput = {
    create?: XOR<StudentProfileCreateWithoutLessonsInput, StudentProfileUncheckedCreateWithoutLessonsInput> | StudentProfileCreateWithoutLessonsInput[] | StudentProfileUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: StudentProfileCreateOrConnectWithoutLessonsInput | StudentProfileCreateOrConnectWithoutLessonsInput[]
    connect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
  }

  export type ClassroomCreateNestedOneWithoutLessonsInput = {
    create?: XOR<ClassroomCreateWithoutLessonsInput, ClassroomUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutLessonsInput
    connect?: ClassroomWhereUniqueInput
  }

  export type AttendanceCreateNestedManyWithoutLessonInput = {
    create?: XOR<AttendanceCreateWithoutLessonInput, AttendanceUncheckedCreateWithoutLessonInput> | AttendanceCreateWithoutLessonInput[] | AttendanceUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutLessonInput | AttendanceCreateOrConnectWithoutLessonInput[]
    createMany?: AttendanceCreateManyLessonInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type HomeworkCreateNestedManyWithoutLessonInput = {
    create?: XOR<HomeworkCreateWithoutLessonInput, HomeworkUncheckedCreateWithoutLessonInput> | HomeworkCreateWithoutLessonInput[] | HomeworkUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: HomeworkCreateOrConnectWithoutLessonInput | HomeworkCreateOrConnectWithoutLessonInput[]
    createMany?: HomeworkCreateManyLessonInputEnvelope
    connect?: HomeworkWhereUniqueInput | HomeworkWhereUniqueInput[]
  }

  export type MaterialCreateNestedManyWithoutLessonInput = {
    create?: XOR<MaterialCreateWithoutLessonInput, MaterialUncheckedCreateWithoutLessonInput> | MaterialCreateWithoutLessonInput[] | MaterialUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutLessonInput | MaterialCreateOrConnectWithoutLessonInput[]
    createMany?: MaterialCreateManyLessonInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type PaymentCreateNestedManyWithoutLessonsInput = {
    create?: XOR<PaymentCreateWithoutLessonsInput, PaymentUncheckedCreateWithoutLessonsInput> | PaymentCreateWithoutLessonsInput[] | PaymentUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLessonsInput | PaymentCreateOrConnectWithoutLessonsInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type StudentProfileUncheckedCreateNestedManyWithoutLessonsInput = {
    create?: XOR<StudentProfileCreateWithoutLessonsInput, StudentProfileUncheckedCreateWithoutLessonsInput> | StudentProfileCreateWithoutLessonsInput[] | StudentProfileUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: StudentProfileCreateOrConnectWithoutLessonsInput | StudentProfileCreateOrConnectWithoutLessonsInput[]
    connect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
  }

  export type AttendanceUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<AttendanceCreateWithoutLessonInput, AttendanceUncheckedCreateWithoutLessonInput> | AttendanceCreateWithoutLessonInput[] | AttendanceUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutLessonInput | AttendanceCreateOrConnectWithoutLessonInput[]
    createMany?: AttendanceCreateManyLessonInputEnvelope
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
  }

  export type HomeworkUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<HomeworkCreateWithoutLessonInput, HomeworkUncheckedCreateWithoutLessonInput> | HomeworkCreateWithoutLessonInput[] | HomeworkUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: HomeworkCreateOrConnectWithoutLessonInput | HomeworkCreateOrConnectWithoutLessonInput[]
    createMany?: HomeworkCreateManyLessonInputEnvelope
    connect?: HomeworkWhereUniqueInput | HomeworkWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutLessonInput = {
    create?: XOR<MaterialCreateWithoutLessonInput, MaterialUncheckedCreateWithoutLessonInput> | MaterialCreateWithoutLessonInput[] | MaterialUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutLessonInput | MaterialCreateOrConnectWithoutLessonInput[]
    createMany?: MaterialCreateManyLessonInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type PaymentUncheckedCreateNestedManyWithoutLessonsInput = {
    create?: XOR<PaymentCreateWithoutLessonsInput, PaymentUncheckedCreateWithoutLessonsInput> | PaymentCreateWithoutLessonsInput[] | PaymentUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLessonsInput | PaymentCreateOrConnectWithoutLessonsInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
  }

  export type EnumLessonStatusFieldUpdateOperationsInput = {
    set?: $Enums.LessonStatus
  }

  export type ScheduleItemUpdateOneWithoutLessonsNestedInput = {
    create?: XOR<ScheduleItemCreateWithoutLessonsInput, ScheduleItemUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ScheduleItemCreateOrConnectWithoutLessonsInput
    upsert?: ScheduleItemUpsertWithoutLessonsInput
    disconnect?: ScheduleItemWhereInput | boolean
    delete?: ScheduleItemWhereInput | boolean
    connect?: ScheduleItemWhereUniqueInput
    update?: XOR<XOR<ScheduleItemUpdateToOneWithWhereWithoutLessonsInput, ScheduleItemUpdateWithoutLessonsInput>, ScheduleItemUncheckedUpdateWithoutLessonsInput>
  }

  export type TeacherProfileUpdateOneRequiredWithoutLessonsNestedInput = {
    create?: XOR<TeacherProfileCreateWithoutLessonsInput, TeacherProfileUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutLessonsInput
    upsert?: TeacherProfileUpsertWithoutLessonsInput
    connect?: TeacherProfileWhereUniqueInput
    update?: XOR<XOR<TeacherProfileUpdateToOneWithWhereWithoutLessonsInput, TeacherProfileUpdateWithoutLessonsInput>, TeacherProfileUncheckedUpdateWithoutLessonsInput>
  }

  export type StudentProfileUpdateManyWithoutLessonsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutLessonsInput, StudentProfileUncheckedCreateWithoutLessonsInput> | StudentProfileCreateWithoutLessonsInput[] | StudentProfileUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: StudentProfileCreateOrConnectWithoutLessonsInput | StudentProfileCreateOrConnectWithoutLessonsInput[]
    upsert?: StudentProfileUpsertWithWhereUniqueWithoutLessonsInput | StudentProfileUpsertWithWhereUniqueWithoutLessonsInput[]
    set?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    disconnect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    delete?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    connect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    update?: StudentProfileUpdateWithWhereUniqueWithoutLessonsInput | StudentProfileUpdateWithWhereUniqueWithoutLessonsInput[]
    updateMany?: StudentProfileUpdateManyWithWhereWithoutLessonsInput | StudentProfileUpdateManyWithWhereWithoutLessonsInput[]
    deleteMany?: StudentProfileScalarWhereInput | StudentProfileScalarWhereInput[]
  }

  export type ClassroomUpdateOneWithoutLessonsNestedInput = {
    create?: XOR<ClassroomCreateWithoutLessonsInput, ClassroomUncheckedCreateWithoutLessonsInput>
    connectOrCreate?: ClassroomCreateOrConnectWithoutLessonsInput
    upsert?: ClassroomUpsertWithoutLessonsInput
    disconnect?: ClassroomWhereInput | boolean
    delete?: ClassroomWhereInput | boolean
    connect?: ClassroomWhereUniqueInput
    update?: XOR<XOR<ClassroomUpdateToOneWithWhereWithoutLessonsInput, ClassroomUpdateWithoutLessonsInput>, ClassroomUncheckedUpdateWithoutLessonsInput>
  }

  export type AttendanceUpdateManyWithoutLessonNestedInput = {
    create?: XOR<AttendanceCreateWithoutLessonInput, AttendanceUncheckedCreateWithoutLessonInput> | AttendanceCreateWithoutLessonInput[] | AttendanceUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutLessonInput | AttendanceCreateOrConnectWithoutLessonInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutLessonInput | AttendanceUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: AttendanceCreateManyLessonInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutLessonInput | AttendanceUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutLessonInput | AttendanceUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type HomeworkUpdateManyWithoutLessonNestedInput = {
    create?: XOR<HomeworkCreateWithoutLessonInput, HomeworkUncheckedCreateWithoutLessonInput> | HomeworkCreateWithoutLessonInput[] | HomeworkUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: HomeworkCreateOrConnectWithoutLessonInput | HomeworkCreateOrConnectWithoutLessonInput[]
    upsert?: HomeworkUpsertWithWhereUniqueWithoutLessonInput | HomeworkUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: HomeworkCreateManyLessonInputEnvelope
    set?: HomeworkWhereUniqueInput | HomeworkWhereUniqueInput[]
    disconnect?: HomeworkWhereUniqueInput | HomeworkWhereUniqueInput[]
    delete?: HomeworkWhereUniqueInput | HomeworkWhereUniqueInput[]
    connect?: HomeworkWhereUniqueInput | HomeworkWhereUniqueInput[]
    update?: HomeworkUpdateWithWhereUniqueWithoutLessonInput | HomeworkUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: HomeworkUpdateManyWithWhereWithoutLessonInput | HomeworkUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: HomeworkScalarWhereInput | HomeworkScalarWhereInput[]
  }

  export type MaterialUpdateManyWithoutLessonNestedInput = {
    create?: XOR<MaterialCreateWithoutLessonInput, MaterialUncheckedCreateWithoutLessonInput> | MaterialCreateWithoutLessonInput[] | MaterialUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutLessonInput | MaterialCreateOrConnectWithoutLessonInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutLessonInput | MaterialUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: MaterialCreateManyLessonInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutLessonInput | MaterialUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutLessonInput | MaterialUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type PaymentUpdateManyWithoutLessonsNestedInput = {
    create?: XOR<PaymentCreateWithoutLessonsInput, PaymentUncheckedCreateWithoutLessonsInput> | PaymentCreateWithoutLessonsInput[] | PaymentUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLessonsInput | PaymentCreateOrConnectWithoutLessonsInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutLessonsInput | PaymentUpsertWithWhereUniqueWithoutLessonsInput[]
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutLessonsInput | PaymentUpdateWithWhereUniqueWithoutLessonsInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutLessonsInput | PaymentUpdateManyWithWhereWithoutLessonsInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type StudentProfileUncheckedUpdateManyWithoutLessonsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutLessonsInput, StudentProfileUncheckedCreateWithoutLessonsInput> | StudentProfileCreateWithoutLessonsInput[] | StudentProfileUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: StudentProfileCreateOrConnectWithoutLessonsInput | StudentProfileCreateOrConnectWithoutLessonsInput[]
    upsert?: StudentProfileUpsertWithWhereUniqueWithoutLessonsInput | StudentProfileUpsertWithWhereUniqueWithoutLessonsInput[]
    set?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    disconnect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    delete?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    connect?: StudentProfileWhereUniqueInput | StudentProfileWhereUniqueInput[]
    update?: StudentProfileUpdateWithWhereUniqueWithoutLessonsInput | StudentProfileUpdateWithWhereUniqueWithoutLessonsInput[]
    updateMany?: StudentProfileUpdateManyWithWhereWithoutLessonsInput | StudentProfileUpdateManyWithWhereWithoutLessonsInput[]
    deleteMany?: StudentProfileScalarWhereInput | StudentProfileScalarWhereInput[]
  }

  export type AttendanceUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<AttendanceCreateWithoutLessonInput, AttendanceUncheckedCreateWithoutLessonInput> | AttendanceCreateWithoutLessonInput[] | AttendanceUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: AttendanceCreateOrConnectWithoutLessonInput | AttendanceCreateOrConnectWithoutLessonInput[]
    upsert?: AttendanceUpsertWithWhereUniqueWithoutLessonInput | AttendanceUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: AttendanceCreateManyLessonInputEnvelope
    set?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    disconnect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    delete?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    connect?: AttendanceWhereUniqueInput | AttendanceWhereUniqueInput[]
    update?: AttendanceUpdateWithWhereUniqueWithoutLessonInput | AttendanceUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: AttendanceUpdateManyWithWhereWithoutLessonInput | AttendanceUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
  }

  export type HomeworkUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<HomeworkCreateWithoutLessonInput, HomeworkUncheckedCreateWithoutLessonInput> | HomeworkCreateWithoutLessonInput[] | HomeworkUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: HomeworkCreateOrConnectWithoutLessonInput | HomeworkCreateOrConnectWithoutLessonInput[]
    upsert?: HomeworkUpsertWithWhereUniqueWithoutLessonInput | HomeworkUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: HomeworkCreateManyLessonInputEnvelope
    set?: HomeworkWhereUniqueInput | HomeworkWhereUniqueInput[]
    disconnect?: HomeworkWhereUniqueInput | HomeworkWhereUniqueInput[]
    delete?: HomeworkWhereUniqueInput | HomeworkWhereUniqueInput[]
    connect?: HomeworkWhereUniqueInput | HomeworkWhereUniqueInput[]
    update?: HomeworkUpdateWithWhereUniqueWithoutLessonInput | HomeworkUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: HomeworkUpdateManyWithWhereWithoutLessonInput | HomeworkUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: HomeworkScalarWhereInput | HomeworkScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutLessonNestedInput = {
    create?: XOR<MaterialCreateWithoutLessonInput, MaterialUncheckedCreateWithoutLessonInput> | MaterialCreateWithoutLessonInput[] | MaterialUncheckedCreateWithoutLessonInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutLessonInput | MaterialCreateOrConnectWithoutLessonInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutLessonInput | MaterialUpsertWithWhereUniqueWithoutLessonInput[]
    createMany?: MaterialCreateManyLessonInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutLessonInput | MaterialUpdateWithWhereUniqueWithoutLessonInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutLessonInput | MaterialUpdateManyWithWhereWithoutLessonInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type PaymentUncheckedUpdateManyWithoutLessonsNestedInput = {
    create?: XOR<PaymentCreateWithoutLessonsInput, PaymentUncheckedCreateWithoutLessonsInput> | PaymentCreateWithoutLessonsInput[] | PaymentUncheckedCreateWithoutLessonsInput[]
    connectOrCreate?: PaymentCreateOrConnectWithoutLessonsInput | PaymentCreateOrConnectWithoutLessonsInput[]
    upsert?: PaymentUpsertWithWhereUniqueWithoutLessonsInput | PaymentUpsertWithWhereUniqueWithoutLessonsInput[]
    set?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    disconnect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    delete?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    connect?: PaymentWhereUniqueInput | PaymentWhereUniqueInput[]
    update?: PaymentUpdateWithWhereUniqueWithoutLessonsInput | PaymentUpdateWithWhereUniqueWithoutLessonsInput[]
    updateMany?: PaymentUpdateManyWithWhereWithoutLessonsInput | PaymentUpdateManyWithWhereWithoutLessonsInput[]
    deleteMany?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
  }

  export type FileCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<FileCreateWithoutMaterialsInput, FileUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: FileCreateOrConnectWithoutMaterialsInput
    connect?: FileWhereUniqueInput
  }

  export type LessonCreateNestedOneWithoutMaterialsInput = {
    create?: XOR<LessonCreateWithoutMaterialsInput, LessonUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutMaterialsInput
    connect?: LessonWhereUniqueInput
  }

  export type EnumFileTypeFieldUpdateOperationsInput = {
    set?: $Enums.FileType
  }

  export type FileUpdateOneWithoutMaterialsNestedInput = {
    create?: XOR<FileCreateWithoutMaterialsInput, FileUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: FileCreateOrConnectWithoutMaterialsInput
    upsert?: FileUpsertWithoutMaterialsInput
    disconnect?: FileWhereInput | boolean
    delete?: FileWhereInput | boolean
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutMaterialsInput, FileUpdateWithoutMaterialsInput>, FileUncheckedUpdateWithoutMaterialsInput>
  }

  export type LessonUpdateOneRequiredWithoutMaterialsNestedInput = {
    create?: XOR<LessonCreateWithoutMaterialsInput, LessonUncheckedCreateWithoutMaterialsInput>
    connectOrCreate?: LessonCreateOrConnectWithoutMaterialsInput
    upsert?: LessonUpsertWithoutMaterialsInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutMaterialsInput, LessonUpdateWithoutMaterialsInput>, LessonUncheckedUpdateWithoutMaterialsInput>
  }

  export type LessonCreateNestedOneWithoutHomeworksInput = {
    create?: XOR<LessonCreateWithoutHomeworksInput, LessonUncheckedCreateWithoutHomeworksInput>
    connectOrCreate?: LessonCreateOrConnectWithoutHomeworksInput
    connect?: LessonWhereUniqueInput
  }

  export type HomeworkTrackingCreateNestedManyWithoutHomeworkInput = {
    create?: XOR<HomeworkTrackingCreateWithoutHomeworkInput, HomeworkTrackingUncheckedCreateWithoutHomeworkInput> | HomeworkTrackingCreateWithoutHomeworkInput[] | HomeworkTrackingUncheckedCreateWithoutHomeworkInput[]
    connectOrCreate?: HomeworkTrackingCreateOrConnectWithoutHomeworkInput | HomeworkTrackingCreateOrConnectWithoutHomeworkInput[]
    createMany?: HomeworkTrackingCreateManyHomeworkInputEnvelope
    connect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
  }

  export type HomeworkTrackingUncheckedCreateNestedManyWithoutHomeworkInput = {
    create?: XOR<HomeworkTrackingCreateWithoutHomeworkInput, HomeworkTrackingUncheckedCreateWithoutHomeworkInput> | HomeworkTrackingCreateWithoutHomeworkInput[] | HomeworkTrackingUncheckedCreateWithoutHomeworkInput[]
    connectOrCreate?: HomeworkTrackingCreateOrConnectWithoutHomeworkInput | HomeworkTrackingCreateOrConnectWithoutHomeworkInput[]
    createMany?: HomeworkTrackingCreateManyHomeworkInputEnvelope
    connect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
  }

  export type LessonUpdateOneRequiredWithoutHomeworksNestedInput = {
    create?: XOR<LessonCreateWithoutHomeworksInput, LessonUncheckedCreateWithoutHomeworksInput>
    connectOrCreate?: LessonCreateOrConnectWithoutHomeworksInput
    upsert?: LessonUpsertWithoutHomeworksInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutHomeworksInput, LessonUpdateWithoutHomeworksInput>, LessonUncheckedUpdateWithoutHomeworksInput>
  }

  export type HomeworkTrackingUpdateManyWithoutHomeworkNestedInput = {
    create?: XOR<HomeworkTrackingCreateWithoutHomeworkInput, HomeworkTrackingUncheckedCreateWithoutHomeworkInput> | HomeworkTrackingCreateWithoutHomeworkInput[] | HomeworkTrackingUncheckedCreateWithoutHomeworkInput[]
    connectOrCreate?: HomeworkTrackingCreateOrConnectWithoutHomeworkInput | HomeworkTrackingCreateOrConnectWithoutHomeworkInput[]
    upsert?: HomeworkTrackingUpsertWithWhereUniqueWithoutHomeworkInput | HomeworkTrackingUpsertWithWhereUniqueWithoutHomeworkInput[]
    createMany?: HomeworkTrackingCreateManyHomeworkInputEnvelope
    set?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    disconnect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    delete?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    connect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    update?: HomeworkTrackingUpdateWithWhereUniqueWithoutHomeworkInput | HomeworkTrackingUpdateWithWhereUniqueWithoutHomeworkInput[]
    updateMany?: HomeworkTrackingUpdateManyWithWhereWithoutHomeworkInput | HomeworkTrackingUpdateManyWithWhereWithoutHomeworkInput[]
    deleteMany?: HomeworkTrackingScalarWhereInput | HomeworkTrackingScalarWhereInput[]
  }

  export type HomeworkTrackingUncheckedUpdateManyWithoutHomeworkNestedInput = {
    create?: XOR<HomeworkTrackingCreateWithoutHomeworkInput, HomeworkTrackingUncheckedCreateWithoutHomeworkInput> | HomeworkTrackingCreateWithoutHomeworkInput[] | HomeworkTrackingUncheckedCreateWithoutHomeworkInput[]
    connectOrCreate?: HomeworkTrackingCreateOrConnectWithoutHomeworkInput | HomeworkTrackingCreateOrConnectWithoutHomeworkInput[]
    upsert?: HomeworkTrackingUpsertWithWhereUniqueWithoutHomeworkInput | HomeworkTrackingUpsertWithWhereUniqueWithoutHomeworkInput[]
    createMany?: HomeworkTrackingCreateManyHomeworkInputEnvelope
    set?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    disconnect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    delete?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    connect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    update?: HomeworkTrackingUpdateWithWhereUniqueWithoutHomeworkInput | HomeworkTrackingUpdateWithWhereUniqueWithoutHomeworkInput[]
    updateMany?: HomeworkTrackingUpdateManyWithWhereWithoutHomeworkInput | HomeworkTrackingUpdateManyWithWhereWithoutHomeworkInput[]
    deleteMany?: HomeworkTrackingScalarWhereInput | HomeworkTrackingScalarWhereInput[]
  }

  export type FileCreateNestedOneWithoutHomeworkTrackingsInput = {
    create?: XOR<FileCreateWithoutHomeworkTrackingsInput, FileUncheckedCreateWithoutHomeworkTrackingsInput>
    connectOrCreate?: FileCreateOrConnectWithoutHomeworkTrackingsInput
    connect?: FileWhereUniqueInput
  }

  export type HomeworkCreateNestedOneWithoutTrackingsInput = {
    create?: XOR<HomeworkCreateWithoutTrackingsInput, HomeworkUncheckedCreateWithoutTrackingsInput>
    connectOrCreate?: HomeworkCreateOrConnectWithoutTrackingsInput
    connect?: HomeworkWhereUniqueInput
  }

  export type StudentProfileCreateNestedOneWithoutHomeworkTrackingsInput = {
    create?: XOR<StudentProfileCreateWithoutHomeworkTrackingsInput, StudentProfileUncheckedCreateWithoutHomeworkTrackingsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutHomeworkTrackingsInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type EnumHomeworkStatusFieldUpdateOperationsInput = {
    set?: $Enums.HomeworkStatus
  }

  export type FileUpdateOneWithoutHomeworkTrackingsNestedInput = {
    create?: XOR<FileCreateWithoutHomeworkTrackingsInput, FileUncheckedCreateWithoutHomeworkTrackingsInput>
    connectOrCreate?: FileCreateOrConnectWithoutHomeworkTrackingsInput
    upsert?: FileUpsertWithoutHomeworkTrackingsInput
    disconnect?: FileWhereInput | boolean
    delete?: FileWhereInput | boolean
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutHomeworkTrackingsInput, FileUpdateWithoutHomeworkTrackingsInput>, FileUncheckedUpdateWithoutHomeworkTrackingsInput>
  }

  export type HomeworkUpdateOneRequiredWithoutTrackingsNestedInput = {
    create?: XOR<HomeworkCreateWithoutTrackingsInput, HomeworkUncheckedCreateWithoutTrackingsInput>
    connectOrCreate?: HomeworkCreateOrConnectWithoutTrackingsInput
    upsert?: HomeworkUpsertWithoutTrackingsInput
    connect?: HomeworkWhereUniqueInput
    update?: XOR<XOR<HomeworkUpdateToOneWithWhereWithoutTrackingsInput, HomeworkUpdateWithoutTrackingsInput>, HomeworkUncheckedUpdateWithoutTrackingsInput>
  }

  export type StudentProfileUpdateOneRequiredWithoutHomeworkTrackingsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutHomeworkTrackingsInput, StudentProfileUncheckedCreateWithoutHomeworkTrackingsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutHomeworkTrackingsInput
    upsert?: StudentProfileUpsertWithoutHomeworkTrackingsInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutHomeworkTrackingsInput, StudentProfileUpdateWithoutHomeworkTrackingsInput>, StudentProfileUncheckedUpdateWithoutHomeworkTrackingsInput>
  }

  export type FileCreateNestedOneWithoutHomeworkSubmissionsInput = {
    create?: XOR<FileCreateWithoutHomeworkSubmissionsInput, FileUncheckedCreateWithoutHomeworkSubmissionsInput>
    connectOrCreate?: FileCreateOrConnectWithoutHomeworkSubmissionsInput
    connect?: FileWhereUniqueInput
  }

  export type StudentProfileCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<StudentProfileCreateWithoutSubmissionsInput, StudentProfileUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutSubmissionsInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type FileUpdateOneWithoutHomeworkSubmissionsNestedInput = {
    create?: XOR<FileCreateWithoutHomeworkSubmissionsInput, FileUncheckedCreateWithoutHomeworkSubmissionsInput>
    connectOrCreate?: FileCreateOrConnectWithoutHomeworkSubmissionsInput
    upsert?: FileUpsertWithoutHomeworkSubmissionsInput
    disconnect?: FileWhereInput | boolean
    delete?: FileWhereInput | boolean
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutHomeworkSubmissionsInput, FileUpdateWithoutHomeworkSubmissionsInput>, FileUncheckedUpdateWithoutHomeworkSubmissionsInput>
  }

  export type StudentProfileUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutSubmissionsInput, StudentProfileUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutSubmissionsInput
    upsert?: StudentProfileUpsertWithoutSubmissionsInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutSubmissionsInput, StudentProfileUpdateWithoutSubmissionsInput>, StudentProfileUncheckedUpdateWithoutSubmissionsInput>
  }

  export type StudentProfileCreateNestedOneWithoutGradesInput = {
    create?: XOR<StudentProfileCreateWithoutGradesInput, StudentProfileUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutGradesInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentProfileUpdateOneRequiredWithoutGradesNestedInput = {
    create?: XOR<StudentProfileCreateWithoutGradesInput, StudentProfileUncheckedCreateWithoutGradesInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutGradesInput
    upsert?: StudentProfileUpsertWithoutGradesInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutGradesInput, StudentProfileUpdateWithoutGradesInput>, StudentProfileUncheckedUpdateWithoutGradesInput>
  }

  export type StudentProfileCreateNestedOneWithoutTrialExamsInput = {
    create?: XOR<StudentProfileCreateWithoutTrialExamsInput, StudentProfileUncheckedCreateWithoutTrialExamsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutTrialExamsInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type TrialExamResultCreateNestedManyWithoutTrialExamInput = {
    create?: XOR<TrialExamResultCreateWithoutTrialExamInput, TrialExamResultUncheckedCreateWithoutTrialExamInput> | TrialExamResultCreateWithoutTrialExamInput[] | TrialExamResultUncheckedCreateWithoutTrialExamInput[]
    connectOrCreate?: TrialExamResultCreateOrConnectWithoutTrialExamInput | TrialExamResultCreateOrConnectWithoutTrialExamInput[]
    createMany?: TrialExamResultCreateManyTrialExamInputEnvelope
    connect?: TrialExamResultWhereUniqueInput | TrialExamResultWhereUniqueInput[]
  }

  export type TrialExamResultUncheckedCreateNestedManyWithoutTrialExamInput = {
    create?: XOR<TrialExamResultCreateWithoutTrialExamInput, TrialExamResultUncheckedCreateWithoutTrialExamInput> | TrialExamResultCreateWithoutTrialExamInput[] | TrialExamResultUncheckedCreateWithoutTrialExamInput[]
    connectOrCreate?: TrialExamResultCreateOrConnectWithoutTrialExamInput | TrialExamResultCreateOrConnectWithoutTrialExamInput[]
    createMany?: TrialExamResultCreateManyTrialExamInputEnvelope
    connect?: TrialExamResultWhereUniqueInput | TrialExamResultWhereUniqueInput[]
  }

  export type EnumExamCategoryFieldUpdateOperationsInput = {
    set?: $Enums.ExamCategory
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type StudentProfileUpdateOneRequiredWithoutTrialExamsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutTrialExamsInput, StudentProfileUncheckedCreateWithoutTrialExamsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutTrialExamsInput
    upsert?: StudentProfileUpsertWithoutTrialExamsInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutTrialExamsInput, StudentProfileUpdateWithoutTrialExamsInput>, StudentProfileUncheckedUpdateWithoutTrialExamsInput>
  }

  export type TrialExamResultUpdateManyWithoutTrialExamNestedInput = {
    create?: XOR<TrialExamResultCreateWithoutTrialExamInput, TrialExamResultUncheckedCreateWithoutTrialExamInput> | TrialExamResultCreateWithoutTrialExamInput[] | TrialExamResultUncheckedCreateWithoutTrialExamInput[]
    connectOrCreate?: TrialExamResultCreateOrConnectWithoutTrialExamInput | TrialExamResultCreateOrConnectWithoutTrialExamInput[]
    upsert?: TrialExamResultUpsertWithWhereUniqueWithoutTrialExamInput | TrialExamResultUpsertWithWhereUniqueWithoutTrialExamInput[]
    createMany?: TrialExamResultCreateManyTrialExamInputEnvelope
    set?: TrialExamResultWhereUniqueInput | TrialExamResultWhereUniqueInput[]
    disconnect?: TrialExamResultWhereUniqueInput | TrialExamResultWhereUniqueInput[]
    delete?: TrialExamResultWhereUniqueInput | TrialExamResultWhereUniqueInput[]
    connect?: TrialExamResultWhereUniqueInput | TrialExamResultWhereUniqueInput[]
    update?: TrialExamResultUpdateWithWhereUniqueWithoutTrialExamInput | TrialExamResultUpdateWithWhereUniqueWithoutTrialExamInput[]
    updateMany?: TrialExamResultUpdateManyWithWhereWithoutTrialExamInput | TrialExamResultUpdateManyWithWhereWithoutTrialExamInput[]
    deleteMany?: TrialExamResultScalarWhereInput | TrialExamResultScalarWhereInput[]
  }

  export type TrialExamResultUncheckedUpdateManyWithoutTrialExamNestedInput = {
    create?: XOR<TrialExamResultCreateWithoutTrialExamInput, TrialExamResultUncheckedCreateWithoutTrialExamInput> | TrialExamResultCreateWithoutTrialExamInput[] | TrialExamResultUncheckedCreateWithoutTrialExamInput[]
    connectOrCreate?: TrialExamResultCreateOrConnectWithoutTrialExamInput | TrialExamResultCreateOrConnectWithoutTrialExamInput[]
    upsert?: TrialExamResultUpsertWithWhereUniqueWithoutTrialExamInput | TrialExamResultUpsertWithWhereUniqueWithoutTrialExamInput[]
    createMany?: TrialExamResultCreateManyTrialExamInputEnvelope
    set?: TrialExamResultWhereUniqueInput | TrialExamResultWhereUniqueInput[]
    disconnect?: TrialExamResultWhereUniqueInput | TrialExamResultWhereUniqueInput[]
    delete?: TrialExamResultWhereUniqueInput | TrialExamResultWhereUniqueInput[]
    connect?: TrialExamResultWhereUniqueInput | TrialExamResultWhereUniqueInput[]
    update?: TrialExamResultUpdateWithWhereUniqueWithoutTrialExamInput | TrialExamResultUpdateWithWhereUniqueWithoutTrialExamInput[]
    updateMany?: TrialExamResultUpdateManyWithWhereWithoutTrialExamInput | TrialExamResultUpdateManyWithWhereWithoutTrialExamInput[]
    deleteMany?: TrialExamResultScalarWhereInput | TrialExamResultScalarWhereInput[]
  }

  export type TrialExamResultCreatemistakeTopicsInput = {
    set: string[]
  }

  export type TrialExamCreateNestedOneWithoutResultsInput = {
    create?: XOR<TrialExamCreateWithoutResultsInput, TrialExamUncheckedCreateWithoutResultsInput>
    connectOrCreate?: TrialExamCreateOrConnectWithoutResultsInput
    connect?: TrialExamWhereUniqueInput
  }

  export type TrialExamResultUpdatemistakeTopicsInput = {
    set?: string[]
    push?: string | string[]
  }

  export type TrialExamUpdateOneRequiredWithoutResultsNestedInput = {
    create?: XOR<TrialExamCreateWithoutResultsInput, TrialExamUncheckedCreateWithoutResultsInput>
    connectOrCreate?: TrialExamCreateOrConnectWithoutResultsInput
    upsert?: TrialExamUpsertWithoutResultsInput
    connect?: TrialExamWhereUniqueInput
    update?: XOR<XOR<TrialExamUpdateToOneWithWhereWithoutResultsInput, TrialExamUpdateWithoutResultsInput>, TrialExamUncheckedUpdateWithoutResultsInput>
  }

  export type LessonCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<LessonCreateWithoutAttendancesInput, LessonUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutAttendancesInput
    connect?: LessonWhereUniqueInput
  }

  export type StudentProfileCreateNestedOneWithoutAttendancesInput = {
    create?: XOR<StudentProfileCreateWithoutAttendancesInput, StudentProfileUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutAttendancesInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type EnumAttendanceStatusFieldUpdateOperationsInput = {
    set?: $Enums.AttendanceStatus
  }

  export type LessonUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<LessonCreateWithoutAttendancesInput, LessonUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: LessonCreateOrConnectWithoutAttendancesInput
    upsert?: LessonUpsertWithoutAttendancesInput
    connect?: LessonWhereUniqueInput
    update?: XOR<XOR<LessonUpdateToOneWithWhereWithoutAttendancesInput, LessonUpdateWithoutAttendancesInput>, LessonUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentProfileUpdateOneRequiredWithoutAttendancesNestedInput = {
    create?: XOR<StudentProfileCreateWithoutAttendancesInput, StudentProfileUncheckedCreateWithoutAttendancesInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutAttendancesInput
    upsert?: StudentProfileUpsertWithoutAttendancesInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutAttendancesInput, StudentProfileUpdateWithoutAttendancesInput>, StudentProfileUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentProfileCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<StudentProfileCreateWithoutPaymentsInput, StudentProfileUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutPaymentsInput
    connect?: StudentProfileWhereUniqueInput
  }

  export type TeacherProfileCreateNestedOneWithoutPaymentsInput = {
    create?: XOR<TeacherProfileCreateWithoutPaymentsInput, TeacherProfileUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutPaymentsInput
    connect?: TeacherProfileWhereUniqueInput
  }

  export type LessonCreateNestedManyWithoutPaymentsInput = {
    create?: XOR<LessonCreateWithoutPaymentsInput, LessonUncheckedCreateWithoutPaymentsInput> | LessonCreateWithoutPaymentsInput[] | LessonUncheckedCreateWithoutPaymentsInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutPaymentsInput | LessonCreateOrConnectWithoutPaymentsInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type LessonUncheckedCreateNestedManyWithoutPaymentsInput = {
    create?: XOR<LessonCreateWithoutPaymentsInput, LessonUncheckedCreateWithoutPaymentsInput> | LessonCreateWithoutPaymentsInput[] | LessonUncheckedCreateWithoutPaymentsInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutPaymentsInput | LessonCreateOrConnectWithoutPaymentsInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EnumPaymentTypeFieldUpdateOperationsInput = {
    set?: $Enums.PaymentType
  }

  export type StudentProfileUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<StudentProfileCreateWithoutPaymentsInput, StudentProfileUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: StudentProfileCreateOrConnectWithoutPaymentsInput
    upsert?: StudentProfileUpsertWithoutPaymentsInput
    connect?: StudentProfileWhereUniqueInput
    update?: XOR<XOR<StudentProfileUpdateToOneWithWhereWithoutPaymentsInput, StudentProfileUpdateWithoutPaymentsInput>, StudentProfileUncheckedUpdateWithoutPaymentsInput>
  }

  export type TeacherProfileUpdateOneRequiredWithoutPaymentsNestedInput = {
    create?: XOR<TeacherProfileCreateWithoutPaymentsInput, TeacherProfileUncheckedCreateWithoutPaymentsInput>
    connectOrCreate?: TeacherProfileCreateOrConnectWithoutPaymentsInput
    upsert?: TeacherProfileUpsertWithoutPaymentsInput
    connect?: TeacherProfileWhereUniqueInput
    update?: XOR<XOR<TeacherProfileUpdateToOneWithWhereWithoutPaymentsInput, TeacherProfileUpdateWithoutPaymentsInput>, TeacherProfileUncheckedUpdateWithoutPaymentsInput>
  }

  export type LessonUpdateManyWithoutPaymentsNestedInput = {
    create?: XOR<LessonCreateWithoutPaymentsInput, LessonUncheckedCreateWithoutPaymentsInput> | LessonCreateWithoutPaymentsInput[] | LessonUncheckedCreateWithoutPaymentsInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutPaymentsInput | LessonCreateOrConnectWithoutPaymentsInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutPaymentsInput | LessonUpsertWithWhereUniqueWithoutPaymentsInput[]
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutPaymentsInput | LessonUpdateWithWhereUniqueWithoutPaymentsInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutPaymentsInput | LessonUpdateManyWithWhereWithoutPaymentsInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type LessonUncheckedUpdateManyWithoutPaymentsNestedInput = {
    create?: XOR<LessonCreateWithoutPaymentsInput, LessonUncheckedCreateWithoutPaymentsInput> | LessonCreateWithoutPaymentsInput[] | LessonUncheckedCreateWithoutPaymentsInput[]
    connectOrCreate?: LessonCreateOrConnectWithoutPaymentsInput | LessonCreateOrConnectWithoutPaymentsInput[]
    upsert?: LessonUpsertWithWhereUniqueWithoutPaymentsInput | LessonUpsertWithWhereUniqueWithoutPaymentsInput[]
    set?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    disconnect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    delete?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    connect?: LessonWhereUniqueInput | LessonWhereUniqueInput[]
    update?: LessonUpdateWithWhereUniqueWithoutPaymentsInput | LessonUpdateWithWhereUniqueWithoutPaymentsInput[]
    updateMany?: LessonUpdateManyWithWhereWithoutPaymentsInput | LessonUpdateManyWithWhereWithoutPaymentsInput[]
    deleteMany?: LessonScalarWhereInput | LessonScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTodosInput = {
    create?: XOR<UserCreateWithoutTodosInput, UserUncheckedCreateWithoutTodosInput>
    connectOrCreate?: UserCreateOrConnectWithoutTodosInput
    connect?: UserWhereUniqueInput
  }

  export type EnumPriorityFieldUpdateOperationsInput = {
    set?: $Enums.Priority
  }

  export type UserUpdateOneRequiredWithoutTodosNestedInput = {
    create?: XOR<UserCreateWithoutTodosInput, UserUncheckedCreateWithoutTodosInput>
    connectOrCreate?: UserCreateOrConnectWithoutTodosInput
    upsert?: UserUpsertWithoutTodosInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTodosInput, UserUpdateWithoutTodosInput>, UserUncheckedUpdateWithoutTodosInput>
  }

  export type UserCreateNestedOneWithoutCalendarEventsInput = {
    create?: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarEventsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutCalendarEventsNestedInput = {
    create?: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    connectOrCreate?: UserCreateOrConnectWithoutCalendarEventsInput
    upsert?: UserUpsertWithoutCalendarEventsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCalendarEventsInput, UserUpdateWithoutCalendarEventsInput>, UserUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type FileCreateNestedOneWithoutMessagesInput = {
    create?: XOR<FileCreateWithoutMessagesInput, FileUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: FileCreateOrConnectWithoutMessagesInput
    connect?: FileWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutReceivedMessagesInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSentMessagesInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
  }

  export type FileUpdateOneWithoutMessagesNestedInput = {
    create?: XOR<FileCreateWithoutMessagesInput, FileUncheckedCreateWithoutMessagesInput>
    connectOrCreate?: FileCreateOrConnectWithoutMessagesInput
    upsert?: FileUpsertWithoutMessagesInput
    disconnect?: FileWhereInput | boolean
    delete?: FileWhereInput | boolean
    connect?: FileWhereUniqueInput
    update?: XOR<XOR<FileUpdateToOneWithWhereWithoutMessagesInput, FileUpdateWithoutMessagesInput>, FileUncheckedUpdateWithoutMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutReceivedMessagesNestedInput = {
    create?: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutReceivedMessagesInput
    upsert?: UserUpsertWithoutReceivedMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutReceivedMessagesInput, UserUpdateWithoutReceivedMessagesInput>, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateOneRequiredWithoutSentMessagesNestedInput = {
    create?: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    connectOrCreate?: UserCreateOrConnectWithoutSentMessagesInput
    upsert?: UserUpsertWithoutSentMessagesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSentMessagesInput, UserUpdateWithoutSentMessagesInput>, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserCreateNestedOneWithoutNotificationsInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    connect?: UserWhereUniqueInput
  }

  export type EnumNotificationTypeFieldUpdateOperationsInput = {
    set?: $Enums.NotificationType
  }

  export type UserUpdateOneRequiredWithoutNotificationsNestedInput = {
    create?: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutNotificationsInput
    upsert?: UserUpsertWithoutNotificationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutNotificationsInput, UserUpdateWithoutNotificationsInput>, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserCreateNestedOneWithoutFilesInput = {
    create?: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFilesInput
    connect?: UserWhereUniqueInput
  }

  export type MaterialCreateNestedManyWithoutFileInput = {
    create?: XOR<MaterialCreateWithoutFileInput, MaterialUncheckedCreateWithoutFileInput> | MaterialCreateWithoutFileInput[] | MaterialUncheckedCreateWithoutFileInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutFileInput | MaterialCreateOrConnectWithoutFileInput[]
    createMany?: MaterialCreateManyFileInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type MessageCreateNestedManyWithoutFileInput = {
    create?: XOR<MessageCreateWithoutFileInput, MessageUncheckedCreateWithoutFileInput> | MessageCreateWithoutFileInput[] | MessageUncheckedCreateWithoutFileInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutFileInput | MessageCreateOrConnectWithoutFileInput[]
    createMany?: MessageCreateManyFileInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type HomeworkTrackingCreateNestedManyWithoutFileInput = {
    create?: XOR<HomeworkTrackingCreateWithoutFileInput, HomeworkTrackingUncheckedCreateWithoutFileInput> | HomeworkTrackingCreateWithoutFileInput[] | HomeworkTrackingUncheckedCreateWithoutFileInput[]
    connectOrCreate?: HomeworkTrackingCreateOrConnectWithoutFileInput | HomeworkTrackingCreateOrConnectWithoutFileInput[]
    createMany?: HomeworkTrackingCreateManyFileInputEnvelope
    connect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
  }

  export type HomeworkSubmissionCreateNestedManyWithoutFileInput = {
    create?: XOR<HomeworkSubmissionCreateWithoutFileInput, HomeworkSubmissionUncheckedCreateWithoutFileInput> | HomeworkSubmissionCreateWithoutFileInput[] | HomeworkSubmissionUncheckedCreateWithoutFileInput[]
    connectOrCreate?: HomeworkSubmissionCreateOrConnectWithoutFileInput | HomeworkSubmissionCreateOrConnectWithoutFileInput[]
    createMany?: HomeworkSubmissionCreateManyFileInputEnvelope
    connect?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
  }

  export type MaterialUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<MaterialCreateWithoutFileInput, MaterialUncheckedCreateWithoutFileInput> | MaterialCreateWithoutFileInput[] | MaterialUncheckedCreateWithoutFileInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutFileInput | MaterialCreateOrConnectWithoutFileInput[]
    createMany?: MaterialCreateManyFileInputEnvelope
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
  }

  export type MessageUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<MessageCreateWithoutFileInput, MessageUncheckedCreateWithoutFileInput> | MessageCreateWithoutFileInput[] | MessageUncheckedCreateWithoutFileInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutFileInput | MessageCreateOrConnectWithoutFileInput[]
    createMany?: MessageCreateManyFileInputEnvelope
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
  }

  export type HomeworkTrackingUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<HomeworkTrackingCreateWithoutFileInput, HomeworkTrackingUncheckedCreateWithoutFileInput> | HomeworkTrackingCreateWithoutFileInput[] | HomeworkTrackingUncheckedCreateWithoutFileInput[]
    connectOrCreate?: HomeworkTrackingCreateOrConnectWithoutFileInput | HomeworkTrackingCreateOrConnectWithoutFileInput[]
    createMany?: HomeworkTrackingCreateManyFileInputEnvelope
    connect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
  }

  export type HomeworkSubmissionUncheckedCreateNestedManyWithoutFileInput = {
    create?: XOR<HomeworkSubmissionCreateWithoutFileInput, HomeworkSubmissionUncheckedCreateWithoutFileInput> | HomeworkSubmissionCreateWithoutFileInput[] | HomeworkSubmissionUncheckedCreateWithoutFileInput[]
    connectOrCreate?: HomeworkSubmissionCreateOrConnectWithoutFileInput | HomeworkSubmissionCreateOrConnectWithoutFileInput[]
    createMany?: HomeworkSubmissionCreateManyFileInputEnvelope
    connect?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
  }

  export type UserUpdateOneRequiredWithoutFilesNestedInput = {
    create?: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    connectOrCreate?: UserCreateOrConnectWithoutFilesInput
    upsert?: UserUpsertWithoutFilesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutFilesInput, UserUpdateWithoutFilesInput>, UserUncheckedUpdateWithoutFilesInput>
  }

  export type MaterialUpdateManyWithoutFileNestedInput = {
    create?: XOR<MaterialCreateWithoutFileInput, MaterialUncheckedCreateWithoutFileInput> | MaterialCreateWithoutFileInput[] | MaterialUncheckedCreateWithoutFileInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutFileInput | MaterialCreateOrConnectWithoutFileInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutFileInput | MaterialUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: MaterialCreateManyFileInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutFileInput | MaterialUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutFileInput | MaterialUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type MessageUpdateManyWithoutFileNestedInput = {
    create?: XOR<MessageCreateWithoutFileInput, MessageUncheckedCreateWithoutFileInput> | MessageCreateWithoutFileInput[] | MessageUncheckedCreateWithoutFileInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutFileInput | MessageCreateOrConnectWithoutFileInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutFileInput | MessageUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: MessageCreateManyFileInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutFileInput | MessageUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutFileInput | MessageUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type HomeworkTrackingUpdateManyWithoutFileNestedInput = {
    create?: XOR<HomeworkTrackingCreateWithoutFileInput, HomeworkTrackingUncheckedCreateWithoutFileInput> | HomeworkTrackingCreateWithoutFileInput[] | HomeworkTrackingUncheckedCreateWithoutFileInput[]
    connectOrCreate?: HomeworkTrackingCreateOrConnectWithoutFileInput | HomeworkTrackingCreateOrConnectWithoutFileInput[]
    upsert?: HomeworkTrackingUpsertWithWhereUniqueWithoutFileInput | HomeworkTrackingUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: HomeworkTrackingCreateManyFileInputEnvelope
    set?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    disconnect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    delete?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    connect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    update?: HomeworkTrackingUpdateWithWhereUniqueWithoutFileInput | HomeworkTrackingUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: HomeworkTrackingUpdateManyWithWhereWithoutFileInput | HomeworkTrackingUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: HomeworkTrackingScalarWhereInput | HomeworkTrackingScalarWhereInput[]
  }

  export type HomeworkSubmissionUpdateManyWithoutFileNestedInput = {
    create?: XOR<HomeworkSubmissionCreateWithoutFileInput, HomeworkSubmissionUncheckedCreateWithoutFileInput> | HomeworkSubmissionCreateWithoutFileInput[] | HomeworkSubmissionUncheckedCreateWithoutFileInput[]
    connectOrCreate?: HomeworkSubmissionCreateOrConnectWithoutFileInput | HomeworkSubmissionCreateOrConnectWithoutFileInput[]
    upsert?: HomeworkSubmissionUpsertWithWhereUniqueWithoutFileInput | HomeworkSubmissionUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: HomeworkSubmissionCreateManyFileInputEnvelope
    set?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    disconnect?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    delete?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    connect?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    update?: HomeworkSubmissionUpdateWithWhereUniqueWithoutFileInput | HomeworkSubmissionUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: HomeworkSubmissionUpdateManyWithWhereWithoutFileInput | HomeworkSubmissionUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: HomeworkSubmissionScalarWhereInput | HomeworkSubmissionScalarWhereInput[]
  }

  export type MaterialUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<MaterialCreateWithoutFileInput, MaterialUncheckedCreateWithoutFileInput> | MaterialCreateWithoutFileInput[] | MaterialUncheckedCreateWithoutFileInput[]
    connectOrCreate?: MaterialCreateOrConnectWithoutFileInput | MaterialCreateOrConnectWithoutFileInput[]
    upsert?: MaterialUpsertWithWhereUniqueWithoutFileInput | MaterialUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: MaterialCreateManyFileInputEnvelope
    set?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    disconnect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    delete?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    connect?: MaterialWhereUniqueInput | MaterialWhereUniqueInput[]
    update?: MaterialUpdateWithWhereUniqueWithoutFileInput | MaterialUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: MaterialUpdateManyWithWhereWithoutFileInput | MaterialUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
  }

  export type MessageUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<MessageCreateWithoutFileInput, MessageUncheckedCreateWithoutFileInput> | MessageCreateWithoutFileInput[] | MessageUncheckedCreateWithoutFileInput[]
    connectOrCreate?: MessageCreateOrConnectWithoutFileInput | MessageCreateOrConnectWithoutFileInput[]
    upsert?: MessageUpsertWithWhereUniqueWithoutFileInput | MessageUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: MessageCreateManyFileInputEnvelope
    set?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    disconnect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    delete?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    connect?: MessageWhereUniqueInput | MessageWhereUniqueInput[]
    update?: MessageUpdateWithWhereUniqueWithoutFileInput | MessageUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: MessageUpdateManyWithWhereWithoutFileInput | MessageUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: MessageScalarWhereInput | MessageScalarWhereInput[]
  }

  export type HomeworkTrackingUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<HomeworkTrackingCreateWithoutFileInput, HomeworkTrackingUncheckedCreateWithoutFileInput> | HomeworkTrackingCreateWithoutFileInput[] | HomeworkTrackingUncheckedCreateWithoutFileInput[]
    connectOrCreate?: HomeworkTrackingCreateOrConnectWithoutFileInput | HomeworkTrackingCreateOrConnectWithoutFileInput[]
    upsert?: HomeworkTrackingUpsertWithWhereUniqueWithoutFileInput | HomeworkTrackingUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: HomeworkTrackingCreateManyFileInputEnvelope
    set?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    disconnect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    delete?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    connect?: HomeworkTrackingWhereUniqueInput | HomeworkTrackingWhereUniqueInput[]
    update?: HomeworkTrackingUpdateWithWhereUniqueWithoutFileInput | HomeworkTrackingUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: HomeworkTrackingUpdateManyWithWhereWithoutFileInput | HomeworkTrackingUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: HomeworkTrackingScalarWhereInput | HomeworkTrackingScalarWhereInput[]
  }

  export type HomeworkSubmissionUncheckedUpdateManyWithoutFileNestedInput = {
    create?: XOR<HomeworkSubmissionCreateWithoutFileInput, HomeworkSubmissionUncheckedCreateWithoutFileInput> | HomeworkSubmissionCreateWithoutFileInput[] | HomeworkSubmissionUncheckedCreateWithoutFileInput[]
    connectOrCreate?: HomeworkSubmissionCreateOrConnectWithoutFileInput | HomeworkSubmissionCreateOrConnectWithoutFileInput[]
    upsert?: HomeworkSubmissionUpsertWithWhereUniqueWithoutFileInput | HomeworkSubmissionUpsertWithWhereUniqueWithoutFileInput[]
    createMany?: HomeworkSubmissionCreateManyFileInputEnvelope
    set?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    disconnect?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    delete?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    connect?: HomeworkSubmissionWhereUniqueInput | HomeworkSubmissionWhereUniqueInput[]
    update?: HomeworkSubmissionUpdateWithWhereUniqueWithoutFileInput | HomeworkSubmissionUpdateWithWhereUniqueWithoutFileInput[]
    updateMany?: HomeworkSubmissionUpdateManyWithWhereWithoutFileInput | HomeworkSubmissionUpdateManyWithWhereWithoutFileInput[]
    deleteMany?: HomeworkSubmissionScalarWhereInput | HomeworkSubmissionScalarWhereInput[]
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedEnumRoleNullableFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableFilter<$PrismaModel> | $Enums.Role | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Role | EnumRoleFieldRefInput<$PrismaModel> | null
    in?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    notIn?: $Enums.Role[] | ListEnumRoleFieldRefInput<$PrismaModel> | null
    not?: NestedEnumRoleNullableWithAggregatesFilter<$PrismaModel> | $Enums.Role | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedEnumRoleNullableFilter<$PrismaModel>
    _max?: NestedEnumRoleNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumDeviceTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceTypeFilter<$PrismaModel> | $Enums.DeviceType
  }

  export type NestedEnumDeviceTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.DeviceType | EnumDeviceTypeFieldRefInput<$PrismaModel>
    in?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.DeviceType[] | ListEnumDeviceTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumDeviceTypeWithAggregatesFilter<$PrismaModel> | $Enums.DeviceType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumDeviceTypeFilter<$PrismaModel>
    _max?: NestedEnumDeviceTypeFilter<$PrismaModel>
  }

  export type NestedEnumRelationStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationStatus | EnumRelationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RelationStatus[] | ListEnumRelationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationStatus[] | ListEnumRelationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationStatusFilter<$PrismaModel> | $Enums.RelationStatus
  }

  export type NestedEnumRelationStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.RelationStatus | EnumRelationStatusFieldRefInput<$PrismaModel>
    in?: $Enums.RelationStatus[] | ListEnumRelationStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.RelationStatus[] | ListEnumRelationStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumRelationStatusWithAggregatesFilter<$PrismaModel> | $Enums.RelationStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRelationStatusFilter<$PrismaModel>
    _max?: NestedEnumRelationStatusFilter<$PrismaModel>
  }

  export type NestedEnumLessonTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeFilter<$PrismaModel> | $Enums.LessonType
  }

  export type NestedEnumLessonLocationFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonLocation | EnumLessonLocationFieldRefInput<$PrismaModel>
    in?: $Enums.LessonLocation[] | ListEnumLessonLocationFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonLocation[] | ListEnumLessonLocationFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonLocationFilter<$PrismaModel> | $Enums.LessonLocation
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonType | EnumLessonTypeFieldRefInput<$PrismaModel>
    in?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonType[] | ListEnumLessonTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonTypeWithAggregatesFilter<$PrismaModel> | $Enums.LessonType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonTypeFilter<$PrismaModel>
    _max?: NestedEnumLessonTypeFilter<$PrismaModel>
  }

  export type NestedEnumLessonLocationWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonLocation | EnumLessonLocationFieldRefInput<$PrismaModel>
    in?: $Enums.LessonLocation[] | ListEnumLessonLocationFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonLocation[] | ListEnumLessonLocationFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonLocationWithAggregatesFilter<$PrismaModel> | $Enums.LessonLocation
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonLocationFilter<$PrismaModel>
    _max?: NestedEnumLessonLocationFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel> | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedEnumLessonStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonStatus | EnumLessonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonStatusFilter<$PrismaModel> | $Enums.LessonStatus
  }

  export type NestedEnumLessonStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.LessonStatus | EnumLessonStatusFieldRefInput<$PrismaModel>
    in?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.LessonStatus[] | ListEnumLessonStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumLessonStatusWithAggregatesFilter<$PrismaModel> | $Enums.LessonStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumLessonStatusFilter<$PrismaModel>
    _max?: NestedEnumLessonStatusFilter<$PrismaModel>
  }

  export type NestedEnumFileTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeFilter<$PrismaModel> | $Enums.FileType
  }

  export type NestedEnumFileTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.FileType | EnumFileTypeFieldRefInput<$PrismaModel>
    in?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.FileType[] | ListEnumFileTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumFileTypeWithAggregatesFilter<$PrismaModel> | $Enums.FileType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumFileTypeFilter<$PrismaModel>
    _max?: NestedEnumFileTypeFilter<$PrismaModel>
  }

  export type NestedEnumHomeworkStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.HomeworkStatus | EnumHomeworkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HomeworkStatus[] | ListEnumHomeworkStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HomeworkStatus[] | ListEnumHomeworkStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHomeworkStatusFilter<$PrismaModel> | $Enums.HomeworkStatus
  }

  export type NestedEnumHomeworkStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.HomeworkStatus | EnumHomeworkStatusFieldRefInput<$PrismaModel>
    in?: $Enums.HomeworkStatus[] | ListEnumHomeworkStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.HomeworkStatus[] | ListEnumHomeworkStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumHomeworkStatusWithAggregatesFilter<$PrismaModel> | $Enums.HomeworkStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumHomeworkStatusFilter<$PrismaModel>
    _max?: NestedEnumHomeworkStatusFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedEnumExamCategoryFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamCategory | EnumExamCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExamCategory[] | ListEnumExamCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamCategory[] | ListEnumExamCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExamCategoryFilter<$PrismaModel> | $Enums.ExamCategory
  }

  export type NestedEnumExamCategoryWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.ExamCategory | EnumExamCategoryFieldRefInput<$PrismaModel>
    in?: $Enums.ExamCategory[] | ListEnumExamCategoryFieldRefInput<$PrismaModel>
    notIn?: $Enums.ExamCategory[] | ListEnumExamCategoryFieldRefInput<$PrismaModel>
    not?: NestedEnumExamCategoryWithAggregatesFilter<$PrismaModel> | $Enums.ExamCategory
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumExamCategoryFilter<$PrismaModel>
    _max?: NestedEnumExamCategoryFilter<$PrismaModel>
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedEnumAttendanceStatusFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusFilter<$PrismaModel> | $Enums.AttendanceStatus
  }

  export type NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.AttendanceStatus | EnumAttendanceStatusFieldRefInput<$PrismaModel>
    in?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    notIn?: $Enums.AttendanceStatus[] | ListEnumAttendanceStatusFieldRefInput<$PrismaModel>
    not?: NestedEnumAttendanceStatusWithAggregatesFilter<$PrismaModel> | $Enums.AttendanceStatus
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumAttendanceStatusFilter<$PrismaModel>
    _max?: NestedEnumAttendanceStatusFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedEnumPaymentTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeFilter<$PrismaModel> | $Enums.PaymentType
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | ListDecimalFieldRefInput<$PrismaModel>
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.PaymentType | EnumPaymentTypeFieldRefInput<$PrismaModel>
    in?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.PaymentType[] | ListEnumPaymentTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumPaymentTypeWithAggregatesFilter<$PrismaModel> | $Enums.PaymentType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPaymentTypeFilter<$PrismaModel>
    _max?: NestedEnumPaymentTypeFilter<$PrismaModel>
  }

  export type NestedEnumPriorityFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityFilter<$PrismaModel> | $Enums.Priority
  }

  export type NestedEnumPriorityWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Priority | EnumPriorityFieldRefInput<$PrismaModel>
    in?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    notIn?: $Enums.Priority[] | ListEnumPriorityFieldRefInput<$PrismaModel>
    not?: NestedEnumPriorityWithAggregatesFilter<$PrismaModel> | $Enums.Priority
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumPriorityFilter<$PrismaModel>
    _max?: NestedEnumPriorityFilter<$PrismaModel>
  }

  export type NestedEnumNotificationTypeFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeFilter<$PrismaModel> | $Enums.NotificationType
  }

  export type NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.NotificationType | EnumNotificationTypeFieldRefInput<$PrismaModel>
    in?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    notIn?: $Enums.NotificationType[] | ListEnumNotificationTypeFieldRefInput<$PrismaModel>
    not?: NestedEnumNotificationTypeWithAggregatesFilter<$PrismaModel> | $Enums.NotificationType
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumNotificationTypeFilter<$PrismaModel>
    _max?: NestedEnumNotificationTypeFilter<$PrismaModel>
  }

  export type UserSettingsCreateWithoutUserInput = {
    id?: string
    profileVisibility?: string
    showAvatar?: boolean
    showEmail?: boolean
    showPhone?: boolean
    allowMessages?: boolean
    showCourses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsUncheckedCreateWithoutUserInput = {
    id?: string
    profileVisibility?: string
    showAvatar?: boolean
    showEmail?: boolean
    showPhone?: boolean
    allowMessages?: boolean
    showCourses?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserSettingsCreateOrConnectWithoutUserInput = {
    where: UserSettingsWhereUniqueInput
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
  }

  export type TeacherProfileCreateWithoutUserInput = {
    id?: string
    branch: string
    bio?: string | null
    studentRelations?: StudentTeacherRelationCreateNestedManyWithoutTeacherInput
    classes?: ClassroomCreateNestedManyWithoutTeacherInput
    lessons?: LessonCreateNestedManyWithoutTeacherInput
    payments?: PaymentCreateNestedManyWithoutTeacherInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileUncheckedCreateWithoutUserInput = {
    id?: string
    branch: string
    bio?: string | null
    studentRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutTeacherInput
    classes?: ClassroomUncheckedCreateNestedManyWithoutTeacherInput
    lessons?: LessonUncheckedCreateNestedManyWithoutTeacherInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTeacherInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileCreateOrConnectWithoutUserInput = {
    where: TeacherProfileWhereUniqueInput
    create: XOR<TeacherProfileCreateWithoutUserInput, TeacherProfileUncheckedCreateWithoutUserInput>
  }

  export type StudentProfileCreateWithoutUserInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherRelations?: StudentTeacherRelationCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemCreateNestedManyWithoutStudentInput
    lessons?: LessonCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutStudentInput
    grades?: SchoolExamCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUncheckedCreateWithoutUserInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemUncheckedCreateNestedManyWithoutStudentInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentInput
    grades?: SchoolExamUncheckedCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileCreateOrConnectWithoutUserInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountUncheckedCreateWithoutUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type AccountCreateOrConnectWithoutUserInput = {
    where: AccountWhereUniqueInput
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountCreateManyUserInputEnvelope = {
    data: AccountCreateManyUserInput | AccountCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type SessionCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionUncheckedCreateWithoutUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type SessionCreateOrConnectWithoutUserInput = {
    where: SessionWhereUniqueInput
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionCreateManyUserInputEnvelope = {
    data: SessionCreateManyUserInput | SessionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailChangeRequestCreateWithoutUserInput = {
    id?: string
    newEmail: string
    token: string
    expires: Date | string
    usedAt?: Date | string | null
  }

  export type EmailChangeRequestUncheckedCreateWithoutUserInput = {
    id?: string
    newEmail: string
    token: string
    expires: Date | string
    usedAt?: Date | string | null
  }

  export type EmailChangeRequestCreateOrConnectWithoutUserInput = {
    where: EmailChangeRequestWhereUniqueInput
    create: XOR<EmailChangeRequestCreateWithoutUserInput, EmailChangeRequestUncheckedCreateWithoutUserInput>
  }

  export type EmailChangeRequestCreateManyUserInputEnvelope = {
    data: EmailChangeRequestCreateManyUserInput | EmailChangeRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DeviceCreateWithoutUserInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceId?: string | null
    model?: string | null
    fcmToken?: string | null
    lastActive?: Date | string
  }

  export type DeviceUncheckedCreateWithoutUserInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceId?: string | null
    model?: string | null
    fcmToken?: string | null
    lastActive?: Date | string
  }

  export type DeviceCreateOrConnectWithoutUserInput = {
    where: DeviceWhereUniqueInput
    create: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
  }

  export type DeviceCreateManyUserInputEnvelope = {
    data: DeviceCreateManyUserInput | DeviceCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutUserInput = {
    id?: string
    title: string
    body: string
    route?: string | null
    relatedId?: string | null
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    body: string
    route?: string | null
    relatedId?: string | null
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutUserInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationCreateManyUserInputEnvelope = {
    data: NotificationCreateManyUserInput | NotificationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutSenderInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    isRead?: boolean
    readAt?: Date | string | null
    file?: FileCreateNestedOneWithoutMessagesInput
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
  }

  export type MessageUncheckedCreateWithoutSenderInput = {
    id?: string
    content?: string | null
    fileId?: string | null
    createdAt?: Date | string
    isRead?: boolean
    readAt?: Date | string | null
    receiverId: string
  }

  export type MessageCreateOrConnectWithoutSenderInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageCreateManySenderInputEnvelope = {
    data: MessageCreateManySenderInput | MessageCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutReceiverInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    isRead?: boolean
    readAt?: Date | string | null
    file?: FileCreateNestedOneWithoutMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutReceiverInput = {
    id?: string
    content?: string | null
    fileId?: string | null
    createdAt?: Date | string
    isRead?: boolean
    readAt?: Date | string | null
    senderId: string
  }

  export type MessageCreateOrConnectWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageCreateManyReceiverInputEnvelope = {
    data: MessageCreateManyReceiverInput | MessageCreateManyReceiverInput[]
    skipDuplicates?: boolean
  }

  export type TodoCreateWithoutUserInput = {
    id?: string
    content: string
    isCompleted?: boolean
    dueDate?: Date | string | null
    reminderTime?: Date | string | null
    priority?: $Enums.Priority
    createdAt?: Date | string
  }

  export type TodoUncheckedCreateWithoutUserInput = {
    id?: string
    content: string
    isCompleted?: boolean
    dueDate?: Date | string | null
    reminderTime?: Date | string | null
    priority?: $Enums.Priority
    createdAt?: Date | string
  }

  export type TodoCreateOrConnectWithoutUserInput = {
    where: TodoWhereUniqueInput
    create: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput>
  }

  export type TodoCreateManyUserInputEnvelope = {
    data: TodoCreateManyUserInput | TodoCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isAllDay?: boolean
    remindAt?: Date | string | null
    color?: string | null
  }

  export type EventUncheckedCreateWithoutUserInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isAllDay?: boolean
    remindAt?: Date | string | null
    color?: string | null
  }

  export type EventCreateOrConnectWithoutUserInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput>
  }

  export type EventCreateManyUserInputEnvelope = {
    data: EventCreateManyUserInput | EventCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type FileCreateWithoutOwnerInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: MaterialCreateNestedManyWithoutFileInput
    messages?: MessageCreateNestedManyWithoutFileInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutFileInput
    homeworkSubmissions?: HomeworkSubmissionCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutOwnerInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: MaterialUncheckedCreateNestedManyWithoutFileInput
    messages?: MessageUncheckedCreateNestedManyWithoutFileInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutFileInput
    homeworkSubmissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutOwnerInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutOwnerInput, FileUncheckedCreateWithoutOwnerInput>
  }

  export type FileCreateManyOwnerInputEnvelope = {
    data: FileCreateManyOwnerInput | FileCreateManyOwnerInput[]
    skipDuplicates?: boolean
  }

  export type UserSettingsUpsertWithoutUserInput = {
    update: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
    create: XOR<UserSettingsCreateWithoutUserInput, UserSettingsUncheckedCreateWithoutUserInput>
    where?: UserSettingsWhereInput
  }

  export type UserSettingsUpdateToOneWithWhereWithoutUserInput = {
    where?: UserSettingsWhereInput
    data: XOR<UserSettingsUpdateWithoutUserInput, UserSettingsUncheckedUpdateWithoutUserInput>
  }

  export type UserSettingsUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileVisibility?: StringFieldUpdateOperationsInput | string
    showAvatar?: BoolFieldUpdateOperationsInput | boolean
    showEmail?: BoolFieldUpdateOperationsInput | boolean
    showPhone?: BoolFieldUpdateOperationsInput | boolean
    allowMessages?: BoolFieldUpdateOperationsInput | boolean
    showCourses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserSettingsUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    profileVisibility?: StringFieldUpdateOperationsInput | string
    showAvatar?: BoolFieldUpdateOperationsInput | boolean
    showEmail?: BoolFieldUpdateOperationsInput | boolean
    showPhone?: BoolFieldUpdateOperationsInput | boolean
    allowMessages?: BoolFieldUpdateOperationsInput | boolean
    showCourses?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherProfileUpsertWithoutUserInput = {
    update: XOR<TeacherProfileUpdateWithoutUserInput, TeacherProfileUncheckedUpdateWithoutUserInput>
    create: XOR<TeacherProfileCreateWithoutUserInput, TeacherProfileUncheckedCreateWithoutUserInput>
    where?: TeacherProfileWhereInput
  }

  export type TeacherProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: TeacherProfileWhereInput
    data: XOR<TeacherProfileUpdateWithoutUserInput, TeacherProfileUncheckedUpdateWithoutUserInput>
  }

  export type TeacherProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    studentRelations?: StudentTeacherRelationUpdateManyWithoutTeacherNestedInput
    classes?: ClassroomUpdateManyWithoutTeacherNestedInput
    lessons?: LessonUpdateManyWithoutTeacherNestedInput
    payments?: PaymentUpdateManyWithoutTeacherNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    studentRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: ClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutTeacherNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTeacherNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type StudentProfileUpsertWithoutUserInput = {
    update: XOR<StudentProfileUpdateWithoutUserInput, StudentProfileUncheckedUpdateWithoutUserInput>
    create: XOR<StudentProfileCreateWithoutUserInput, StudentProfileUncheckedCreateWithoutUserInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutUserInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutUserInput, StudentProfileUncheckedUpdateWithoutUserInput>
  }

  export type StudentProfileUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherRelations?: StudentTeacherRelationUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUpdateManyWithoutStudentNestedInput
    lessons?: LessonUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUncheckedUpdateManyWithoutStudentNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUncheckedUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type AccountUpsertWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    update: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
    create: XOR<AccountCreateWithoutUserInput, AccountUncheckedCreateWithoutUserInput>
  }

  export type AccountUpdateWithWhereUniqueWithoutUserInput = {
    where: AccountWhereUniqueInput
    data: XOR<AccountUpdateWithoutUserInput, AccountUncheckedUpdateWithoutUserInput>
  }

  export type AccountUpdateManyWithWhereWithoutUserInput = {
    where: AccountScalarWhereInput
    data: XOR<AccountUpdateManyMutationInput, AccountUncheckedUpdateManyWithoutUserInput>
  }

  export type AccountScalarWhereInput = {
    AND?: AccountScalarWhereInput | AccountScalarWhereInput[]
    OR?: AccountScalarWhereInput[]
    NOT?: AccountScalarWhereInput | AccountScalarWhereInput[]
    id?: StringFilter<"Account"> | string
    userId?: StringFilter<"Account"> | string
    type?: StringFilter<"Account"> | string
    provider?: StringFilter<"Account"> | string
    providerAccountId?: StringFilter<"Account"> | string
    refresh_token?: StringNullableFilter<"Account"> | string | null
    access_token?: StringNullableFilter<"Account"> | string | null
    expires_at?: IntNullableFilter<"Account"> | number | null
    token_type?: StringNullableFilter<"Account"> | string | null
    scope?: StringNullableFilter<"Account"> | string | null
    id_token?: StringNullableFilter<"Account"> | string | null
    session_state?: StringNullableFilter<"Account"> | string | null
  }

  export type SessionUpsertWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    update: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
    create: XOR<SessionCreateWithoutUserInput, SessionUncheckedCreateWithoutUserInput>
  }

  export type SessionUpdateWithWhereUniqueWithoutUserInput = {
    where: SessionWhereUniqueInput
    data: XOR<SessionUpdateWithoutUserInput, SessionUncheckedUpdateWithoutUserInput>
  }

  export type SessionUpdateManyWithWhereWithoutUserInput = {
    where: SessionScalarWhereInput
    data: XOR<SessionUpdateManyMutationInput, SessionUncheckedUpdateManyWithoutUserInput>
  }

  export type SessionScalarWhereInput = {
    AND?: SessionScalarWhereInput | SessionScalarWhereInput[]
    OR?: SessionScalarWhereInput[]
    NOT?: SessionScalarWhereInput | SessionScalarWhereInput[]
    id?: StringFilter<"Session"> | string
    sessionToken?: StringFilter<"Session"> | string
    userId?: StringFilter<"Session"> | string
    expires?: DateTimeFilter<"Session"> | Date | string
  }

  export type EmailChangeRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: EmailChangeRequestWhereUniqueInput
    update: XOR<EmailChangeRequestUpdateWithoutUserInput, EmailChangeRequestUncheckedUpdateWithoutUserInput>
    create: XOR<EmailChangeRequestCreateWithoutUserInput, EmailChangeRequestUncheckedCreateWithoutUserInput>
  }

  export type EmailChangeRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: EmailChangeRequestWhereUniqueInput
    data: XOR<EmailChangeRequestUpdateWithoutUserInput, EmailChangeRequestUncheckedUpdateWithoutUserInput>
  }

  export type EmailChangeRequestUpdateManyWithWhereWithoutUserInput = {
    where: EmailChangeRequestScalarWhereInput
    data: XOR<EmailChangeRequestUpdateManyMutationInput, EmailChangeRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type EmailChangeRequestScalarWhereInput = {
    AND?: EmailChangeRequestScalarWhereInput | EmailChangeRequestScalarWhereInput[]
    OR?: EmailChangeRequestScalarWhereInput[]
    NOT?: EmailChangeRequestScalarWhereInput | EmailChangeRequestScalarWhereInput[]
    id?: StringFilter<"EmailChangeRequest"> | string
    userId?: StringFilter<"EmailChangeRequest"> | string
    newEmail?: StringFilter<"EmailChangeRequest"> | string
    token?: StringFilter<"EmailChangeRequest"> | string
    expires?: DateTimeFilter<"EmailChangeRequest"> | Date | string
    usedAt?: DateTimeNullableFilter<"EmailChangeRequest"> | Date | string | null
  }

  export type DeviceUpsertWithWhereUniqueWithoutUserInput = {
    where: DeviceWhereUniqueInput
    update: XOR<DeviceUpdateWithoutUserInput, DeviceUncheckedUpdateWithoutUserInput>
    create: XOR<DeviceCreateWithoutUserInput, DeviceUncheckedCreateWithoutUserInput>
  }

  export type DeviceUpdateWithWhereUniqueWithoutUserInput = {
    where: DeviceWhereUniqueInput
    data: XOR<DeviceUpdateWithoutUserInput, DeviceUncheckedUpdateWithoutUserInput>
  }

  export type DeviceUpdateManyWithWhereWithoutUserInput = {
    where: DeviceScalarWhereInput
    data: XOR<DeviceUpdateManyMutationInput, DeviceUncheckedUpdateManyWithoutUserInput>
  }

  export type DeviceScalarWhereInput = {
    AND?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    OR?: DeviceScalarWhereInput[]
    NOT?: DeviceScalarWhereInput | DeviceScalarWhereInput[]
    id?: StringFilter<"Device"> | string
    userId?: StringFilter<"Device"> | string
    deviceType?: EnumDeviceTypeFilter<"Device"> | $Enums.DeviceType
    deviceId?: StringNullableFilter<"Device"> | string | null
    model?: StringNullableFilter<"Device"> | string | null
    fcmToken?: StringNullableFilter<"Device"> | string | null
    lastActive?: DateTimeFilter<"Device"> | Date | string
  }

  export type NotificationUpsertWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
    create: XOR<NotificationCreateWithoutUserInput, NotificationUncheckedCreateWithoutUserInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutUserInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutUserInput, NotificationUncheckedUpdateWithoutUserInput>
  }

  export type NotificationUpdateManyWithWhereWithoutUserInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutUserInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    body?: StringFilter<"Notification"> | string
    route?: StringNullableFilter<"Notification"> | string | null
    relatedId?: StringNullableFilter<"Notification"> | string | null
    type?: EnumNotificationTypeFilter<"Notification"> | $Enums.NotificationType
    isRead?: BoolFilter<"Notification"> | boolean
    userId?: StringFilter<"Notification"> | string
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type MessageUpsertWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
    create: XOR<MessageCreateWithoutSenderInput, MessageUncheckedCreateWithoutSenderInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutSenderInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutSenderInput, MessageUncheckedUpdateWithoutSenderInput>
  }

  export type MessageUpdateManyWithWhereWithoutSenderInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutSenderInput>
  }

  export type MessageScalarWhereInput = {
    AND?: MessageScalarWhereInput | MessageScalarWhereInput[]
    OR?: MessageScalarWhereInput[]
    NOT?: MessageScalarWhereInput | MessageScalarWhereInput[]
    id?: StringFilter<"Message"> | string
    content?: StringNullableFilter<"Message"> | string | null
    fileId?: StringNullableFilter<"Message"> | string | null
    createdAt?: DateTimeFilter<"Message"> | Date | string
    isRead?: BoolFilter<"Message"> | boolean
    readAt?: DateTimeNullableFilter<"Message"> | Date | string | null
    senderId?: StringFilter<"Message"> | string
    receiverId?: StringFilter<"Message"> | string
  }

  export type MessageUpsertWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
    create: XOR<MessageCreateWithoutReceiverInput, MessageUncheckedCreateWithoutReceiverInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutReceiverInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutReceiverInput, MessageUncheckedUpdateWithoutReceiverInput>
  }

  export type MessageUpdateManyWithWhereWithoutReceiverInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutReceiverInput>
  }

  export type TodoUpsertWithWhereUniqueWithoutUserInput = {
    where: TodoWhereUniqueInput
    update: XOR<TodoUpdateWithoutUserInput, TodoUncheckedUpdateWithoutUserInput>
    create: XOR<TodoCreateWithoutUserInput, TodoUncheckedCreateWithoutUserInput>
  }

  export type TodoUpdateWithWhereUniqueWithoutUserInput = {
    where: TodoWhereUniqueInput
    data: XOR<TodoUpdateWithoutUserInput, TodoUncheckedUpdateWithoutUserInput>
  }

  export type TodoUpdateManyWithWhereWithoutUserInput = {
    where: TodoScalarWhereInput
    data: XOR<TodoUpdateManyMutationInput, TodoUncheckedUpdateManyWithoutUserInput>
  }

  export type TodoScalarWhereInput = {
    AND?: TodoScalarWhereInput | TodoScalarWhereInput[]
    OR?: TodoScalarWhereInput[]
    NOT?: TodoScalarWhereInput | TodoScalarWhereInput[]
    id?: StringFilter<"Todo"> | string
    content?: StringFilter<"Todo"> | string
    isCompleted?: BoolFilter<"Todo"> | boolean
    dueDate?: DateTimeNullableFilter<"Todo"> | Date | string | null
    reminderTime?: DateTimeNullableFilter<"Todo"> | Date | string | null
    priority?: EnumPriorityFilter<"Todo"> | $Enums.Priority
    userId?: StringFilter<"Todo"> | string
    createdAt?: DateTimeFilter<"Todo"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutUserInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutUserInput, EventUncheckedUpdateWithoutUserInput>
    create: XOR<EventCreateWithoutUserInput, EventUncheckedCreateWithoutUserInput>
  }

  export type EventUpdateWithWhereUniqueWithoutUserInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutUserInput, EventUncheckedUpdateWithoutUserInput>
  }

  export type EventUpdateManyWithWhereWithoutUserInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutUserInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    description?: StringNullableFilter<"Event"> | string | null
    startDate?: DateTimeFilter<"Event"> | Date | string
    endDate?: DateTimeFilter<"Event"> | Date | string
    isAllDay?: BoolFilter<"Event"> | boolean
    remindAt?: DateTimeNullableFilter<"Event"> | Date | string | null
    color?: StringNullableFilter<"Event"> | string | null
    userId?: StringFilter<"Event"> | string
  }

  export type FileUpsertWithWhereUniqueWithoutOwnerInput = {
    where: FileWhereUniqueInput
    update: XOR<FileUpdateWithoutOwnerInput, FileUncheckedUpdateWithoutOwnerInput>
    create: XOR<FileCreateWithoutOwnerInput, FileUncheckedCreateWithoutOwnerInput>
  }

  export type FileUpdateWithWhereUniqueWithoutOwnerInput = {
    where: FileWhereUniqueInput
    data: XOR<FileUpdateWithoutOwnerInput, FileUncheckedUpdateWithoutOwnerInput>
  }

  export type FileUpdateManyWithWhereWithoutOwnerInput = {
    where: FileScalarWhereInput
    data: XOR<FileUpdateManyMutationInput, FileUncheckedUpdateManyWithoutOwnerInput>
  }

  export type FileScalarWhereInput = {
    AND?: FileScalarWhereInput | FileScalarWhereInput[]
    OR?: FileScalarWhereInput[]
    NOT?: FileScalarWhereInput | FileScalarWhereInput[]
    id?: StringFilter<"File"> | string
    key?: StringFilter<"File"> | string
    filename?: StringFilter<"File"> | string
    mimeType?: StringFilter<"File"> | string
    sizeBytes?: IntFilter<"File"> | number
    ownerId?: StringFilter<"File"> | string
    createdAt?: DateTimeFilter<"File"> | Date | string
    updatedAt?: DateTimeFilter<"File"> | Date | string
  }

  export type UserCreateWithoutSettingsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    todos?: TodoCreateNestedManyWithoutUserInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutSettingsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutSettingsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
  }

  export type UserUpsertWithoutSettingsInput = {
    update: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
    create: XOR<UserCreateWithoutSettingsInput, UserUncheckedCreateWithoutSettingsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSettingsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSettingsInput, UserUncheckedUpdateWithoutSettingsInput>
  }

  export type UserUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutSettingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    todos?: TodoCreateNestedManyWithoutUserInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutAccountsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutAccountsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
  }

  export type UserUpsertWithoutAccountsInput = {
    update: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
    create: XOR<UserCreateWithoutAccountsInput, UserUncheckedCreateWithoutAccountsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAccountsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAccountsInput, UserUncheckedUpdateWithoutAccountsInput>
  }

  export type UserUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutAccountsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    todos?: TodoCreateNestedManyWithoutUserInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutSessionsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutSessionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
  }

  export type UserUpsertWithoutSessionsInput = {
    update: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
    create: XOR<UserCreateWithoutSessionsInput, UserUncheckedCreateWithoutSessionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSessionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSessionsInput, UserUncheckedUpdateWithoutSessionsInput>
  }

  export type UserUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutSessionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutEmailChangeRequestsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    todos?: TodoCreateNestedManyWithoutUserInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutEmailChangeRequestsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutEmailChangeRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailChangeRequestsInput, UserUncheckedCreateWithoutEmailChangeRequestsInput>
  }

  export type UserUpsertWithoutEmailChangeRequestsInput = {
    update: XOR<UserUpdateWithoutEmailChangeRequestsInput, UserUncheckedUpdateWithoutEmailChangeRequestsInput>
    create: XOR<UserCreateWithoutEmailChangeRequestsInput, UserUncheckedCreateWithoutEmailChangeRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailChangeRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailChangeRequestsInput, UserUncheckedUpdateWithoutEmailChangeRequestsInput>
  }

  export type UserUpdateWithoutEmailChangeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailChangeRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutDevicesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    todos?: TodoCreateNestedManyWithoutUserInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutDevicesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutDevicesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
  }

  export type UserUpsertWithoutDevicesInput = {
    update: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
    create: XOR<UserCreateWithoutDevicesInput, UserUncheckedCreateWithoutDevicesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDevicesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDevicesInput, UserUncheckedUpdateWithoutDevicesInput>
  }

  export type UserUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutDevicesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutTeacherProfileInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    todos?: TodoCreateNestedManyWithoutUserInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutTeacherProfileInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutTeacherProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeacherProfileInput, UserUncheckedCreateWithoutTeacherProfileInput>
  }

  export type StudentTeacherRelationCreateWithoutTeacherInput = {
    id?: string
    status?: $Enums.RelationStatus
    isCreator?: boolean
    customName?: string | null
    privateNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    student: StudentProfileCreateNestedOneWithoutTeacherRelationsInput
  }

  export type StudentTeacherRelationUncheckedCreateWithoutTeacherInput = {
    id?: string
    studentId: string
    status?: $Enums.RelationStatus
    isCreator?: boolean
    customName?: string | null
    privateNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTeacherRelationCreateOrConnectWithoutTeacherInput = {
    where: StudentTeacherRelationWhereUniqueInput
    create: XOR<StudentTeacherRelationCreateWithoutTeacherInput, StudentTeacherRelationUncheckedCreateWithoutTeacherInput>
  }

  export type StudentTeacherRelationCreateManyTeacherInputEnvelope = {
    data: StudentTeacherRelationCreateManyTeacherInput | StudentTeacherRelationCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomCreateWithoutTeacherInput = {
    id?: string
    name: string
    year: number
    students?: StudentProfileCreateNestedManyWithoutClassroomsInput
    schedule?: ScheduleItemCreateNestedManyWithoutClassroomInput
    lessons?: LessonCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutTeacherInput = {
    id?: string
    name: string
    year: number
    students?: StudentProfileUncheckedCreateNestedManyWithoutClassroomsInput
    schedule?: ScheduleItemUncheckedCreateNestedManyWithoutClassroomInput
    lessons?: LessonUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutTeacherInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutTeacherInput, ClassroomUncheckedCreateWithoutTeacherInput>
  }

  export type ClassroomCreateManyTeacherInputEnvelope = {
    data: ClassroomCreateManyTeacherInput | ClassroomCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutTeacherInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduleItem?: ScheduleItemCreateNestedOneWithoutLessonsInput
    students?: StudentProfileCreateNestedManyWithoutLessonsInput
    classroom?: ClassroomCreateNestedOneWithoutLessonsInput
    attendances?: AttendanceCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkCreateNestedManyWithoutLessonInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
    payments?: PaymentCreateNestedManyWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutTeacherInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    scheduleItemId?: string | null
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentProfileUncheckedCreateNestedManyWithoutLessonsInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkUncheckedCreateNestedManyWithoutLessonInput
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLessonsInput
  }

  export type LessonCreateOrConnectWithoutTeacherInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutTeacherInput, LessonUncheckedCreateWithoutTeacherInput>
  }

  export type LessonCreateManyTeacherInputEnvelope = {
    data: LessonCreateManyTeacherInput | LessonCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutTeacherInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    type: $Enums.PaymentType
    note?: string | null
    isVisibleToStudent?: boolean
    student: StudentProfileCreateNestedOneWithoutPaymentsInput
    lessons?: LessonCreateNestedManyWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutTeacherInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    type: $Enums.PaymentType
    note?: string | null
    isVisibleToStudent?: boolean
    studentId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutPaymentsInput
  }

  export type PaymentCreateOrConnectWithoutTeacherInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutTeacherInput, PaymentUncheckedCreateWithoutTeacherInput>
  }

  export type PaymentCreateManyTeacherInputEnvelope = {
    data: PaymentCreateManyTeacherInput | PaymentCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type ScheduleItemCreateWithoutTeacherInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    classroom?: ClassroomCreateNestedOneWithoutScheduleInput
    student?: StudentProfileCreateNestedOneWithoutRecurringSchedulesInput
    lessons?: LessonCreateNestedManyWithoutScheduleItemInput
  }

  export type ScheduleItemUncheckedCreateWithoutTeacherInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    classroomId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonUncheckedCreateNestedManyWithoutScheduleItemInput
  }

  export type ScheduleItemCreateOrConnectWithoutTeacherInput = {
    where: ScheduleItemWhereUniqueInput
    create: XOR<ScheduleItemCreateWithoutTeacherInput, ScheduleItemUncheckedCreateWithoutTeacherInput>
  }

  export type ScheduleItemCreateManyTeacherInputEnvelope = {
    data: ScheduleItemCreateManyTeacherInput | ScheduleItemCreateManyTeacherInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutTeacherProfileInput = {
    update: XOR<UserUpdateWithoutTeacherProfileInput, UserUncheckedUpdateWithoutTeacherProfileInput>
    create: XOR<UserCreateWithoutTeacherProfileInput, UserUncheckedCreateWithoutTeacherProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeacherProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeacherProfileInput, UserUncheckedUpdateWithoutTeacherProfileInput>
  }

  export type UserUpdateWithoutTeacherProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutTeacherProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type StudentTeacherRelationUpsertWithWhereUniqueWithoutTeacherInput = {
    where: StudentTeacherRelationWhereUniqueInput
    update: XOR<StudentTeacherRelationUpdateWithoutTeacherInput, StudentTeacherRelationUncheckedUpdateWithoutTeacherInput>
    create: XOR<StudentTeacherRelationCreateWithoutTeacherInput, StudentTeacherRelationUncheckedCreateWithoutTeacherInput>
  }

  export type StudentTeacherRelationUpdateWithWhereUniqueWithoutTeacherInput = {
    where: StudentTeacherRelationWhereUniqueInput
    data: XOR<StudentTeacherRelationUpdateWithoutTeacherInput, StudentTeacherRelationUncheckedUpdateWithoutTeacherInput>
  }

  export type StudentTeacherRelationUpdateManyWithWhereWithoutTeacherInput = {
    where: StudentTeacherRelationScalarWhereInput
    data: XOR<StudentTeacherRelationUpdateManyMutationInput, StudentTeacherRelationUncheckedUpdateManyWithoutTeacherInput>
  }

  export type StudentTeacherRelationScalarWhereInput = {
    AND?: StudentTeacherRelationScalarWhereInput | StudentTeacherRelationScalarWhereInput[]
    OR?: StudentTeacherRelationScalarWhereInput[]
    NOT?: StudentTeacherRelationScalarWhereInput | StudentTeacherRelationScalarWhereInput[]
    id?: StringFilter<"StudentTeacherRelation"> | string
    teacherId?: StringFilter<"StudentTeacherRelation"> | string
    studentId?: StringFilter<"StudentTeacherRelation"> | string
    status?: EnumRelationStatusFilter<"StudentTeacherRelation"> | $Enums.RelationStatus
    isCreator?: BoolFilter<"StudentTeacherRelation"> | boolean
    customName?: StringNullableFilter<"StudentTeacherRelation"> | string | null
    privateNotes?: StringNullableFilter<"StudentTeacherRelation"> | string | null
    createdAt?: DateTimeFilter<"StudentTeacherRelation"> | Date | string
    updatedAt?: DateTimeFilter<"StudentTeacherRelation"> | Date | string
  }

  export type ClassroomUpsertWithWhereUniqueWithoutTeacherInput = {
    where: ClassroomWhereUniqueInput
    update: XOR<ClassroomUpdateWithoutTeacherInput, ClassroomUncheckedUpdateWithoutTeacherInput>
    create: XOR<ClassroomCreateWithoutTeacherInput, ClassroomUncheckedCreateWithoutTeacherInput>
  }

  export type ClassroomUpdateWithWhereUniqueWithoutTeacherInput = {
    where: ClassroomWhereUniqueInput
    data: XOR<ClassroomUpdateWithoutTeacherInput, ClassroomUncheckedUpdateWithoutTeacherInput>
  }

  export type ClassroomUpdateManyWithWhereWithoutTeacherInput = {
    where: ClassroomScalarWhereInput
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyWithoutTeacherInput>
  }

  export type ClassroomScalarWhereInput = {
    AND?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
    OR?: ClassroomScalarWhereInput[]
    NOT?: ClassroomScalarWhereInput | ClassroomScalarWhereInput[]
    id?: StringFilter<"Classroom"> | string
    name?: StringFilter<"Classroom"> | string
    year?: IntFilter<"Classroom"> | number
    teacherId?: StringNullableFilter<"Classroom"> | string | null
  }

  export type LessonUpsertWithWhereUniqueWithoutTeacherInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutTeacherInput, LessonUncheckedUpdateWithoutTeacherInput>
    create: XOR<LessonCreateWithoutTeacherInput, LessonUncheckedCreateWithoutTeacherInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutTeacherInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutTeacherInput, LessonUncheckedUpdateWithoutTeacherInput>
  }

  export type LessonUpdateManyWithWhereWithoutTeacherInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutTeacherInput>
  }

  export type LessonScalarWhereInput = {
    AND?: LessonScalarWhereInput | LessonScalarWhereInput[]
    OR?: LessonScalarWhereInput[]
    NOT?: LessonScalarWhereInput | LessonScalarWhereInput[]
    id?: StringFilter<"Lesson"> | string
    title?: StringFilter<"Lesson"> | string
    startTime?: DateTimeFilter<"Lesson"> | Date | string
    endTime?: DateTimeFilter<"Lesson"> | Date | string
    scheduleItemId?: StringNullableFilter<"Lesson"> | string | null
    type?: EnumLessonTypeFilter<"Lesson"> | $Enums.LessonType
    status?: EnumLessonStatusFilter<"Lesson"> | $Enums.LessonStatus
    cancelReason?: StringNullableFilter<"Lesson"> | string | null
    location?: EnumLessonLocationFilter<"Lesson"> | $Enums.LessonLocation
    locationUrl?: StringNullableFilter<"Lesson"> | string | null
    address?: StringNullableFilter<"Lesson"> | string | null
    publicNote?: StringNullableFilter<"Lesson"> | string | null
    privateNote?: StringNullableFilter<"Lesson"> | string | null
    price?: DecimalNullableFilter<"Lesson"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Lesson"> | string
    isPaid?: BoolFilter<"Lesson"> | boolean
    teacherId?: StringFilter<"Lesson"> | string
    classroomId?: StringNullableFilter<"Lesson"> | string | null
    createdAt?: DateTimeFilter<"Lesson"> | Date | string
    updatedAt?: DateTimeFilter<"Lesson"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutTeacherInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutTeacherInput, PaymentUncheckedUpdateWithoutTeacherInput>
    create: XOR<PaymentCreateWithoutTeacherInput, PaymentUncheckedCreateWithoutTeacherInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutTeacherInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutTeacherInput, PaymentUncheckedUpdateWithoutTeacherInput>
  }

  export type PaymentUpdateManyWithWhereWithoutTeacherInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutTeacherInput>
  }

  export type PaymentScalarWhereInput = {
    AND?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    OR?: PaymentScalarWhereInput[]
    NOT?: PaymentScalarWhereInput | PaymentScalarWhereInput[]
    id?: StringFilter<"Payment"> | string
    amount?: DecimalFilter<"Payment"> | Decimal | DecimalJsLike | number | string
    date?: DateTimeFilter<"Payment"> | Date | string
    type?: EnumPaymentTypeFilter<"Payment"> | $Enums.PaymentType
    note?: StringNullableFilter<"Payment"> | string | null
    isVisibleToStudent?: BoolFilter<"Payment"> | boolean
    studentId?: StringFilter<"Payment"> | string
    teacherId?: StringFilter<"Payment"> | string
  }

  export type ScheduleItemUpsertWithWhereUniqueWithoutTeacherInput = {
    where: ScheduleItemWhereUniqueInput
    update: XOR<ScheduleItemUpdateWithoutTeacherInput, ScheduleItemUncheckedUpdateWithoutTeacherInput>
    create: XOR<ScheduleItemCreateWithoutTeacherInput, ScheduleItemUncheckedCreateWithoutTeacherInput>
  }

  export type ScheduleItemUpdateWithWhereUniqueWithoutTeacherInput = {
    where: ScheduleItemWhereUniqueInput
    data: XOR<ScheduleItemUpdateWithoutTeacherInput, ScheduleItemUncheckedUpdateWithoutTeacherInput>
  }

  export type ScheduleItemUpdateManyWithWhereWithoutTeacherInput = {
    where: ScheduleItemScalarWhereInput
    data: XOR<ScheduleItemUpdateManyMutationInput, ScheduleItemUncheckedUpdateManyWithoutTeacherInput>
  }

  export type ScheduleItemScalarWhereInput = {
    AND?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
    OR?: ScheduleItemScalarWhereInput[]
    NOT?: ScheduleItemScalarWhereInput | ScheduleItemScalarWhereInput[]
    id?: StringFilter<"ScheduleItem"> | string
    dayOfWeek?: IntFilter<"ScheduleItem"> | number
    startTime?: StringFilter<"ScheduleItem"> | string
    endTime?: StringFilter<"ScheduleItem"> | string
    subject?: StringNullableFilter<"ScheduleItem"> | string | null
    type?: EnumLessonTypeFilter<"ScheduleItem"> | $Enums.LessonType
    location?: EnumLessonLocationFilter<"ScheduleItem"> | $Enums.LessonLocation
    locationUrl?: StringNullableFilter<"ScheduleItem"> | string | null
    address?: StringNullableFilter<"ScheduleItem"> | string | null
    price?: DecimalNullableFilter<"ScheduleItem"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"ScheduleItem"> | string
    teacherId?: StringFilter<"ScheduleItem"> | string
    classroomId?: StringNullableFilter<"ScheduleItem"> | string | null
    studentId?: StringNullableFilter<"ScheduleItem"> | string | null
    createdAt?: DateTimeFilter<"ScheduleItem"> | Date | string
    updatedAt?: DateTimeFilter<"ScheduleItem"> | Date | string
  }

  export type UserCreateWithoutStudentProfileInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    todos?: TodoCreateNestedManyWithoutUserInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutStudentProfileInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutStudentProfileInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
  }

  export type StudentTeacherRelationCreateWithoutStudentInput = {
    id?: string
    status?: $Enums.RelationStatus
    isCreator?: boolean
    customName?: string | null
    privateNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherProfileCreateNestedOneWithoutStudentRelationsInput
  }

  export type StudentTeacherRelationUncheckedCreateWithoutStudentInput = {
    id?: string
    teacherId: string
    status?: $Enums.RelationStatus
    isCreator?: boolean
    customName?: string | null
    privateNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTeacherRelationCreateOrConnectWithoutStudentInput = {
    where: StudentTeacherRelationWhereUniqueInput
    create: XOR<StudentTeacherRelationCreateWithoutStudentInput, StudentTeacherRelationUncheckedCreateWithoutStudentInput>
  }

  export type StudentTeacherRelationCreateManyStudentInputEnvelope = {
    data: StudentTeacherRelationCreateManyStudentInput | StudentTeacherRelationCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type ClassroomCreateWithoutStudentsInput = {
    id?: string
    name: string
    year: number
    teacher?: TeacherProfileCreateNestedOneWithoutClassesInput
    schedule?: ScheduleItemCreateNestedManyWithoutClassroomInput
    lessons?: LessonCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutStudentsInput = {
    id?: string
    name: string
    year: number
    teacherId?: string | null
    schedule?: ScheduleItemUncheckedCreateNestedManyWithoutClassroomInput
    lessons?: LessonUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutStudentsInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutStudentsInput, ClassroomUncheckedCreateWithoutStudentsInput>
  }

  export type ScheduleItemCreateWithoutStudentInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherProfileCreateNestedOneWithoutScheduleItemsInput
    classroom?: ClassroomCreateNestedOneWithoutScheduleInput
    lessons?: LessonCreateNestedManyWithoutScheduleItemInput
  }

  export type ScheduleItemUncheckedCreateWithoutStudentInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    teacherId: string
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonUncheckedCreateNestedManyWithoutScheduleItemInput
  }

  export type ScheduleItemCreateOrConnectWithoutStudentInput = {
    where: ScheduleItemWhereUniqueInput
    create: XOR<ScheduleItemCreateWithoutStudentInput, ScheduleItemUncheckedCreateWithoutStudentInput>
  }

  export type ScheduleItemCreateManyStudentInputEnvelope = {
    data: ScheduleItemCreateManyStudentInput | ScheduleItemCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutStudentsInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduleItem?: ScheduleItemCreateNestedOneWithoutLessonsInput
    teacher: TeacherProfileCreateNestedOneWithoutLessonsInput
    classroom?: ClassroomCreateNestedOneWithoutLessonsInput
    attendances?: AttendanceCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkCreateNestedManyWithoutLessonInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
    payments?: PaymentCreateNestedManyWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutStudentsInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    scheduleItemId?: string | null
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    teacherId: string
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    attendances?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkUncheckedCreateNestedManyWithoutLessonInput
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLessonsInput
  }

  export type LessonCreateOrConnectWithoutStudentsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutStudentsInput, LessonUncheckedCreateWithoutStudentsInput>
  }

  export type HomeworkTrackingCreateWithoutStudentInput = {
    id?: string
    status?: $Enums.HomeworkStatus
    studentNote?: string | null
    teacherNote?: string | null
    checkedAt?: Date | string | null
    file?: FileCreateNestedOneWithoutHomeworkTrackingsInput
    homework: HomeworkCreateNestedOneWithoutTrackingsInput
  }

  export type HomeworkTrackingUncheckedCreateWithoutStudentInput = {
    id?: string
    homeworkId: string
    status?: $Enums.HomeworkStatus
    studentNote?: string | null
    teacherNote?: string | null
    fileId?: string | null
    checkedAt?: Date | string | null
  }

  export type HomeworkTrackingCreateOrConnectWithoutStudentInput = {
    where: HomeworkTrackingWhereUniqueInput
    create: XOR<HomeworkTrackingCreateWithoutStudentInput, HomeworkTrackingUncheckedCreateWithoutStudentInput>
  }

  export type HomeworkTrackingCreateManyStudentInputEnvelope = {
    data: HomeworkTrackingCreateManyStudentInput | HomeworkTrackingCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type HomeworkSubmissionCreateWithoutStudentInput = {
    id?: string
    note?: string | null
    submittedAt?: Date | string
    file?: FileCreateNestedOneWithoutHomeworkSubmissionsInput
  }

  export type HomeworkSubmissionUncheckedCreateWithoutStudentInput = {
    id?: string
    fileId?: string | null
    note?: string | null
    submittedAt?: Date | string
  }

  export type HomeworkSubmissionCreateOrConnectWithoutStudentInput = {
    where: HomeworkSubmissionWhereUniqueInput
    create: XOR<HomeworkSubmissionCreateWithoutStudentInput, HomeworkSubmissionUncheckedCreateWithoutStudentInput>
  }

  export type HomeworkSubmissionCreateManyStudentInputEnvelope = {
    data: HomeworkSubmissionCreateManyStudentInput | HomeworkSubmissionCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutStudentInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    type: $Enums.PaymentType
    note?: string | null
    isVisibleToStudent?: boolean
    teacher: TeacherProfileCreateNestedOneWithoutPaymentsInput
    lessons?: LessonCreateNestedManyWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutStudentInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    type: $Enums.PaymentType
    note?: string | null
    isVisibleToStudent?: boolean
    teacherId: string
    lessons?: LessonUncheckedCreateNestedManyWithoutPaymentsInput
  }

  export type PaymentCreateOrConnectWithoutStudentInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutStudentInput, PaymentUncheckedCreateWithoutStudentInput>
  }

  export type PaymentCreateManyStudentInputEnvelope = {
    data: PaymentCreateManyStudentInput | PaymentCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type SchoolExamCreateWithoutStudentInput = {
    id?: string
    title: string
    score: number
    date: Date | string
    subject: string
  }

  export type SchoolExamUncheckedCreateWithoutStudentInput = {
    id?: string
    title: string
    score: number
    date: Date | string
    subject: string
  }

  export type SchoolExamCreateOrConnectWithoutStudentInput = {
    where: SchoolExamWhereUniqueInput
    create: XOR<SchoolExamCreateWithoutStudentInput, SchoolExamUncheckedCreateWithoutStudentInput>
  }

  export type SchoolExamCreateManyStudentInputEnvelope = {
    data: SchoolExamCreateManyStudentInput | SchoolExamCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type TrialExamCreateWithoutStudentInput = {
    id?: string
    title: string
    date: Date | string
    category: $Enums.ExamCategory
    publisher?: string | null
    totalNet?: number | null
    totalScore?: number | null
    results?: TrialExamResultCreateNestedManyWithoutTrialExamInput
  }

  export type TrialExamUncheckedCreateWithoutStudentInput = {
    id?: string
    title: string
    date: Date | string
    category: $Enums.ExamCategory
    publisher?: string | null
    totalNet?: number | null
    totalScore?: number | null
    results?: TrialExamResultUncheckedCreateNestedManyWithoutTrialExamInput
  }

  export type TrialExamCreateOrConnectWithoutStudentInput = {
    where: TrialExamWhereUniqueInput
    create: XOR<TrialExamCreateWithoutStudentInput, TrialExamUncheckedCreateWithoutStudentInput>
  }

  export type TrialExamCreateManyStudentInputEnvelope = {
    data: TrialExamCreateManyStudentInput | TrialExamCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceCreateWithoutStudentInput = {
    id?: string
    status: $Enums.AttendanceStatus
    note?: string | null
    lesson: LessonCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutStudentInput = {
    id?: string
    lessonId: string
    status: $Enums.AttendanceStatus
    note?: string | null
  }

  export type AttendanceCreateOrConnectWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceCreateManyStudentInputEnvelope = {
    data: AttendanceCreateManyStudentInput | AttendanceCreateManyStudentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutStudentProfileInput = {
    update: XOR<UserUpdateWithoutStudentProfileInput, UserUncheckedUpdateWithoutStudentProfileInput>
    create: XOR<UserCreateWithoutStudentProfileInput, UserUncheckedCreateWithoutStudentProfileInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutStudentProfileInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutStudentProfileInput, UserUncheckedUpdateWithoutStudentProfileInput>
  }

  export type UserUpdateWithoutStudentProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutStudentProfileInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type StudentTeacherRelationUpsertWithWhereUniqueWithoutStudentInput = {
    where: StudentTeacherRelationWhereUniqueInput
    update: XOR<StudentTeacherRelationUpdateWithoutStudentInput, StudentTeacherRelationUncheckedUpdateWithoutStudentInput>
    create: XOR<StudentTeacherRelationCreateWithoutStudentInput, StudentTeacherRelationUncheckedCreateWithoutStudentInput>
  }

  export type StudentTeacherRelationUpdateWithWhereUniqueWithoutStudentInput = {
    where: StudentTeacherRelationWhereUniqueInput
    data: XOR<StudentTeacherRelationUpdateWithoutStudentInput, StudentTeacherRelationUncheckedUpdateWithoutStudentInput>
  }

  export type StudentTeacherRelationUpdateManyWithWhereWithoutStudentInput = {
    where: StudentTeacherRelationScalarWhereInput
    data: XOR<StudentTeacherRelationUpdateManyMutationInput, StudentTeacherRelationUncheckedUpdateManyWithoutStudentInput>
  }

  export type ClassroomUpsertWithWhereUniqueWithoutStudentsInput = {
    where: ClassroomWhereUniqueInput
    update: XOR<ClassroomUpdateWithoutStudentsInput, ClassroomUncheckedUpdateWithoutStudentsInput>
    create: XOR<ClassroomCreateWithoutStudentsInput, ClassroomUncheckedCreateWithoutStudentsInput>
  }

  export type ClassroomUpdateWithWhereUniqueWithoutStudentsInput = {
    where: ClassroomWhereUniqueInput
    data: XOR<ClassroomUpdateWithoutStudentsInput, ClassroomUncheckedUpdateWithoutStudentsInput>
  }

  export type ClassroomUpdateManyWithWhereWithoutStudentsInput = {
    where: ClassroomScalarWhereInput
    data: XOR<ClassroomUpdateManyMutationInput, ClassroomUncheckedUpdateManyWithoutStudentsInput>
  }

  export type ScheduleItemUpsertWithWhereUniqueWithoutStudentInput = {
    where: ScheduleItemWhereUniqueInput
    update: XOR<ScheduleItemUpdateWithoutStudentInput, ScheduleItemUncheckedUpdateWithoutStudentInput>
    create: XOR<ScheduleItemCreateWithoutStudentInput, ScheduleItemUncheckedCreateWithoutStudentInput>
  }

  export type ScheduleItemUpdateWithWhereUniqueWithoutStudentInput = {
    where: ScheduleItemWhereUniqueInput
    data: XOR<ScheduleItemUpdateWithoutStudentInput, ScheduleItemUncheckedUpdateWithoutStudentInput>
  }

  export type ScheduleItemUpdateManyWithWhereWithoutStudentInput = {
    where: ScheduleItemScalarWhereInput
    data: XOR<ScheduleItemUpdateManyMutationInput, ScheduleItemUncheckedUpdateManyWithoutStudentInput>
  }

  export type LessonUpsertWithWhereUniqueWithoutStudentsInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutStudentsInput, LessonUncheckedUpdateWithoutStudentsInput>
    create: XOR<LessonCreateWithoutStudentsInput, LessonUncheckedCreateWithoutStudentsInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutStudentsInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutStudentsInput, LessonUncheckedUpdateWithoutStudentsInput>
  }

  export type LessonUpdateManyWithWhereWithoutStudentsInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutStudentsInput>
  }

  export type HomeworkTrackingUpsertWithWhereUniqueWithoutStudentInput = {
    where: HomeworkTrackingWhereUniqueInput
    update: XOR<HomeworkTrackingUpdateWithoutStudentInput, HomeworkTrackingUncheckedUpdateWithoutStudentInput>
    create: XOR<HomeworkTrackingCreateWithoutStudentInput, HomeworkTrackingUncheckedCreateWithoutStudentInput>
  }

  export type HomeworkTrackingUpdateWithWhereUniqueWithoutStudentInput = {
    where: HomeworkTrackingWhereUniqueInput
    data: XOR<HomeworkTrackingUpdateWithoutStudentInput, HomeworkTrackingUncheckedUpdateWithoutStudentInput>
  }

  export type HomeworkTrackingUpdateManyWithWhereWithoutStudentInput = {
    where: HomeworkTrackingScalarWhereInput
    data: XOR<HomeworkTrackingUpdateManyMutationInput, HomeworkTrackingUncheckedUpdateManyWithoutStudentInput>
  }

  export type HomeworkTrackingScalarWhereInput = {
    AND?: HomeworkTrackingScalarWhereInput | HomeworkTrackingScalarWhereInput[]
    OR?: HomeworkTrackingScalarWhereInput[]
    NOT?: HomeworkTrackingScalarWhereInput | HomeworkTrackingScalarWhereInput[]
    id?: StringFilter<"HomeworkTracking"> | string
    homeworkId?: StringFilter<"HomeworkTracking"> | string
    studentId?: StringFilter<"HomeworkTracking"> | string
    status?: EnumHomeworkStatusFilter<"HomeworkTracking"> | $Enums.HomeworkStatus
    studentNote?: StringNullableFilter<"HomeworkTracking"> | string | null
    teacherNote?: StringNullableFilter<"HomeworkTracking"> | string | null
    fileId?: StringNullableFilter<"HomeworkTracking"> | string | null
    checkedAt?: DateTimeNullableFilter<"HomeworkTracking"> | Date | string | null
  }

  export type HomeworkSubmissionUpsertWithWhereUniqueWithoutStudentInput = {
    where: HomeworkSubmissionWhereUniqueInput
    update: XOR<HomeworkSubmissionUpdateWithoutStudentInput, HomeworkSubmissionUncheckedUpdateWithoutStudentInput>
    create: XOR<HomeworkSubmissionCreateWithoutStudentInput, HomeworkSubmissionUncheckedCreateWithoutStudentInput>
  }

  export type HomeworkSubmissionUpdateWithWhereUniqueWithoutStudentInput = {
    where: HomeworkSubmissionWhereUniqueInput
    data: XOR<HomeworkSubmissionUpdateWithoutStudentInput, HomeworkSubmissionUncheckedUpdateWithoutStudentInput>
  }

  export type HomeworkSubmissionUpdateManyWithWhereWithoutStudentInput = {
    where: HomeworkSubmissionScalarWhereInput
    data: XOR<HomeworkSubmissionUpdateManyMutationInput, HomeworkSubmissionUncheckedUpdateManyWithoutStudentInput>
  }

  export type HomeworkSubmissionScalarWhereInput = {
    AND?: HomeworkSubmissionScalarWhereInput | HomeworkSubmissionScalarWhereInput[]
    OR?: HomeworkSubmissionScalarWhereInput[]
    NOT?: HomeworkSubmissionScalarWhereInput | HomeworkSubmissionScalarWhereInput[]
    id?: StringFilter<"HomeworkSubmission"> | string
    fileId?: StringNullableFilter<"HomeworkSubmission"> | string | null
    note?: StringNullableFilter<"HomeworkSubmission"> | string | null
    submittedAt?: DateTimeFilter<"HomeworkSubmission"> | Date | string
    studentId?: StringFilter<"HomeworkSubmission"> | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutStudentInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutStudentInput, PaymentUncheckedUpdateWithoutStudentInput>
    create: XOR<PaymentCreateWithoutStudentInput, PaymentUncheckedCreateWithoutStudentInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutStudentInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutStudentInput, PaymentUncheckedUpdateWithoutStudentInput>
  }

  export type PaymentUpdateManyWithWhereWithoutStudentInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutStudentInput>
  }

  export type SchoolExamUpsertWithWhereUniqueWithoutStudentInput = {
    where: SchoolExamWhereUniqueInput
    update: XOR<SchoolExamUpdateWithoutStudentInput, SchoolExamUncheckedUpdateWithoutStudentInput>
    create: XOR<SchoolExamCreateWithoutStudentInput, SchoolExamUncheckedCreateWithoutStudentInput>
  }

  export type SchoolExamUpdateWithWhereUniqueWithoutStudentInput = {
    where: SchoolExamWhereUniqueInput
    data: XOR<SchoolExamUpdateWithoutStudentInput, SchoolExamUncheckedUpdateWithoutStudentInput>
  }

  export type SchoolExamUpdateManyWithWhereWithoutStudentInput = {
    where: SchoolExamScalarWhereInput
    data: XOR<SchoolExamUpdateManyMutationInput, SchoolExamUncheckedUpdateManyWithoutStudentInput>
  }

  export type SchoolExamScalarWhereInput = {
    AND?: SchoolExamScalarWhereInput | SchoolExamScalarWhereInput[]
    OR?: SchoolExamScalarWhereInput[]
    NOT?: SchoolExamScalarWhereInput | SchoolExamScalarWhereInput[]
    id?: StringFilter<"SchoolExam"> | string
    title?: StringFilter<"SchoolExam"> | string
    score?: FloatFilter<"SchoolExam"> | number
    date?: DateTimeFilter<"SchoolExam"> | Date | string
    subject?: StringFilter<"SchoolExam"> | string
    studentId?: StringFilter<"SchoolExam"> | string
  }

  export type TrialExamUpsertWithWhereUniqueWithoutStudentInput = {
    where: TrialExamWhereUniqueInput
    update: XOR<TrialExamUpdateWithoutStudentInput, TrialExamUncheckedUpdateWithoutStudentInput>
    create: XOR<TrialExamCreateWithoutStudentInput, TrialExamUncheckedCreateWithoutStudentInput>
  }

  export type TrialExamUpdateWithWhereUniqueWithoutStudentInput = {
    where: TrialExamWhereUniqueInput
    data: XOR<TrialExamUpdateWithoutStudentInput, TrialExamUncheckedUpdateWithoutStudentInput>
  }

  export type TrialExamUpdateManyWithWhereWithoutStudentInput = {
    where: TrialExamScalarWhereInput
    data: XOR<TrialExamUpdateManyMutationInput, TrialExamUncheckedUpdateManyWithoutStudentInput>
  }

  export type TrialExamScalarWhereInput = {
    AND?: TrialExamScalarWhereInput | TrialExamScalarWhereInput[]
    OR?: TrialExamScalarWhereInput[]
    NOT?: TrialExamScalarWhereInput | TrialExamScalarWhereInput[]
    id?: StringFilter<"TrialExam"> | string
    title?: StringFilter<"TrialExam"> | string
    date?: DateTimeFilter<"TrialExam"> | Date | string
    category?: EnumExamCategoryFilter<"TrialExam"> | $Enums.ExamCategory
    publisher?: StringNullableFilter<"TrialExam"> | string | null
    studentId?: StringFilter<"TrialExam"> | string
    totalNet?: FloatNullableFilter<"TrialExam"> | number | null
    totalScore?: FloatNullableFilter<"TrialExam"> | number | null
  }

  export type AttendanceUpsertWithWhereUniqueWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutStudentInput, AttendanceUncheckedUpdateWithoutStudentInput>
    create: XOR<AttendanceCreateWithoutStudentInput, AttendanceUncheckedCreateWithoutStudentInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutStudentInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutStudentInput, AttendanceUncheckedUpdateWithoutStudentInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutStudentInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutStudentInput>
  }

  export type AttendanceScalarWhereInput = {
    AND?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    OR?: AttendanceScalarWhereInput[]
    NOT?: AttendanceScalarWhereInput | AttendanceScalarWhereInput[]
    id?: StringFilter<"Attendance"> | string
    lessonId?: StringFilter<"Attendance"> | string
    studentId?: StringFilter<"Attendance"> | string
    status?: EnumAttendanceStatusFilter<"Attendance"> | $Enums.AttendanceStatus
    note?: StringNullableFilter<"Attendance"> | string | null
  }

  export type TeacherProfileCreateWithoutStudentRelationsInput = {
    id?: string
    branch: string
    bio?: string | null
    user: UserCreateNestedOneWithoutTeacherProfileInput
    classes?: ClassroomCreateNestedManyWithoutTeacherInput
    lessons?: LessonCreateNestedManyWithoutTeacherInput
    payments?: PaymentCreateNestedManyWithoutTeacherInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileUncheckedCreateWithoutStudentRelationsInput = {
    id?: string
    userId: string
    branch: string
    bio?: string | null
    classes?: ClassroomUncheckedCreateNestedManyWithoutTeacherInput
    lessons?: LessonUncheckedCreateNestedManyWithoutTeacherInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTeacherInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileCreateOrConnectWithoutStudentRelationsInput = {
    where: TeacherProfileWhereUniqueInput
    create: XOR<TeacherProfileCreateWithoutStudentRelationsInput, TeacherProfileUncheckedCreateWithoutStudentRelationsInput>
  }

  export type StudentProfileCreateWithoutTeacherRelationsInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    classrooms?: ClassroomCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemCreateNestedManyWithoutStudentInput
    lessons?: LessonCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutStudentInput
    grades?: SchoolExamCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUncheckedCreateWithoutTeacherRelationsInput = {
    id?: string
    userId?: string | null
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemUncheckedCreateNestedManyWithoutStudentInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentInput
    grades?: SchoolExamUncheckedCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileCreateOrConnectWithoutTeacherRelationsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutTeacherRelationsInput, StudentProfileUncheckedCreateWithoutTeacherRelationsInput>
  }

  export type TeacherProfileUpsertWithoutStudentRelationsInput = {
    update: XOR<TeacherProfileUpdateWithoutStudentRelationsInput, TeacherProfileUncheckedUpdateWithoutStudentRelationsInput>
    create: XOR<TeacherProfileCreateWithoutStudentRelationsInput, TeacherProfileUncheckedCreateWithoutStudentRelationsInput>
    where?: TeacherProfileWhereInput
  }

  export type TeacherProfileUpdateToOneWithWhereWithoutStudentRelationsInput = {
    where?: TeacherProfileWhereInput
    data: XOR<TeacherProfileUpdateWithoutStudentRelationsInput, TeacherProfileUncheckedUpdateWithoutStudentRelationsInput>
  }

  export type TeacherProfileUpdateWithoutStudentRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherProfileNestedInput
    classes?: ClassroomUpdateManyWithoutTeacherNestedInput
    lessons?: LessonUpdateManyWithoutTeacherNestedInput
    payments?: PaymentUpdateManyWithoutTeacherNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherProfileUncheckedUpdateWithoutStudentRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    classes?: ClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutTeacherNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTeacherNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type StudentProfileUpsertWithoutTeacherRelationsInput = {
    update: XOR<StudentProfileUpdateWithoutTeacherRelationsInput, StudentProfileUncheckedUpdateWithoutTeacherRelationsInput>
    create: XOR<StudentProfileCreateWithoutTeacherRelationsInput, StudentProfileUncheckedCreateWithoutTeacherRelationsInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutTeacherRelationsInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutTeacherRelationsInput, StudentProfileUncheckedUpdateWithoutTeacherRelationsInput>
  }

  export type StudentProfileUpdateWithoutTeacherRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    classrooms?: ClassroomUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUpdateManyWithoutStudentNestedInput
    lessons?: LessonUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutTeacherRelationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classrooms?: ClassroomUncheckedUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUncheckedUpdateManyWithoutStudentNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUncheckedUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherProfileCreateWithoutClassesInput = {
    id?: string
    branch: string
    bio?: string | null
    user: UserCreateNestedOneWithoutTeacherProfileInput
    studentRelations?: StudentTeacherRelationCreateNestedManyWithoutTeacherInput
    lessons?: LessonCreateNestedManyWithoutTeacherInput
    payments?: PaymentCreateNestedManyWithoutTeacherInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileUncheckedCreateWithoutClassesInput = {
    id?: string
    userId: string
    branch: string
    bio?: string | null
    studentRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutTeacherInput
    lessons?: LessonUncheckedCreateNestedManyWithoutTeacherInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTeacherInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileCreateOrConnectWithoutClassesInput = {
    where: TeacherProfileWhereUniqueInput
    create: XOR<TeacherProfileCreateWithoutClassesInput, TeacherProfileUncheckedCreateWithoutClassesInput>
  }

  export type StudentProfileCreateWithoutClassroomsInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    teacherRelations?: StudentTeacherRelationCreateNestedManyWithoutStudentInput
    recurringSchedules?: ScheduleItemCreateNestedManyWithoutStudentInput
    lessons?: LessonCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutStudentInput
    grades?: SchoolExamCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUncheckedCreateWithoutClassroomsInput = {
    id?: string
    userId?: string | null
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutStudentInput
    recurringSchedules?: ScheduleItemUncheckedCreateNestedManyWithoutStudentInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentInput
    grades?: SchoolExamUncheckedCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileCreateOrConnectWithoutClassroomsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutClassroomsInput, StudentProfileUncheckedCreateWithoutClassroomsInput>
  }

  export type ScheduleItemCreateWithoutClassroomInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherProfileCreateNestedOneWithoutScheduleItemsInput
    student?: StudentProfileCreateNestedOneWithoutRecurringSchedulesInput
    lessons?: LessonCreateNestedManyWithoutScheduleItemInput
  }

  export type ScheduleItemUncheckedCreateWithoutClassroomInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    teacherId: string
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    lessons?: LessonUncheckedCreateNestedManyWithoutScheduleItemInput
  }

  export type ScheduleItemCreateOrConnectWithoutClassroomInput = {
    where: ScheduleItemWhereUniqueInput
    create: XOR<ScheduleItemCreateWithoutClassroomInput, ScheduleItemUncheckedCreateWithoutClassroomInput>
  }

  export type ScheduleItemCreateManyClassroomInputEnvelope = {
    data: ScheduleItemCreateManyClassroomInput | ScheduleItemCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type LessonCreateWithoutClassroomInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduleItem?: ScheduleItemCreateNestedOneWithoutLessonsInput
    teacher: TeacherProfileCreateNestedOneWithoutLessonsInput
    students?: StudentProfileCreateNestedManyWithoutLessonsInput
    attendances?: AttendanceCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkCreateNestedManyWithoutLessonInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
    payments?: PaymentCreateNestedManyWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutClassroomInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    scheduleItemId?: string | null
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    teacherId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentProfileUncheckedCreateNestedManyWithoutLessonsInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkUncheckedCreateNestedManyWithoutLessonInput
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLessonsInput
  }

  export type LessonCreateOrConnectWithoutClassroomInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutClassroomInput, LessonUncheckedCreateWithoutClassroomInput>
  }

  export type LessonCreateManyClassroomInputEnvelope = {
    data: LessonCreateManyClassroomInput | LessonCreateManyClassroomInput[]
    skipDuplicates?: boolean
  }

  export type TeacherProfileUpsertWithoutClassesInput = {
    update: XOR<TeacherProfileUpdateWithoutClassesInput, TeacherProfileUncheckedUpdateWithoutClassesInput>
    create: XOR<TeacherProfileCreateWithoutClassesInput, TeacherProfileUncheckedCreateWithoutClassesInput>
    where?: TeacherProfileWhereInput
  }

  export type TeacherProfileUpdateToOneWithWhereWithoutClassesInput = {
    where?: TeacherProfileWhereInput
    data: XOR<TeacherProfileUpdateWithoutClassesInput, TeacherProfileUncheckedUpdateWithoutClassesInput>
  }

  export type TeacherProfileUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherProfileNestedInput
    studentRelations?: StudentTeacherRelationUpdateManyWithoutTeacherNestedInput
    lessons?: LessonUpdateManyWithoutTeacherNestedInput
    payments?: PaymentUpdateManyWithoutTeacherNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherProfileUncheckedUpdateWithoutClassesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    studentRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutTeacherNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutTeacherNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTeacherNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type StudentProfileUpsertWithWhereUniqueWithoutClassroomsInput = {
    where: StudentProfileWhereUniqueInput
    update: XOR<StudentProfileUpdateWithoutClassroomsInput, StudentProfileUncheckedUpdateWithoutClassroomsInput>
    create: XOR<StudentProfileCreateWithoutClassroomsInput, StudentProfileUncheckedCreateWithoutClassroomsInput>
  }

  export type StudentProfileUpdateWithWhereUniqueWithoutClassroomsInput = {
    where: StudentProfileWhereUniqueInput
    data: XOR<StudentProfileUpdateWithoutClassroomsInput, StudentProfileUncheckedUpdateWithoutClassroomsInput>
  }

  export type StudentProfileUpdateManyWithWhereWithoutClassroomsInput = {
    where: StudentProfileScalarWhereInput
    data: XOR<StudentProfileUpdateManyMutationInput, StudentProfileUncheckedUpdateManyWithoutClassroomsInput>
  }

  export type StudentProfileScalarWhereInput = {
    AND?: StudentProfileScalarWhereInput | StudentProfileScalarWhereInput[]
    OR?: StudentProfileScalarWhereInput[]
    NOT?: StudentProfileScalarWhereInput | StudentProfileScalarWhereInput[]
    id?: StringFilter<"StudentProfile"> | string
    userId?: StringNullableFilter<"StudentProfile"> | string | null
    tempFirstName?: StringNullableFilter<"StudentProfile"> | string | null
    tempLastName?: StringNullableFilter<"StudentProfile"> | string | null
    tempPhone?: StringNullableFilter<"StudentProfile"> | string | null
    tempEmail?: StringNullableFilter<"StudentProfile"> | string | null
    tempAvatarKey?: StringNullableFilter<"StudentProfile"> | string | null
    inviteToken?: StringNullableFilter<"StudentProfile"> | string | null
    inviteTokenExpires?: DateTimeNullableFilter<"StudentProfile"> | Date | string | null
    isClaimed?: BoolFilter<"StudentProfile"> | boolean
    creatorTeacherId?: StringNullableFilter<"StudentProfile"> | string | null
    studentNo?: StringNullableFilter<"StudentProfile"> | string | null
    gradeLevel?: StringNullableFilter<"StudentProfile"> | string | null
    parentName?: StringNullableFilter<"StudentProfile"> | string | null
    parentPhone?: StringNullableFilter<"StudentProfile"> | string | null
    parentEmail?: StringNullableFilter<"StudentProfile"> | string | null
    createdAt?: DateTimeFilter<"StudentProfile"> | Date | string
    updatedAt?: DateTimeFilter<"StudentProfile"> | Date | string
  }

  export type ScheduleItemUpsertWithWhereUniqueWithoutClassroomInput = {
    where: ScheduleItemWhereUniqueInput
    update: XOR<ScheduleItemUpdateWithoutClassroomInput, ScheduleItemUncheckedUpdateWithoutClassroomInput>
    create: XOR<ScheduleItemCreateWithoutClassroomInput, ScheduleItemUncheckedCreateWithoutClassroomInput>
  }

  export type ScheduleItemUpdateWithWhereUniqueWithoutClassroomInput = {
    where: ScheduleItemWhereUniqueInput
    data: XOR<ScheduleItemUpdateWithoutClassroomInput, ScheduleItemUncheckedUpdateWithoutClassroomInput>
  }

  export type ScheduleItemUpdateManyWithWhereWithoutClassroomInput = {
    where: ScheduleItemScalarWhereInput
    data: XOR<ScheduleItemUpdateManyMutationInput, ScheduleItemUncheckedUpdateManyWithoutClassroomInput>
  }

  export type LessonUpsertWithWhereUniqueWithoutClassroomInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutClassroomInput, LessonUncheckedUpdateWithoutClassroomInput>
    create: XOR<LessonCreateWithoutClassroomInput, LessonUncheckedCreateWithoutClassroomInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutClassroomInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutClassroomInput, LessonUncheckedUpdateWithoutClassroomInput>
  }

  export type LessonUpdateManyWithWhereWithoutClassroomInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutClassroomInput>
  }

  export type TeacherProfileCreateWithoutScheduleItemsInput = {
    id?: string
    branch: string
    bio?: string | null
    user: UserCreateNestedOneWithoutTeacherProfileInput
    studentRelations?: StudentTeacherRelationCreateNestedManyWithoutTeacherInput
    classes?: ClassroomCreateNestedManyWithoutTeacherInput
    lessons?: LessonCreateNestedManyWithoutTeacherInput
    payments?: PaymentCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileUncheckedCreateWithoutScheduleItemsInput = {
    id?: string
    userId: string
    branch: string
    bio?: string | null
    studentRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutTeacherInput
    classes?: ClassroomUncheckedCreateNestedManyWithoutTeacherInput
    lessons?: LessonUncheckedCreateNestedManyWithoutTeacherInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileCreateOrConnectWithoutScheduleItemsInput = {
    where: TeacherProfileWhereUniqueInput
    create: XOR<TeacherProfileCreateWithoutScheduleItemsInput, TeacherProfileUncheckedCreateWithoutScheduleItemsInput>
  }

  export type ClassroomCreateWithoutScheduleInput = {
    id?: string
    name: string
    year: number
    teacher?: TeacherProfileCreateNestedOneWithoutClassesInput
    students?: StudentProfileCreateNestedManyWithoutClassroomsInput
    lessons?: LessonCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutScheduleInput = {
    id?: string
    name: string
    year: number
    teacherId?: string | null
    students?: StudentProfileUncheckedCreateNestedManyWithoutClassroomsInput
    lessons?: LessonUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutScheduleInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutScheduleInput, ClassroomUncheckedCreateWithoutScheduleInput>
  }

  export type StudentProfileCreateWithoutRecurringSchedulesInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    teacherRelations?: StudentTeacherRelationCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomCreateNestedManyWithoutStudentsInput
    lessons?: LessonCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutStudentInput
    grades?: SchoolExamCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUncheckedCreateWithoutRecurringSchedulesInput = {
    id?: string
    userId?: string | null
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutStudentsInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentInput
    grades?: SchoolExamUncheckedCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileCreateOrConnectWithoutRecurringSchedulesInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutRecurringSchedulesInput, StudentProfileUncheckedCreateWithoutRecurringSchedulesInput>
  }

  export type LessonCreateWithoutScheduleItemInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherProfileCreateNestedOneWithoutLessonsInput
    students?: StudentProfileCreateNestedManyWithoutLessonsInput
    classroom?: ClassroomCreateNestedOneWithoutLessonsInput
    attendances?: AttendanceCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkCreateNestedManyWithoutLessonInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
    payments?: PaymentCreateNestedManyWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutScheduleItemInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    teacherId: string
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentProfileUncheckedCreateNestedManyWithoutLessonsInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkUncheckedCreateNestedManyWithoutLessonInput
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLessonsInput
  }

  export type LessonCreateOrConnectWithoutScheduleItemInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutScheduleItemInput, LessonUncheckedCreateWithoutScheduleItemInput>
  }

  export type LessonCreateManyScheduleItemInputEnvelope = {
    data: LessonCreateManyScheduleItemInput | LessonCreateManyScheduleItemInput[]
    skipDuplicates?: boolean
  }

  export type TeacherProfileUpsertWithoutScheduleItemsInput = {
    update: XOR<TeacherProfileUpdateWithoutScheduleItemsInput, TeacherProfileUncheckedUpdateWithoutScheduleItemsInput>
    create: XOR<TeacherProfileCreateWithoutScheduleItemsInput, TeacherProfileUncheckedCreateWithoutScheduleItemsInput>
    where?: TeacherProfileWhereInput
  }

  export type TeacherProfileUpdateToOneWithWhereWithoutScheduleItemsInput = {
    where?: TeacherProfileWhereInput
    data: XOR<TeacherProfileUpdateWithoutScheduleItemsInput, TeacherProfileUncheckedUpdateWithoutScheduleItemsInput>
  }

  export type TeacherProfileUpdateWithoutScheduleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherProfileNestedInput
    studentRelations?: StudentTeacherRelationUpdateManyWithoutTeacherNestedInput
    classes?: ClassroomUpdateManyWithoutTeacherNestedInput
    lessons?: LessonUpdateManyWithoutTeacherNestedInput
    payments?: PaymentUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherProfileUncheckedUpdateWithoutScheduleItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    studentRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: ClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutTeacherNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type ClassroomUpsertWithoutScheduleInput = {
    update: XOR<ClassroomUpdateWithoutScheduleInput, ClassroomUncheckedUpdateWithoutScheduleInput>
    create: XOR<ClassroomCreateWithoutScheduleInput, ClassroomUncheckedCreateWithoutScheduleInput>
    where?: ClassroomWhereInput
  }

  export type ClassroomUpdateToOneWithWhereWithoutScheduleInput = {
    where?: ClassroomWhereInput
    data: XOR<ClassroomUpdateWithoutScheduleInput, ClassroomUncheckedUpdateWithoutScheduleInput>
  }

  export type ClassroomUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    teacher?: TeacherProfileUpdateOneWithoutClassesNestedInput
    students?: StudentProfileUpdateManyWithoutClassroomsNestedInput
    lessons?: LessonUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutScheduleInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentProfileUncheckedUpdateManyWithoutClassroomsNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type StudentProfileUpsertWithoutRecurringSchedulesInput = {
    update: XOR<StudentProfileUpdateWithoutRecurringSchedulesInput, StudentProfileUncheckedUpdateWithoutRecurringSchedulesInput>
    create: XOR<StudentProfileCreateWithoutRecurringSchedulesInput, StudentProfileUncheckedCreateWithoutRecurringSchedulesInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutRecurringSchedulesInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutRecurringSchedulesInput, StudentProfileUncheckedUpdateWithoutRecurringSchedulesInput>
  }

  export type StudentProfileUpdateWithoutRecurringSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    teacherRelations?: StudentTeacherRelationUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUpdateManyWithoutStudentsNestedInput
    lessons?: LessonUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutRecurringSchedulesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutStudentsNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUncheckedUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type LessonUpsertWithWhereUniqueWithoutScheduleItemInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutScheduleItemInput, LessonUncheckedUpdateWithoutScheduleItemInput>
    create: XOR<LessonCreateWithoutScheduleItemInput, LessonUncheckedCreateWithoutScheduleItemInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutScheduleItemInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutScheduleItemInput, LessonUncheckedUpdateWithoutScheduleItemInput>
  }

  export type LessonUpdateManyWithWhereWithoutScheduleItemInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutScheduleItemInput>
  }

  export type ScheduleItemCreateWithoutLessonsInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    createdAt?: Date | string
    updatedAt?: Date | string
    teacher: TeacherProfileCreateNestedOneWithoutScheduleItemsInput
    classroom?: ClassroomCreateNestedOneWithoutScheduleInput
    student?: StudentProfileCreateNestedOneWithoutRecurringSchedulesInput
  }

  export type ScheduleItemUncheckedCreateWithoutLessonsInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    teacherId: string
    classroomId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleItemCreateOrConnectWithoutLessonsInput = {
    where: ScheduleItemWhereUniqueInput
    create: XOR<ScheduleItemCreateWithoutLessonsInput, ScheduleItemUncheckedCreateWithoutLessonsInput>
  }

  export type TeacherProfileCreateWithoutLessonsInput = {
    id?: string
    branch: string
    bio?: string | null
    user: UserCreateNestedOneWithoutTeacherProfileInput
    studentRelations?: StudentTeacherRelationCreateNestedManyWithoutTeacherInput
    classes?: ClassroomCreateNestedManyWithoutTeacherInput
    payments?: PaymentCreateNestedManyWithoutTeacherInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileUncheckedCreateWithoutLessonsInput = {
    id?: string
    userId: string
    branch: string
    bio?: string | null
    studentRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutTeacherInput
    classes?: ClassroomUncheckedCreateNestedManyWithoutTeacherInput
    payments?: PaymentUncheckedCreateNestedManyWithoutTeacherInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileCreateOrConnectWithoutLessonsInput = {
    where: TeacherProfileWhereUniqueInput
    create: XOR<TeacherProfileCreateWithoutLessonsInput, TeacherProfileUncheckedCreateWithoutLessonsInput>
  }

  export type StudentProfileCreateWithoutLessonsInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    teacherRelations?: StudentTeacherRelationCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemCreateNestedManyWithoutStudentInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutStudentInput
    grades?: SchoolExamCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUncheckedCreateWithoutLessonsInput = {
    id?: string
    userId?: string | null
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemUncheckedCreateNestedManyWithoutStudentInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentInput
    grades?: SchoolExamUncheckedCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileCreateOrConnectWithoutLessonsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutLessonsInput, StudentProfileUncheckedCreateWithoutLessonsInput>
  }

  export type ClassroomCreateWithoutLessonsInput = {
    id?: string
    name: string
    year: number
    teacher?: TeacherProfileCreateNestedOneWithoutClassesInput
    students?: StudentProfileCreateNestedManyWithoutClassroomsInput
    schedule?: ScheduleItemCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomUncheckedCreateWithoutLessonsInput = {
    id?: string
    name: string
    year: number
    teacherId?: string | null
    students?: StudentProfileUncheckedCreateNestedManyWithoutClassroomsInput
    schedule?: ScheduleItemUncheckedCreateNestedManyWithoutClassroomInput
  }

  export type ClassroomCreateOrConnectWithoutLessonsInput = {
    where: ClassroomWhereUniqueInput
    create: XOR<ClassroomCreateWithoutLessonsInput, ClassroomUncheckedCreateWithoutLessonsInput>
  }

  export type AttendanceCreateWithoutLessonInput = {
    id?: string
    status: $Enums.AttendanceStatus
    note?: string | null
    student: StudentProfileCreateNestedOneWithoutAttendancesInput
  }

  export type AttendanceUncheckedCreateWithoutLessonInput = {
    id?: string
    studentId: string
    status: $Enums.AttendanceStatus
    note?: string | null
  }

  export type AttendanceCreateOrConnectWithoutLessonInput = {
    where: AttendanceWhereUniqueInput
    create: XOR<AttendanceCreateWithoutLessonInput, AttendanceUncheckedCreateWithoutLessonInput>
  }

  export type AttendanceCreateManyLessonInputEnvelope = {
    data: AttendanceCreateManyLessonInput | AttendanceCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type HomeworkCreateWithoutLessonInput = {
    id?: string
    title: string
    content?: string | null
    assignedDate?: Date | string
    dueDate: Date | string
    trackings?: HomeworkTrackingCreateNestedManyWithoutHomeworkInput
  }

  export type HomeworkUncheckedCreateWithoutLessonInput = {
    id?: string
    title: string
    content?: string | null
    assignedDate?: Date | string
    dueDate: Date | string
    trackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutHomeworkInput
  }

  export type HomeworkCreateOrConnectWithoutLessonInput = {
    where: HomeworkWhereUniqueInput
    create: XOR<HomeworkCreateWithoutLessonInput, HomeworkUncheckedCreateWithoutLessonInput>
  }

  export type HomeworkCreateManyLessonInputEnvelope = {
    data: HomeworkCreateManyLessonInput | HomeworkCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type MaterialCreateWithoutLessonInput = {
    id?: string
    title: string
    linkUrl?: string | null
    type: $Enums.FileType
    createdAt?: Date | string
    file?: FileCreateNestedOneWithoutMaterialsInput
  }

  export type MaterialUncheckedCreateWithoutLessonInput = {
    id?: string
    title: string
    fileId?: string | null
    linkUrl?: string | null
    type: $Enums.FileType
    createdAt?: Date | string
  }

  export type MaterialCreateOrConnectWithoutLessonInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutLessonInput, MaterialUncheckedCreateWithoutLessonInput>
  }

  export type MaterialCreateManyLessonInputEnvelope = {
    data: MaterialCreateManyLessonInput | MaterialCreateManyLessonInput[]
    skipDuplicates?: boolean
  }

  export type PaymentCreateWithoutLessonsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    type: $Enums.PaymentType
    note?: string | null
    isVisibleToStudent?: boolean
    student: StudentProfileCreateNestedOneWithoutPaymentsInput
    teacher: TeacherProfileCreateNestedOneWithoutPaymentsInput
  }

  export type PaymentUncheckedCreateWithoutLessonsInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    type: $Enums.PaymentType
    note?: string | null
    isVisibleToStudent?: boolean
    studentId: string
    teacherId: string
  }

  export type PaymentCreateOrConnectWithoutLessonsInput = {
    where: PaymentWhereUniqueInput
    create: XOR<PaymentCreateWithoutLessonsInput, PaymentUncheckedCreateWithoutLessonsInput>
  }

  export type ScheduleItemUpsertWithoutLessonsInput = {
    update: XOR<ScheduleItemUpdateWithoutLessonsInput, ScheduleItemUncheckedUpdateWithoutLessonsInput>
    create: XOR<ScheduleItemCreateWithoutLessonsInput, ScheduleItemUncheckedCreateWithoutLessonsInput>
    where?: ScheduleItemWhereInput
  }

  export type ScheduleItemUpdateToOneWithWhereWithoutLessonsInput = {
    where?: ScheduleItemWhereInput
    data: XOR<ScheduleItemUpdateWithoutLessonsInput, ScheduleItemUncheckedUpdateWithoutLessonsInput>
  }

  export type ScheduleItemUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherProfileUpdateOneRequiredWithoutScheduleItemsNestedInput
    classroom?: ClassroomUpdateOneWithoutScheduleNestedInput
    student?: StudentProfileUpdateOneWithoutRecurringSchedulesNestedInput
  }

  export type ScheduleItemUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeacherProfileUpsertWithoutLessonsInput = {
    update: XOR<TeacherProfileUpdateWithoutLessonsInput, TeacherProfileUncheckedUpdateWithoutLessonsInput>
    create: XOR<TeacherProfileCreateWithoutLessonsInput, TeacherProfileUncheckedCreateWithoutLessonsInput>
    where?: TeacherProfileWhereInput
  }

  export type TeacherProfileUpdateToOneWithWhereWithoutLessonsInput = {
    where?: TeacherProfileWhereInput
    data: XOR<TeacherProfileUpdateWithoutLessonsInput, TeacherProfileUncheckedUpdateWithoutLessonsInput>
  }

  export type TeacherProfileUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherProfileNestedInput
    studentRelations?: StudentTeacherRelationUpdateManyWithoutTeacherNestedInput
    classes?: ClassroomUpdateManyWithoutTeacherNestedInput
    payments?: PaymentUpdateManyWithoutTeacherNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherProfileUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    studentRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: ClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutTeacherNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type StudentProfileUpsertWithWhereUniqueWithoutLessonsInput = {
    where: StudentProfileWhereUniqueInput
    update: XOR<StudentProfileUpdateWithoutLessonsInput, StudentProfileUncheckedUpdateWithoutLessonsInput>
    create: XOR<StudentProfileCreateWithoutLessonsInput, StudentProfileUncheckedCreateWithoutLessonsInput>
  }

  export type StudentProfileUpdateWithWhereUniqueWithoutLessonsInput = {
    where: StudentProfileWhereUniqueInput
    data: XOR<StudentProfileUpdateWithoutLessonsInput, StudentProfileUncheckedUpdateWithoutLessonsInput>
  }

  export type StudentProfileUpdateManyWithWhereWithoutLessonsInput = {
    where: StudentProfileScalarWhereInput
    data: XOR<StudentProfileUpdateManyMutationInput, StudentProfileUncheckedUpdateManyWithoutLessonsInput>
  }

  export type ClassroomUpsertWithoutLessonsInput = {
    update: XOR<ClassroomUpdateWithoutLessonsInput, ClassroomUncheckedUpdateWithoutLessonsInput>
    create: XOR<ClassroomCreateWithoutLessonsInput, ClassroomUncheckedCreateWithoutLessonsInput>
    where?: ClassroomWhereInput
  }

  export type ClassroomUpdateToOneWithWhereWithoutLessonsInput = {
    where?: ClassroomWhereInput
    data: XOR<ClassroomUpdateWithoutLessonsInput, ClassroomUncheckedUpdateWithoutLessonsInput>
  }

  export type ClassroomUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    teacher?: TeacherProfileUpdateOneWithoutClassesNestedInput
    students?: StudentProfileUpdateManyWithoutClassroomsNestedInput
    schedule?: ScheduleItemUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    students?: StudentProfileUncheckedUpdateManyWithoutClassroomsNestedInput
    schedule?: ScheduleItemUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type AttendanceUpsertWithWhereUniqueWithoutLessonInput = {
    where: AttendanceWhereUniqueInput
    update: XOR<AttendanceUpdateWithoutLessonInput, AttendanceUncheckedUpdateWithoutLessonInput>
    create: XOR<AttendanceCreateWithoutLessonInput, AttendanceUncheckedCreateWithoutLessonInput>
  }

  export type AttendanceUpdateWithWhereUniqueWithoutLessonInput = {
    where: AttendanceWhereUniqueInput
    data: XOR<AttendanceUpdateWithoutLessonInput, AttendanceUncheckedUpdateWithoutLessonInput>
  }

  export type AttendanceUpdateManyWithWhereWithoutLessonInput = {
    where: AttendanceScalarWhereInput
    data: XOR<AttendanceUpdateManyMutationInput, AttendanceUncheckedUpdateManyWithoutLessonInput>
  }

  export type HomeworkUpsertWithWhereUniqueWithoutLessonInput = {
    where: HomeworkWhereUniqueInput
    update: XOR<HomeworkUpdateWithoutLessonInput, HomeworkUncheckedUpdateWithoutLessonInput>
    create: XOR<HomeworkCreateWithoutLessonInput, HomeworkUncheckedCreateWithoutLessonInput>
  }

  export type HomeworkUpdateWithWhereUniqueWithoutLessonInput = {
    where: HomeworkWhereUniqueInput
    data: XOR<HomeworkUpdateWithoutLessonInput, HomeworkUncheckedUpdateWithoutLessonInput>
  }

  export type HomeworkUpdateManyWithWhereWithoutLessonInput = {
    where: HomeworkScalarWhereInput
    data: XOR<HomeworkUpdateManyMutationInput, HomeworkUncheckedUpdateManyWithoutLessonInput>
  }

  export type HomeworkScalarWhereInput = {
    AND?: HomeworkScalarWhereInput | HomeworkScalarWhereInput[]
    OR?: HomeworkScalarWhereInput[]
    NOT?: HomeworkScalarWhereInput | HomeworkScalarWhereInput[]
    id?: StringFilter<"Homework"> | string
    title?: StringFilter<"Homework"> | string
    content?: StringNullableFilter<"Homework"> | string | null
    assignedDate?: DateTimeFilter<"Homework"> | Date | string
    dueDate?: DateTimeFilter<"Homework"> | Date | string
    lessonId?: StringFilter<"Homework"> | string
  }

  export type MaterialUpsertWithWhereUniqueWithoutLessonInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutLessonInput, MaterialUncheckedUpdateWithoutLessonInput>
    create: XOR<MaterialCreateWithoutLessonInput, MaterialUncheckedCreateWithoutLessonInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutLessonInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutLessonInput, MaterialUncheckedUpdateWithoutLessonInput>
  }

  export type MaterialUpdateManyWithWhereWithoutLessonInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutLessonInput>
  }

  export type MaterialScalarWhereInput = {
    AND?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    OR?: MaterialScalarWhereInput[]
    NOT?: MaterialScalarWhereInput | MaterialScalarWhereInput[]
    id?: StringFilter<"Material"> | string
    title?: StringFilter<"Material"> | string
    fileId?: StringNullableFilter<"Material"> | string | null
    linkUrl?: StringNullableFilter<"Material"> | string | null
    type?: EnumFileTypeFilter<"Material"> | $Enums.FileType
    lessonId?: StringFilter<"Material"> | string
    createdAt?: DateTimeFilter<"Material"> | Date | string
  }

  export type PaymentUpsertWithWhereUniqueWithoutLessonsInput = {
    where: PaymentWhereUniqueInput
    update: XOR<PaymentUpdateWithoutLessonsInput, PaymentUncheckedUpdateWithoutLessonsInput>
    create: XOR<PaymentCreateWithoutLessonsInput, PaymentUncheckedCreateWithoutLessonsInput>
  }

  export type PaymentUpdateWithWhereUniqueWithoutLessonsInput = {
    where: PaymentWhereUniqueInput
    data: XOR<PaymentUpdateWithoutLessonsInput, PaymentUncheckedUpdateWithoutLessonsInput>
  }

  export type PaymentUpdateManyWithWhereWithoutLessonsInput = {
    where: PaymentScalarWhereInput
    data: XOR<PaymentUpdateManyMutationInput, PaymentUncheckedUpdateManyWithoutLessonsInput>
  }

  export type FileCreateWithoutMaterialsInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutFilesInput
    messages?: MessageCreateNestedManyWithoutFileInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutFileInput
    homeworkSubmissions?: HomeworkSubmissionCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutMaterialsInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    messages?: MessageUncheckedCreateNestedManyWithoutFileInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutFileInput
    homeworkSubmissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutMaterialsInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutMaterialsInput, FileUncheckedCreateWithoutMaterialsInput>
  }

  export type LessonCreateWithoutMaterialsInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduleItem?: ScheduleItemCreateNestedOneWithoutLessonsInput
    teacher: TeacherProfileCreateNestedOneWithoutLessonsInput
    students?: StudentProfileCreateNestedManyWithoutLessonsInput
    classroom?: ClassroomCreateNestedOneWithoutLessonsInput
    attendances?: AttendanceCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkCreateNestedManyWithoutLessonInput
    payments?: PaymentCreateNestedManyWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutMaterialsInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    scheduleItemId?: string | null
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    teacherId: string
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentProfileUncheckedCreateNestedManyWithoutLessonsInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkUncheckedCreateNestedManyWithoutLessonInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLessonsInput
  }

  export type LessonCreateOrConnectWithoutMaterialsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutMaterialsInput, LessonUncheckedCreateWithoutMaterialsInput>
  }

  export type FileUpsertWithoutMaterialsInput = {
    update: XOR<FileUpdateWithoutMaterialsInput, FileUncheckedUpdateWithoutMaterialsInput>
    create: XOR<FileCreateWithoutMaterialsInput, FileUncheckedCreateWithoutMaterialsInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutMaterialsInput, FileUncheckedUpdateWithoutMaterialsInput>
  }

  export type FileUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutFilesNestedInput
    messages?: MessageUpdateManyWithoutFileNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutFileNestedInput
    homeworkSubmissions?: HomeworkSubmissionUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    messages?: MessageUncheckedUpdateManyWithoutFileNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutFileNestedInput
    homeworkSubmissions?: HomeworkSubmissionUncheckedUpdateManyWithoutFileNestedInput
  }

  export type LessonUpsertWithoutMaterialsInput = {
    update: XOR<LessonUpdateWithoutMaterialsInput, LessonUncheckedUpdateWithoutMaterialsInput>
    create: XOR<LessonCreateWithoutMaterialsInput, LessonUncheckedCreateWithoutMaterialsInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutMaterialsInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutMaterialsInput, LessonUncheckedUpdateWithoutMaterialsInput>
  }

  export type LessonUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItem?: ScheduleItemUpdateOneWithoutLessonsNestedInput
    teacher?: TeacherProfileUpdateOneRequiredWithoutLessonsNestedInput
    students?: StudentProfileUpdateManyWithoutLessonsNestedInput
    classroom?: ClassroomUpdateOneWithoutLessonsNestedInput
    attendances?: AttendanceUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUpdateManyWithoutLessonNestedInput
    payments?: PaymentUpdateManyWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutMaterialsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentProfileUncheckedUpdateManyWithoutLessonsNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUncheckedUpdateManyWithoutLessonNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLessonsNestedInput
  }

  export type LessonCreateWithoutHomeworksInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduleItem?: ScheduleItemCreateNestedOneWithoutLessonsInput
    teacher: TeacherProfileCreateNestedOneWithoutLessonsInput
    students?: StudentProfileCreateNestedManyWithoutLessonsInput
    classroom?: ClassroomCreateNestedOneWithoutLessonsInput
    attendances?: AttendanceCreateNestedManyWithoutLessonInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
    payments?: PaymentCreateNestedManyWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutHomeworksInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    scheduleItemId?: string | null
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    teacherId: string
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentProfileUncheckedCreateNestedManyWithoutLessonsInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLessonsInput
  }

  export type LessonCreateOrConnectWithoutHomeworksInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutHomeworksInput, LessonUncheckedCreateWithoutHomeworksInput>
  }

  export type HomeworkTrackingCreateWithoutHomeworkInput = {
    id?: string
    status?: $Enums.HomeworkStatus
    studentNote?: string | null
    teacherNote?: string | null
    checkedAt?: Date | string | null
    file?: FileCreateNestedOneWithoutHomeworkTrackingsInput
    student: StudentProfileCreateNestedOneWithoutHomeworkTrackingsInput
  }

  export type HomeworkTrackingUncheckedCreateWithoutHomeworkInput = {
    id?: string
    studentId: string
    status?: $Enums.HomeworkStatus
    studentNote?: string | null
    teacherNote?: string | null
    fileId?: string | null
    checkedAt?: Date | string | null
  }

  export type HomeworkTrackingCreateOrConnectWithoutHomeworkInput = {
    where: HomeworkTrackingWhereUniqueInput
    create: XOR<HomeworkTrackingCreateWithoutHomeworkInput, HomeworkTrackingUncheckedCreateWithoutHomeworkInput>
  }

  export type HomeworkTrackingCreateManyHomeworkInputEnvelope = {
    data: HomeworkTrackingCreateManyHomeworkInput | HomeworkTrackingCreateManyHomeworkInput[]
    skipDuplicates?: boolean
  }

  export type LessonUpsertWithoutHomeworksInput = {
    update: XOR<LessonUpdateWithoutHomeworksInput, LessonUncheckedUpdateWithoutHomeworksInput>
    create: XOR<LessonCreateWithoutHomeworksInput, LessonUncheckedCreateWithoutHomeworksInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutHomeworksInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutHomeworksInput, LessonUncheckedUpdateWithoutHomeworksInput>
  }

  export type LessonUpdateWithoutHomeworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItem?: ScheduleItemUpdateOneWithoutLessonsNestedInput
    teacher?: TeacherProfileUpdateOneRequiredWithoutLessonsNestedInput
    students?: StudentProfileUpdateManyWithoutLessonsNestedInput
    classroom?: ClassroomUpdateOneWithoutLessonsNestedInput
    attendances?: AttendanceUpdateManyWithoutLessonNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    payments?: PaymentUpdateManyWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutHomeworksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentProfileUncheckedUpdateManyWithoutLessonsNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLessonsNestedInput
  }

  export type HomeworkTrackingUpsertWithWhereUniqueWithoutHomeworkInput = {
    where: HomeworkTrackingWhereUniqueInput
    update: XOR<HomeworkTrackingUpdateWithoutHomeworkInput, HomeworkTrackingUncheckedUpdateWithoutHomeworkInput>
    create: XOR<HomeworkTrackingCreateWithoutHomeworkInput, HomeworkTrackingUncheckedCreateWithoutHomeworkInput>
  }

  export type HomeworkTrackingUpdateWithWhereUniqueWithoutHomeworkInput = {
    where: HomeworkTrackingWhereUniqueInput
    data: XOR<HomeworkTrackingUpdateWithoutHomeworkInput, HomeworkTrackingUncheckedUpdateWithoutHomeworkInput>
  }

  export type HomeworkTrackingUpdateManyWithWhereWithoutHomeworkInput = {
    where: HomeworkTrackingScalarWhereInput
    data: XOR<HomeworkTrackingUpdateManyMutationInput, HomeworkTrackingUncheckedUpdateManyWithoutHomeworkInput>
  }

  export type FileCreateWithoutHomeworkTrackingsInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutFilesInput
    materials?: MaterialCreateNestedManyWithoutFileInput
    messages?: MessageCreateNestedManyWithoutFileInput
    homeworkSubmissions?: HomeworkSubmissionCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutHomeworkTrackingsInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: MaterialUncheckedCreateNestedManyWithoutFileInput
    messages?: MessageUncheckedCreateNestedManyWithoutFileInput
    homeworkSubmissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutHomeworkTrackingsInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutHomeworkTrackingsInput, FileUncheckedCreateWithoutHomeworkTrackingsInput>
  }

  export type HomeworkCreateWithoutTrackingsInput = {
    id?: string
    title: string
    content?: string | null
    assignedDate?: Date | string
    dueDate: Date | string
    lesson: LessonCreateNestedOneWithoutHomeworksInput
  }

  export type HomeworkUncheckedCreateWithoutTrackingsInput = {
    id?: string
    title: string
    content?: string | null
    assignedDate?: Date | string
    dueDate: Date | string
    lessonId: string
  }

  export type HomeworkCreateOrConnectWithoutTrackingsInput = {
    where: HomeworkWhereUniqueInput
    create: XOR<HomeworkCreateWithoutTrackingsInput, HomeworkUncheckedCreateWithoutTrackingsInput>
  }

  export type StudentProfileCreateWithoutHomeworkTrackingsInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    teacherRelations?: StudentTeacherRelationCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemCreateNestedManyWithoutStudentInput
    lessons?: LessonCreateNestedManyWithoutStudentsInput
    submissions?: HomeworkSubmissionCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutStudentInput
    grades?: SchoolExamCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUncheckedCreateWithoutHomeworkTrackingsInput = {
    id?: string
    userId?: string | null
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemUncheckedCreateNestedManyWithoutStudentInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentsInput
    submissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentInput
    grades?: SchoolExamUncheckedCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileCreateOrConnectWithoutHomeworkTrackingsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutHomeworkTrackingsInput, StudentProfileUncheckedCreateWithoutHomeworkTrackingsInput>
  }

  export type FileUpsertWithoutHomeworkTrackingsInput = {
    update: XOR<FileUpdateWithoutHomeworkTrackingsInput, FileUncheckedUpdateWithoutHomeworkTrackingsInput>
    create: XOR<FileCreateWithoutHomeworkTrackingsInput, FileUncheckedCreateWithoutHomeworkTrackingsInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutHomeworkTrackingsInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutHomeworkTrackingsInput, FileUncheckedUpdateWithoutHomeworkTrackingsInput>
  }

  export type FileUpdateWithoutHomeworkTrackingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutFilesNestedInput
    materials?: MaterialUpdateManyWithoutFileNestedInput
    messages?: MessageUpdateManyWithoutFileNestedInput
    homeworkSubmissions?: HomeworkSubmissionUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutHomeworkTrackingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: MaterialUncheckedUpdateManyWithoutFileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutFileNestedInput
    homeworkSubmissions?: HomeworkSubmissionUncheckedUpdateManyWithoutFileNestedInput
  }

  export type HomeworkUpsertWithoutTrackingsInput = {
    update: XOR<HomeworkUpdateWithoutTrackingsInput, HomeworkUncheckedUpdateWithoutTrackingsInput>
    create: XOR<HomeworkCreateWithoutTrackingsInput, HomeworkUncheckedCreateWithoutTrackingsInput>
    where?: HomeworkWhereInput
  }

  export type HomeworkUpdateToOneWithWhereWithoutTrackingsInput = {
    where?: HomeworkWhereInput
    data: XOR<HomeworkUpdateWithoutTrackingsInput, HomeworkUncheckedUpdateWithoutTrackingsInput>
  }

  export type HomeworkUpdateWithoutTrackingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutHomeworksNestedInput
  }

  export type HomeworkUncheckedUpdateWithoutTrackingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    lessonId?: StringFieldUpdateOperationsInput | string
  }

  export type StudentProfileUpsertWithoutHomeworkTrackingsInput = {
    update: XOR<StudentProfileUpdateWithoutHomeworkTrackingsInput, StudentProfileUncheckedUpdateWithoutHomeworkTrackingsInput>
    create: XOR<StudentProfileCreateWithoutHomeworkTrackingsInput, StudentProfileUncheckedCreateWithoutHomeworkTrackingsInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutHomeworkTrackingsInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutHomeworkTrackingsInput, StudentProfileUncheckedUpdateWithoutHomeworkTrackingsInput>
  }

  export type StudentProfileUpdateWithoutHomeworkTrackingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    teacherRelations?: StudentTeacherRelationUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUpdateManyWithoutStudentNestedInput
    lessons?: LessonUpdateManyWithoutStudentsNestedInput
    submissions?: HomeworkSubmissionUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutHomeworkTrackingsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUncheckedUpdateManyWithoutStudentNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentsNestedInput
    submissions?: HomeworkSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUncheckedUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type FileCreateWithoutHomeworkSubmissionsInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutFilesInput
    materials?: MaterialCreateNestedManyWithoutFileInput
    messages?: MessageCreateNestedManyWithoutFileInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutHomeworkSubmissionsInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: MaterialUncheckedCreateNestedManyWithoutFileInput
    messages?: MessageUncheckedCreateNestedManyWithoutFileInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutHomeworkSubmissionsInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutHomeworkSubmissionsInput, FileUncheckedCreateWithoutHomeworkSubmissionsInput>
  }

  export type StudentProfileCreateWithoutSubmissionsInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    teacherRelations?: StudentTeacherRelationCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemCreateNestedManyWithoutStudentInput
    lessons?: LessonCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutStudentInput
    grades?: SchoolExamCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    userId?: string | null
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemUncheckedCreateNestedManyWithoutStudentInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentInput
    grades?: SchoolExamUncheckedCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileCreateOrConnectWithoutSubmissionsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutSubmissionsInput, StudentProfileUncheckedCreateWithoutSubmissionsInput>
  }

  export type FileUpsertWithoutHomeworkSubmissionsInput = {
    update: XOR<FileUpdateWithoutHomeworkSubmissionsInput, FileUncheckedUpdateWithoutHomeworkSubmissionsInput>
    create: XOR<FileCreateWithoutHomeworkSubmissionsInput, FileUncheckedCreateWithoutHomeworkSubmissionsInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutHomeworkSubmissionsInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutHomeworkSubmissionsInput, FileUncheckedUpdateWithoutHomeworkSubmissionsInput>
  }

  export type FileUpdateWithoutHomeworkSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutFilesNestedInput
    materials?: MaterialUpdateManyWithoutFileNestedInput
    messages?: MessageUpdateManyWithoutFileNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutHomeworkSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: MaterialUncheckedUpdateManyWithoutFileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutFileNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutFileNestedInput
  }

  export type StudentProfileUpsertWithoutSubmissionsInput = {
    update: XOR<StudentProfileUpdateWithoutSubmissionsInput, StudentProfileUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<StudentProfileCreateWithoutSubmissionsInput, StudentProfileUncheckedCreateWithoutSubmissionsInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutSubmissionsInput, StudentProfileUncheckedUpdateWithoutSubmissionsInput>
  }

  export type StudentProfileUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    teacherRelations?: StudentTeacherRelationUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUpdateManyWithoutStudentNestedInput
    lessons?: LessonUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUncheckedUpdateManyWithoutStudentNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUncheckedUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileCreateWithoutGradesInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    teacherRelations?: StudentTeacherRelationCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemCreateNestedManyWithoutStudentInput
    lessons?: LessonCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUncheckedCreateWithoutGradesInput = {
    id?: string
    userId?: string | null
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemUncheckedCreateNestedManyWithoutStudentInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileCreateOrConnectWithoutGradesInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutGradesInput, StudentProfileUncheckedCreateWithoutGradesInput>
  }

  export type StudentProfileUpsertWithoutGradesInput = {
    update: XOR<StudentProfileUpdateWithoutGradesInput, StudentProfileUncheckedUpdateWithoutGradesInput>
    create: XOR<StudentProfileCreateWithoutGradesInput, StudentProfileUncheckedCreateWithoutGradesInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutGradesInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutGradesInput, StudentProfileUncheckedUpdateWithoutGradesInput>
  }

  export type StudentProfileUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    teacherRelations?: StudentTeacherRelationUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUpdateManyWithoutStudentNestedInput
    lessons?: LessonUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutGradesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUncheckedUpdateManyWithoutStudentNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileCreateWithoutTrialExamsInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    teacherRelations?: StudentTeacherRelationCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemCreateNestedManyWithoutStudentInput
    lessons?: LessonCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutStudentInput
    grades?: SchoolExamCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUncheckedCreateWithoutTrialExamsInput = {
    id?: string
    userId?: string | null
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemUncheckedCreateNestedManyWithoutStudentInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentInput
    grades?: SchoolExamUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileCreateOrConnectWithoutTrialExamsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutTrialExamsInput, StudentProfileUncheckedCreateWithoutTrialExamsInput>
  }

  export type TrialExamResultCreateWithoutTrialExamInput = {
    id?: string
    lessonName: string
    correctCount: number
    incorrectCount: number
    emptyCount: number
    net: number
    mistakeTopics?: TrialExamResultCreatemistakeTopicsInput | string[]
    mistakeAnalysis?: string | null
  }

  export type TrialExamResultUncheckedCreateWithoutTrialExamInput = {
    id?: string
    lessonName: string
    correctCount: number
    incorrectCount: number
    emptyCount: number
    net: number
    mistakeTopics?: TrialExamResultCreatemistakeTopicsInput | string[]
    mistakeAnalysis?: string | null
  }

  export type TrialExamResultCreateOrConnectWithoutTrialExamInput = {
    where: TrialExamResultWhereUniqueInput
    create: XOR<TrialExamResultCreateWithoutTrialExamInput, TrialExamResultUncheckedCreateWithoutTrialExamInput>
  }

  export type TrialExamResultCreateManyTrialExamInputEnvelope = {
    data: TrialExamResultCreateManyTrialExamInput | TrialExamResultCreateManyTrialExamInput[]
    skipDuplicates?: boolean
  }

  export type StudentProfileUpsertWithoutTrialExamsInput = {
    update: XOR<StudentProfileUpdateWithoutTrialExamsInput, StudentProfileUncheckedUpdateWithoutTrialExamsInput>
    create: XOR<StudentProfileCreateWithoutTrialExamsInput, StudentProfileUncheckedCreateWithoutTrialExamsInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutTrialExamsInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutTrialExamsInput, StudentProfileUncheckedUpdateWithoutTrialExamsInput>
  }

  export type StudentProfileUpdateWithoutTrialExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    teacherRelations?: StudentTeacherRelationUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUpdateManyWithoutStudentNestedInput
    lessons?: LessonUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutTrialExamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUncheckedUpdateManyWithoutStudentNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TrialExamResultUpsertWithWhereUniqueWithoutTrialExamInput = {
    where: TrialExamResultWhereUniqueInput
    update: XOR<TrialExamResultUpdateWithoutTrialExamInput, TrialExamResultUncheckedUpdateWithoutTrialExamInput>
    create: XOR<TrialExamResultCreateWithoutTrialExamInput, TrialExamResultUncheckedCreateWithoutTrialExamInput>
  }

  export type TrialExamResultUpdateWithWhereUniqueWithoutTrialExamInput = {
    where: TrialExamResultWhereUniqueInput
    data: XOR<TrialExamResultUpdateWithoutTrialExamInput, TrialExamResultUncheckedUpdateWithoutTrialExamInput>
  }

  export type TrialExamResultUpdateManyWithWhereWithoutTrialExamInput = {
    where: TrialExamResultScalarWhereInput
    data: XOR<TrialExamResultUpdateManyMutationInput, TrialExamResultUncheckedUpdateManyWithoutTrialExamInput>
  }

  export type TrialExamResultScalarWhereInput = {
    AND?: TrialExamResultScalarWhereInput | TrialExamResultScalarWhereInput[]
    OR?: TrialExamResultScalarWhereInput[]
    NOT?: TrialExamResultScalarWhereInput | TrialExamResultScalarWhereInput[]
    id?: StringFilter<"TrialExamResult"> | string
    trialExamId?: StringFilter<"TrialExamResult"> | string
    lessonName?: StringFilter<"TrialExamResult"> | string
    correctCount?: IntFilter<"TrialExamResult"> | number
    incorrectCount?: IntFilter<"TrialExamResult"> | number
    emptyCount?: IntFilter<"TrialExamResult"> | number
    net?: FloatFilter<"TrialExamResult"> | number
    mistakeTopics?: StringNullableListFilter<"TrialExamResult">
    mistakeAnalysis?: StringNullableFilter<"TrialExamResult"> | string | null
  }

  export type TrialExamCreateWithoutResultsInput = {
    id?: string
    title: string
    date: Date | string
    category: $Enums.ExamCategory
    publisher?: string | null
    totalNet?: number | null
    totalScore?: number | null
    student: StudentProfileCreateNestedOneWithoutTrialExamsInput
  }

  export type TrialExamUncheckedCreateWithoutResultsInput = {
    id?: string
    title: string
    date: Date | string
    category: $Enums.ExamCategory
    publisher?: string | null
    studentId: string
    totalNet?: number | null
    totalScore?: number | null
  }

  export type TrialExamCreateOrConnectWithoutResultsInput = {
    where: TrialExamWhereUniqueInput
    create: XOR<TrialExamCreateWithoutResultsInput, TrialExamUncheckedCreateWithoutResultsInput>
  }

  export type TrialExamUpsertWithoutResultsInput = {
    update: XOR<TrialExamUpdateWithoutResultsInput, TrialExamUncheckedUpdateWithoutResultsInput>
    create: XOR<TrialExamCreateWithoutResultsInput, TrialExamUncheckedCreateWithoutResultsInput>
    where?: TrialExamWhereInput
  }

  export type TrialExamUpdateToOneWithWhereWithoutResultsInput = {
    where?: TrialExamWhereInput
    data: XOR<TrialExamUpdateWithoutResultsInput, TrialExamUncheckedUpdateWithoutResultsInput>
  }

  export type TrialExamUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumExamCategoryFieldUpdateOperationsInput | $Enums.ExamCategory
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    student?: StudentProfileUpdateOneRequiredWithoutTrialExamsNestedInput
  }

  export type TrialExamUncheckedUpdateWithoutResultsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumExamCategoryFieldUpdateOperationsInput | $Enums.ExamCategory
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: StringFieldUpdateOperationsInput | string
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type LessonCreateWithoutAttendancesInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduleItem?: ScheduleItemCreateNestedOneWithoutLessonsInput
    teacher: TeacherProfileCreateNestedOneWithoutLessonsInput
    students?: StudentProfileCreateNestedManyWithoutLessonsInput
    classroom?: ClassroomCreateNestedOneWithoutLessonsInput
    homeworks?: HomeworkCreateNestedManyWithoutLessonInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
    payments?: PaymentCreateNestedManyWithoutLessonsInput
  }

  export type LessonUncheckedCreateWithoutAttendancesInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    scheduleItemId?: string | null
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    teacherId: string
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentProfileUncheckedCreateNestedManyWithoutLessonsInput
    homeworks?: HomeworkUncheckedCreateNestedManyWithoutLessonInput
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
    payments?: PaymentUncheckedCreateNestedManyWithoutLessonsInput
  }

  export type LessonCreateOrConnectWithoutAttendancesInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutAttendancesInput, LessonUncheckedCreateWithoutAttendancesInput>
  }

  export type StudentProfileCreateWithoutAttendancesInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    teacherRelations?: StudentTeacherRelationCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemCreateNestedManyWithoutStudentInput
    lessons?: LessonCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionCreateNestedManyWithoutStudentInput
    payments?: PaymentCreateNestedManyWithoutStudentInput
    grades?: SchoolExamCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUncheckedCreateWithoutAttendancesInput = {
    id?: string
    userId?: string | null
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemUncheckedCreateNestedManyWithoutStudentInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutStudentInput
    payments?: PaymentUncheckedCreateNestedManyWithoutStudentInput
    grades?: SchoolExamUncheckedCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileCreateOrConnectWithoutAttendancesInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutAttendancesInput, StudentProfileUncheckedCreateWithoutAttendancesInput>
  }

  export type LessonUpsertWithoutAttendancesInput = {
    update: XOR<LessonUpdateWithoutAttendancesInput, LessonUncheckedUpdateWithoutAttendancesInput>
    create: XOR<LessonCreateWithoutAttendancesInput, LessonUncheckedCreateWithoutAttendancesInput>
    where?: LessonWhereInput
  }

  export type LessonUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: LessonWhereInput
    data: XOR<LessonUpdateWithoutAttendancesInput, LessonUncheckedUpdateWithoutAttendancesInput>
  }

  export type LessonUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItem?: ScheduleItemUpdateOneWithoutLessonsNestedInput
    teacher?: TeacherProfileUpdateOneRequiredWithoutLessonsNestedInput
    students?: StudentProfileUpdateManyWithoutLessonsNestedInput
    classroom?: ClassroomUpdateOneWithoutLessonsNestedInput
    homeworks?: HomeworkUpdateManyWithoutLessonNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    payments?: PaymentUpdateManyWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentProfileUncheckedUpdateManyWithoutLessonsNestedInput
    homeworks?: HomeworkUncheckedUpdateManyWithoutLessonNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLessonsNestedInput
  }

  export type StudentProfileUpsertWithoutAttendancesInput = {
    update: XOR<StudentProfileUpdateWithoutAttendancesInput, StudentProfileUncheckedUpdateWithoutAttendancesInput>
    create: XOR<StudentProfileCreateWithoutAttendancesInput, StudentProfileUncheckedCreateWithoutAttendancesInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutAttendancesInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutAttendancesInput, StudentProfileUncheckedUpdateWithoutAttendancesInput>
  }

  export type StudentProfileUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    teacherRelations?: StudentTeacherRelationUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUpdateManyWithoutStudentNestedInput
    lessons?: LessonUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutAttendancesInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUncheckedUpdateManyWithoutStudentNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUncheckedUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileCreateWithoutPaymentsInput = {
    id?: string
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    user?: UserCreateNestedOneWithoutStudentProfileInput
    teacherRelations?: StudentTeacherRelationCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemCreateNestedManyWithoutStudentInput
    lessons?: LessonCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionCreateNestedManyWithoutStudentInput
    grades?: SchoolExamCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamCreateNestedManyWithoutStudentInput
    attendances?: AttendanceCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId?: string | null
    tempFirstName?: string | null
    tempLastName?: string | null
    tempPhone?: string | null
    tempEmail?: string | null
    tempAvatarKey?: string | null
    inviteToken?: string | null
    inviteTokenExpires?: Date | string | null
    isClaimed?: boolean
    creatorTeacherId?: string | null
    studentNo?: string | null
    gradeLevel?: string | null
    parentName?: string | null
    parentPhone?: string | null
    parentEmail?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teacherRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutStudentInput
    classrooms?: ClassroomUncheckedCreateNestedManyWithoutStudentsInput
    recurringSchedules?: ScheduleItemUncheckedCreateNestedManyWithoutStudentInput
    lessons?: LessonUncheckedCreateNestedManyWithoutStudentsInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutStudentInput
    submissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutStudentInput
    grades?: SchoolExamUncheckedCreateNestedManyWithoutStudentInput
    trialExams?: TrialExamUncheckedCreateNestedManyWithoutStudentInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutStudentInput
  }

  export type StudentProfileCreateOrConnectWithoutPaymentsInput = {
    where: StudentProfileWhereUniqueInput
    create: XOR<StudentProfileCreateWithoutPaymentsInput, StudentProfileUncheckedCreateWithoutPaymentsInput>
  }

  export type TeacherProfileCreateWithoutPaymentsInput = {
    id?: string
    branch: string
    bio?: string | null
    user: UserCreateNestedOneWithoutTeacherProfileInput
    studentRelations?: StudentTeacherRelationCreateNestedManyWithoutTeacherInput
    classes?: ClassroomCreateNestedManyWithoutTeacherInput
    lessons?: LessonCreateNestedManyWithoutTeacherInput
    scheduleItems?: ScheduleItemCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileUncheckedCreateWithoutPaymentsInput = {
    id?: string
    userId: string
    branch: string
    bio?: string | null
    studentRelations?: StudentTeacherRelationUncheckedCreateNestedManyWithoutTeacherInput
    classes?: ClassroomUncheckedCreateNestedManyWithoutTeacherInput
    lessons?: LessonUncheckedCreateNestedManyWithoutTeacherInput
    scheduleItems?: ScheduleItemUncheckedCreateNestedManyWithoutTeacherInput
  }

  export type TeacherProfileCreateOrConnectWithoutPaymentsInput = {
    where: TeacherProfileWhereUniqueInput
    create: XOR<TeacherProfileCreateWithoutPaymentsInput, TeacherProfileUncheckedCreateWithoutPaymentsInput>
  }

  export type LessonCreateWithoutPaymentsInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    scheduleItem?: ScheduleItemCreateNestedOneWithoutLessonsInput
    teacher: TeacherProfileCreateNestedOneWithoutLessonsInput
    students?: StudentProfileCreateNestedManyWithoutLessonsInput
    classroom?: ClassroomCreateNestedOneWithoutLessonsInput
    attendances?: AttendanceCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkCreateNestedManyWithoutLessonInput
    materials?: MaterialCreateNestedManyWithoutLessonInput
  }

  export type LessonUncheckedCreateWithoutPaymentsInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    scheduleItemId?: string | null
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    teacherId: string
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    students?: StudentProfileUncheckedCreateNestedManyWithoutLessonsInput
    attendances?: AttendanceUncheckedCreateNestedManyWithoutLessonInput
    homeworks?: HomeworkUncheckedCreateNestedManyWithoutLessonInput
    materials?: MaterialUncheckedCreateNestedManyWithoutLessonInput
  }

  export type LessonCreateOrConnectWithoutPaymentsInput = {
    where: LessonWhereUniqueInput
    create: XOR<LessonCreateWithoutPaymentsInput, LessonUncheckedCreateWithoutPaymentsInput>
  }

  export type StudentProfileUpsertWithoutPaymentsInput = {
    update: XOR<StudentProfileUpdateWithoutPaymentsInput, StudentProfileUncheckedUpdateWithoutPaymentsInput>
    create: XOR<StudentProfileCreateWithoutPaymentsInput, StudentProfileUncheckedCreateWithoutPaymentsInput>
    where?: StudentProfileWhereInput
  }

  export type StudentProfileUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: StudentProfileWhereInput
    data: XOR<StudentProfileUpdateWithoutPaymentsInput, StudentProfileUncheckedUpdateWithoutPaymentsInput>
  }

  export type StudentProfileUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    teacherRelations?: StudentTeacherRelationUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUpdateManyWithoutStudentNestedInput
    lessons?: LessonUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUncheckedUpdateManyWithoutStudentNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUncheckedUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type TeacherProfileUpsertWithoutPaymentsInput = {
    update: XOR<TeacherProfileUpdateWithoutPaymentsInput, TeacherProfileUncheckedUpdateWithoutPaymentsInput>
    create: XOR<TeacherProfileCreateWithoutPaymentsInput, TeacherProfileUncheckedCreateWithoutPaymentsInput>
    where?: TeacherProfileWhereInput
  }

  export type TeacherProfileUpdateToOneWithWhereWithoutPaymentsInput = {
    where?: TeacherProfileWhereInput
    data: XOR<TeacherProfileUpdateWithoutPaymentsInput, TeacherProfileUncheckedUpdateWithoutPaymentsInput>
  }

  export type TeacherProfileUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTeacherProfileNestedInput
    studentRelations?: StudentTeacherRelationUpdateManyWithoutTeacherNestedInput
    classes?: ClassroomUpdateManyWithoutTeacherNestedInput
    lessons?: LessonUpdateManyWithoutTeacherNestedInput
    scheduleItems?: ScheduleItemUpdateManyWithoutTeacherNestedInput
  }

  export type TeacherProfileUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    branch?: StringFieldUpdateOperationsInput | string
    bio?: NullableStringFieldUpdateOperationsInput | string | null
    studentRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutTeacherNestedInput
    classes?: ClassroomUncheckedUpdateManyWithoutTeacherNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutTeacherNestedInput
    scheduleItems?: ScheduleItemUncheckedUpdateManyWithoutTeacherNestedInput
  }

  export type LessonUpsertWithWhereUniqueWithoutPaymentsInput = {
    where: LessonWhereUniqueInput
    update: XOR<LessonUpdateWithoutPaymentsInput, LessonUncheckedUpdateWithoutPaymentsInput>
    create: XOR<LessonCreateWithoutPaymentsInput, LessonUncheckedCreateWithoutPaymentsInput>
  }

  export type LessonUpdateWithWhereUniqueWithoutPaymentsInput = {
    where: LessonWhereUniqueInput
    data: XOR<LessonUpdateWithoutPaymentsInput, LessonUncheckedUpdateWithoutPaymentsInput>
  }

  export type LessonUpdateManyWithWhereWithoutPaymentsInput = {
    where: LessonScalarWhereInput
    data: XOR<LessonUpdateManyMutationInput, LessonUncheckedUpdateManyWithoutPaymentsInput>
  }

  export type UserCreateWithoutTodosInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutTodosInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutTodosInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTodosInput, UserUncheckedCreateWithoutTodosInput>
  }

  export type UserUpsertWithoutTodosInput = {
    update: XOR<UserUpdateWithoutTodosInput, UserUncheckedUpdateWithoutTodosInput>
    create: XOR<UserCreateWithoutTodosInput, UserUncheckedCreateWithoutTodosInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTodosInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTodosInput, UserUncheckedUpdateWithoutTodosInput>
  }

  export type UserUpdateWithoutTodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutTodosInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutCalendarEventsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    todos?: TodoCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutCalendarEventsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutCalendarEventsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
  }

  export type UserUpsertWithoutCalendarEventsInput = {
    update: XOR<UserUpdateWithoutCalendarEventsInput, UserUncheckedUpdateWithoutCalendarEventsInput>
    create: XOR<UserCreateWithoutCalendarEventsInput, UserUncheckedCreateWithoutCalendarEventsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCalendarEventsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCalendarEventsInput, UserUncheckedUpdateWithoutCalendarEventsInput>
  }

  export type UserUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutCalendarEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type FileCreateWithoutMessagesInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
    owner: UserCreateNestedOneWithoutFilesInput
    materials?: MaterialCreateNestedManyWithoutFileInput
    homeworkTrackings?: HomeworkTrackingCreateNestedManyWithoutFileInput
    homeworkSubmissions?: HomeworkSubmissionCreateNestedManyWithoutFileInput
  }

  export type FileUncheckedCreateWithoutMessagesInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    ownerId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    materials?: MaterialUncheckedCreateNestedManyWithoutFileInput
    homeworkTrackings?: HomeworkTrackingUncheckedCreateNestedManyWithoutFileInput
    homeworkSubmissions?: HomeworkSubmissionUncheckedCreateNestedManyWithoutFileInput
  }

  export type FileCreateOrConnectWithoutMessagesInput = {
    where: FileWhereUniqueInput
    create: XOR<FileCreateWithoutMessagesInput, FileUncheckedCreateWithoutMessagesInput>
  }

  export type UserCreateWithoutReceivedMessagesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    todos?: TodoCreateNestedManyWithoutUserInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutReceivedMessagesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutReceivedMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
  }

  export type UserCreateWithoutSentMessagesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    todos?: TodoCreateNestedManyWithoutUserInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutSentMessagesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutSentMessagesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
  }

  export type FileUpsertWithoutMessagesInput = {
    update: XOR<FileUpdateWithoutMessagesInput, FileUncheckedUpdateWithoutMessagesInput>
    create: XOR<FileCreateWithoutMessagesInput, FileUncheckedCreateWithoutMessagesInput>
    where?: FileWhereInput
  }

  export type FileUpdateToOneWithWhereWithoutMessagesInput = {
    where?: FileWhereInput
    data: XOR<FileUpdateWithoutMessagesInput, FileUncheckedUpdateWithoutMessagesInput>
  }

  export type FileUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    owner?: UserUpdateOneRequiredWithoutFilesNestedInput
    materials?: MaterialUpdateManyWithoutFileNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutFileNestedInput
    homeworkSubmissions?: HomeworkSubmissionUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    ownerId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: MaterialUncheckedUpdateManyWithoutFileNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutFileNestedInput
    homeworkSubmissions?: HomeworkSubmissionUncheckedUpdateManyWithoutFileNestedInput
  }

  export type UserUpsertWithoutReceivedMessagesInput = {
    update: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
    create: XOR<UserCreateWithoutReceivedMessagesInput, UserUncheckedCreateWithoutReceivedMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutReceivedMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutReceivedMessagesInput, UserUncheckedUpdateWithoutReceivedMessagesInput>
  }

  export type UserUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutReceivedMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserUpsertWithoutSentMessagesInput = {
    update: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
    create: XOR<UserCreateWithoutSentMessagesInput, UserUncheckedCreateWithoutSentMessagesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSentMessagesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSentMessagesInput, UserUncheckedUpdateWithoutSentMessagesInput>
  }

  export type UserUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutSentMessagesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    todos?: TodoCreateNestedManyWithoutUserInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
    files?: FileCreateNestedManyWithoutOwnerInput
  }

  export type UserUncheckedCreateWithoutNotificationsInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
    files?: FileUncheckedCreateNestedManyWithoutOwnerInput
  }

  export type UserCreateOrConnectWithoutNotificationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
  }

  export type UserUpsertWithoutNotificationsInput = {
    update: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
    create: XOR<UserCreateWithoutNotificationsInput, UserUncheckedCreateWithoutNotificationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutNotificationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutNotificationsInput, UserUncheckedUpdateWithoutNotificationsInput>
  }

  export type UserUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
    files?: FileUpdateManyWithoutOwnerNestedInput
  }

  export type UserUncheckedUpdateWithoutNotificationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
    files?: FileUncheckedUpdateManyWithoutOwnerNestedInput
  }

  export type UserCreateWithoutFilesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileCreateNestedOneWithoutUserInput
    accounts?: AccountCreateNestedManyWithoutUserInput
    sessions?: SessionCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestCreateNestedManyWithoutUserInput
    devices?: DeviceCreateNestedManyWithoutUserInput
    notifications?: NotificationCreateNestedManyWithoutUserInput
    sentMessages?: MessageCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageCreateNestedManyWithoutReceiverInput
    todos?: TodoCreateNestedManyWithoutUserInput
    calendarEvents?: EventCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutFilesInput = {
    id?: string
    name?: string | null
    firstName?: string | null
    lastName?: string | null
    username?: string | null
    email?: string | null
    emailVerified?: Date | string | null
    image?: string | null
    avatarVersion?: number
    password?: string | null
    phoneNumber?: string | null
    isDeleted?: boolean
    deletedAt?: Date | string | null
    role?: $Enums.Role | null
    isActive?: boolean
    isOnboardingCompleted?: boolean
    notificationEmailEnabled?: boolean
    notificationInAppEnabled?: boolean
    preferredCountry?: string | null
    preferredTimezone?: string | null
    cookieAnalyticsEnabled?: boolean
    isMarketingConsent?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    settings?: UserSettingsUncheckedCreateNestedOneWithoutUserInput
    teacherProfile?: TeacherProfileUncheckedCreateNestedOneWithoutUserInput
    studentProfile?: StudentProfileUncheckedCreateNestedOneWithoutUserInput
    accounts?: AccountUncheckedCreateNestedManyWithoutUserInput
    sessions?: SessionUncheckedCreateNestedManyWithoutUserInput
    emailChangeRequests?: EmailChangeRequestUncheckedCreateNestedManyWithoutUserInput
    devices?: DeviceUncheckedCreateNestedManyWithoutUserInput
    notifications?: NotificationUncheckedCreateNestedManyWithoutUserInput
    sentMessages?: MessageUncheckedCreateNestedManyWithoutSenderInput
    receivedMessages?: MessageUncheckedCreateNestedManyWithoutReceiverInput
    todos?: TodoUncheckedCreateNestedManyWithoutUserInput
    calendarEvents?: EventUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutFilesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
  }

  export type MaterialCreateWithoutFileInput = {
    id?: string
    title: string
    linkUrl?: string | null
    type: $Enums.FileType
    createdAt?: Date | string
    lesson: LessonCreateNestedOneWithoutMaterialsInput
  }

  export type MaterialUncheckedCreateWithoutFileInput = {
    id?: string
    title: string
    linkUrl?: string | null
    type: $Enums.FileType
    lessonId: string
    createdAt?: Date | string
  }

  export type MaterialCreateOrConnectWithoutFileInput = {
    where: MaterialWhereUniqueInput
    create: XOR<MaterialCreateWithoutFileInput, MaterialUncheckedCreateWithoutFileInput>
  }

  export type MaterialCreateManyFileInputEnvelope = {
    data: MaterialCreateManyFileInput | MaterialCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type MessageCreateWithoutFileInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    isRead?: boolean
    readAt?: Date | string | null
    receiver: UserCreateNestedOneWithoutReceivedMessagesInput
    sender: UserCreateNestedOneWithoutSentMessagesInput
  }

  export type MessageUncheckedCreateWithoutFileInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    isRead?: boolean
    readAt?: Date | string | null
    senderId: string
    receiverId: string
  }

  export type MessageCreateOrConnectWithoutFileInput = {
    where: MessageWhereUniqueInput
    create: XOR<MessageCreateWithoutFileInput, MessageUncheckedCreateWithoutFileInput>
  }

  export type MessageCreateManyFileInputEnvelope = {
    data: MessageCreateManyFileInput | MessageCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type HomeworkTrackingCreateWithoutFileInput = {
    id?: string
    status?: $Enums.HomeworkStatus
    studentNote?: string | null
    teacherNote?: string | null
    checkedAt?: Date | string | null
    homework: HomeworkCreateNestedOneWithoutTrackingsInput
    student: StudentProfileCreateNestedOneWithoutHomeworkTrackingsInput
  }

  export type HomeworkTrackingUncheckedCreateWithoutFileInput = {
    id?: string
    homeworkId: string
    studentId: string
    status?: $Enums.HomeworkStatus
    studentNote?: string | null
    teacherNote?: string | null
    checkedAt?: Date | string | null
  }

  export type HomeworkTrackingCreateOrConnectWithoutFileInput = {
    where: HomeworkTrackingWhereUniqueInput
    create: XOR<HomeworkTrackingCreateWithoutFileInput, HomeworkTrackingUncheckedCreateWithoutFileInput>
  }

  export type HomeworkTrackingCreateManyFileInputEnvelope = {
    data: HomeworkTrackingCreateManyFileInput | HomeworkTrackingCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type HomeworkSubmissionCreateWithoutFileInput = {
    id?: string
    note?: string | null
    submittedAt?: Date | string
    student: StudentProfileCreateNestedOneWithoutSubmissionsInput
  }

  export type HomeworkSubmissionUncheckedCreateWithoutFileInput = {
    id?: string
    note?: string | null
    submittedAt?: Date | string
    studentId: string
  }

  export type HomeworkSubmissionCreateOrConnectWithoutFileInput = {
    where: HomeworkSubmissionWhereUniqueInput
    create: XOR<HomeworkSubmissionCreateWithoutFileInput, HomeworkSubmissionUncheckedCreateWithoutFileInput>
  }

  export type HomeworkSubmissionCreateManyFileInputEnvelope = {
    data: HomeworkSubmissionCreateManyFileInput | HomeworkSubmissionCreateManyFileInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutFilesInput = {
    update: XOR<UserUpdateWithoutFilesInput, UserUncheckedUpdateWithoutFilesInput>
    create: XOR<UserCreateWithoutFilesInput, UserUncheckedCreateWithoutFilesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutFilesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutFilesInput, UserUncheckedUpdateWithoutFilesInput>
  }

  export type UserUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUpdateOneWithoutUserNestedInput
    accounts?: AccountUpdateManyWithoutUserNestedInput
    sessions?: SessionUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUpdateManyWithoutUserNestedInput
    devices?: DeviceUpdateManyWithoutUserNestedInput
    notifications?: NotificationUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUpdateManyWithoutReceiverNestedInput
    todos?: TodoUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutFilesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: NullableStringFieldUpdateOperationsInput | string | null
    firstName?: NullableStringFieldUpdateOperationsInput | string | null
    lastName?: NullableStringFieldUpdateOperationsInput | string | null
    username?: NullableStringFieldUpdateOperationsInput | string | null
    email?: NullableStringFieldUpdateOperationsInput | string | null
    emailVerified?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    image?: NullableStringFieldUpdateOperationsInput | string | null
    avatarVersion?: IntFieldUpdateOperationsInput | number
    password?: NullableStringFieldUpdateOperationsInput | string | null
    phoneNumber?: NullableStringFieldUpdateOperationsInput | string | null
    isDeleted?: BoolFieldUpdateOperationsInput | boolean
    deletedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    role?: NullableEnumRoleFieldUpdateOperationsInput | $Enums.Role | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    isOnboardingCompleted?: BoolFieldUpdateOperationsInput | boolean
    notificationEmailEnabled?: BoolFieldUpdateOperationsInput | boolean
    notificationInAppEnabled?: BoolFieldUpdateOperationsInput | boolean
    preferredCountry?: NullableStringFieldUpdateOperationsInput | string | null
    preferredTimezone?: NullableStringFieldUpdateOperationsInput | string | null
    cookieAnalyticsEnabled?: BoolFieldUpdateOperationsInput | boolean
    isMarketingConsent?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    settings?: UserSettingsUncheckedUpdateOneWithoutUserNestedInput
    teacherProfile?: TeacherProfileUncheckedUpdateOneWithoutUserNestedInput
    studentProfile?: StudentProfileUncheckedUpdateOneWithoutUserNestedInput
    accounts?: AccountUncheckedUpdateManyWithoutUserNestedInput
    sessions?: SessionUncheckedUpdateManyWithoutUserNestedInput
    emailChangeRequests?: EmailChangeRequestUncheckedUpdateManyWithoutUserNestedInput
    devices?: DeviceUncheckedUpdateManyWithoutUserNestedInput
    notifications?: NotificationUncheckedUpdateManyWithoutUserNestedInput
    sentMessages?: MessageUncheckedUpdateManyWithoutSenderNestedInput
    receivedMessages?: MessageUncheckedUpdateManyWithoutReceiverNestedInput
    todos?: TodoUncheckedUpdateManyWithoutUserNestedInput
    calendarEvents?: EventUncheckedUpdateManyWithoutUserNestedInput
  }

  export type MaterialUpsertWithWhereUniqueWithoutFileInput = {
    where: MaterialWhereUniqueInput
    update: XOR<MaterialUpdateWithoutFileInput, MaterialUncheckedUpdateWithoutFileInput>
    create: XOR<MaterialCreateWithoutFileInput, MaterialUncheckedCreateWithoutFileInput>
  }

  export type MaterialUpdateWithWhereUniqueWithoutFileInput = {
    where: MaterialWhereUniqueInput
    data: XOR<MaterialUpdateWithoutFileInput, MaterialUncheckedUpdateWithoutFileInput>
  }

  export type MaterialUpdateManyWithWhereWithoutFileInput = {
    where: MaterialScalarWhereInput
    data: XOR<MaterialUpdateManyMutationInput, MaterialUncheckedUpdateManyWithoutFileInput>
  }

  export type MessageUpsertWithWhereUniqueWithoutFileInput = {
    where: MessageWhereUniqueInput
    update: XOR<MessageUpdateWithoutFileInput, MessageUncheckedUpdateWithoutFileInput>
    create: XOR<MessageCreateWithoutFileInput, MessageUncheckedCreateWithoutFileInput>
  }

  export type MessageUpdateWithWhereUniqueWithoutFileInput = {
    where: MessageWhereUniqueInput
    data: XOR<MessageUpdateWithoutFileInput, MessageUncheckedUpdateWithoutFileInput>
  }

  export type MessageUpdateManyWithWhereWithoutFileInput = {
    where: MessageScalarWhereInput
    data: XOR<MessageUpdateManyMutationInput, MessageUncheckedUpdateManyWithoutFileInput>
  }

  export type HomeworkTrackingUpsertWithWhereUniqueWithoutFileInput = {
    where: HomeworkTrackingWhereUniqueInput
    update: XOR<HomeworkTrackingUpdateWithoutFileInput, HomeworkTrackingUncheckedUpdateWithoutFileInput>
    create: XOR<HomeworkTrackingCreateWithoutFileInput, HomeworkTrackingUncheckedCreateWithoutFileInput>
  }

  export type HomeworkTrackingUpdateWithWhereUniqueWithoutFileInput = {
    where: HomeworkTrackingWhereUniqueInput
    data: XOR<HomeworkTrackingUpdateWithoutFileInput, HomeworkTrackingUncheckedUpdateWithoutFileInput>
  }

  export type HomeworkTrackingUpdateManyWithWhereWithoutFileInput = {
    where: HomeworkTrackingScalarWhereInput
    data: XOR<HomeworkTrackingUpdateManyMutationInput, HomeworkTrackingUncheckedUpdateManyWithoutFileInput>
  }

  export type HomeworkSubmissionUpsertWithWhereUniqueWithoutFileInput = {
    where: HomeworkSubmissionWhereUniqueInput
    update: XOR<HomeworkSubmissionUpdateWithoutFileInput, HomeworkSubmissionUncheckedUpdateWithoutFileInput>
    create: XOR<HomeworkSubmissionCreateWithoutFileInput, HomeworkSubmissionUncheckedCreateWithoutFileInput>
  }

  export type HomeworkSubmissionUpdateWithWhereUniqueWithoutFileInput = {
    where: HomeworkSubmissionWhereUniqueInput
    data: XOR<HomeworkSubmissionUpdateWithoutFileInput, HomeworkSubmissionUncheckedUpdateWithoutFileInput>
  }

  export type HomeworkSubmissionUpdateManyWithWhereWithoutFileInput = {
    where: HomeworkSubmissionScalarWhereInput
    data: XOR<HomeworkSubmissionUpdateManyMutationInput, HomeworkSubmissionUncheckedUpdateManyWithoutFileInput>
  }

  export type AccountCreateManyUserInput = {
    id?: string
    type: string
    provider: string
    providerAccountId: string
    refresh_token?: string | null
    access_token?: string | null
    expires_at?: number | null
    token_type?: string | null
    scope?: string | null
    id_token?: string | null
    session_state?: string | null
  }

  export type SessionCreateManyUserInput = {
    id?: string
    sessionToken: string
    expires: Date | string
  }

  export type EmailChangeRequestCreateManyUserInput = {
    id?: string
    newEmail: string
    token: string
    expires: Date | string
    usedAt?: Date | string | null
  }

  export type DeviceCreateManyUserInput = {
    id?: string
    deviceType: $Enums.DeviceType
    deviceId?: string | null
    model?: string | null
    fcmToken?: string | null
    lastActive?: Date | string
  }

  export type NotificationCreateManyUserInput = {
    id?: string
    title: string
    body: string
    route?: string | null
    relatedId?: string | null
    type: $Enums.NotificationType
    isRead?: boolean
    createdAt?: Date | string
  }

  export type MessageCreateManySenderInput = {
    id?: string
    content?: string | null
    fileId?: string | null
    createdAt?: Date | string
    isRead?: boolean
    readAt?: Date | string | null
    receiverId: string
  }

  export type MessageCreateManyReceiverInput = {
    id?: string
    content?: string | null
    fileId?: string | null
    createdAt?: Date | string
    isRead?: boolean
    readAt?: Date | string | null
    senderId: string
  }

  export type TodoCreateManyUserInput = {
    id?: string
    content: string
    isCompleted?: boolean
    dueDate?: Date | string | null
    reminderTime?: Date | string | null
    priority?: $Enums.Priority
    createdAt?: Date | string
  }

  export type EventCreateManyUserInput = {
    id?: string
    title: string
    description?: string | null
    startDate: Date | string
    endDate: Date | string
    isAllDay?: boolean
    remindAt?: Date | string | null
    color?: string | null
  }

  export type FileCreateManyOwnerInput = {
    id?: string
    key: string
    filename: string
    mimeType: string
    sizeBytes: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AccountUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AccountUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    provider?: StringFieldUpdateOperationsInput | string
    providerAccountId?: StringFieldUpdateOperationsInput | string
    refresh_token?: NullableStringFieldUpdateOperationsInput | string | null
    access_token?: NullableStringFieldUpdateOperationsInput | string | null
    expires_at?: NullableIntFieldUpdateOperationsInput | number | null
    token_type?: NullableStringFieldUpdateOperationsInput | string | null
    scope?: NullableStringFieldUpdateOperationsInput | string | null
    id_token?: NullableStringFieldUpdateOperationsInput | string | null
    session_state?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type SessionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SessionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    sessionToken?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailChangeRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailChangeRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EmailChangeRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    newEmail?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expires?: DateTimeFieldUpdateOperationsInput | Date | string
    usedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DeviceUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DeviceUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    deviceType?: EnumDeviceTypeFieldUpdateOperationsInput | $Enums.DeviceType
    deviceId?: NullableStringFieldUpdateOperationsInput | string | null
    model?: NullableStringFieldUpdateOperationsInput | string | null
    fcmToken?: NullableStringFieldUpdateOperationsInput | string | null
    lastActive?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    body?: StringFieldUpdateOperationsInput | string
    route?: NullableStringFieldUpdateOperationsInput | string | null
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumNotificationTypeFieldUpdateOperationsInput | $Enums.NotificationType
    isRead?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file?: FileUpdateOneWithoutMessagesNestedInput
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file?: FileUpdateOneWithoutMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateManyWithoutReceiverInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderId?: StringFieldUpdateOperationsInput | string
  }

  export type TodoUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TodoUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: StringFieldUpdateOperationsInput | string
    isCompleted?: BoolFieldUpdateOperationsInput | boolean
    dueDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reminderTime?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    priority?: EnumPriorityFieldUpdateOperationsInput | $Enums.Priority
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    remindAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    remindAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    isAllDay?: BoolFieldUpdateOperationsInput | boolean
    remindAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type FileUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: MaterialUpdateManyWithoutFileNestedInput
    messages?: MessageUpdateManyWithoutFileNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutFileNestedInput
    homeworkSubmissions?: HomeworkSubmissionUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    materials?: MaterialUncheckedUpdateManyWithoutFileNestedInput
    messages?: MessageUncheckedUpdateManyWithoutFileNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutFileNestedInput
    homeworkSubmissions?: HomeworkSubmissionUncheckedUpdateManyWithoutFileNestedInput
  }

  export type FileUncheckedUpdateManyWithoutOwnerInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    filename?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    sizeBytes?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTeacherRelationCreateManyTeacherInput = {
    id?: string
    studentId: string
    status?: $Enums.RelationStatus
    isCreator?: boolean
    customName?: string | null
    privateNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ClassroomCreateManyTeacherInput = {
    id?: string
    name: string
    year: number
  }

  export type LessonCreateManyTeacherInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    scheduleItemId?: string | null
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PaymentCreateManyTeacherInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    type: $Enums.PaymentType
    note?: string | null
    isVisibleToStudent?: boolean
    studentId: string
  }

  export type ScheduleItemCreateManyTeacherInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    classroomId?: string | null
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentTeacherRelationUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRelationStatusFieldUpdateOperationsInput | $Enums.RelationStatus
    isCreator?: BoolFieldUpdateOperationsInput | boolean
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    privateNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentProfileUpdateOneRequiredWithoutTeacherRelationsNestedInput
  }

  export type StudentTeacherRelationUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumRelationStatusFieldUpdateOperationsInput | $Enums.RelationStatus
    isCreator?: BoolFieldUpdateOperationsInput | boolean
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    privateNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTeacherRelationUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumRelationStatusFieldUpdateOperationsInput | $Enums.RelationStatus
    isCreator?: BoolFieldUpdateOperationsInput | boolean
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    privateNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    students?: StudentProfileUpdateManyWithoutClassroomsNestedInput
    schedule?: ScheduleItemUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    students?: StudentProfileUncheckedUpdateManyWithoutClassroomsNestedInput
    schedule?: ScheduleItemUncheckedUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
  }

  export type LessonUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItem?: ScheduleItemUpdateOneWithoutLessonsNestedInput
    students?: StudentProfileUpdateManyWithoutLessonsNestedInput
    classroom?: ClassroomUpdateOneWithoutLessonsNestedInput
    attendances?: AttendanceUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUpdateManyWithoutLessonNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    payments?: PaymentUpdateManyWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentProfileUncheckedUpdateManyWithoutLessonsNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUncheckedUpdateManyWithoutLessonNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentProfileUpdateOneRequiredWithoutPaymentsNestedInput
    lessons?: LessonUpdateManyWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type ScheduleItemUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    classroom?: ClassroomUpdateOneWithoutScheduleNestedInput
    student?: StudentProfileUpdateOneWithoutRecurringSchedulesNestedInput
    lessons?: LessonUpdateManyWithoutScheduleItemNestedInput
  }

  export type ScheduleItemUncheckedUpdateWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUncheckedUpdateManyWithoutScheduleItemNestedInput
  }

  export type ScheduleItemUncheckedUpdateManyWithoutTeacherInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTeacherRelationCreateManyStudentInput = {
    id?: string
    teacherId: string
    status?: $Enums.RelationStatus
    isCreator?: boolean
    customName?: string | null
    privateNotes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ScheduleItemCreateManyStudentInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    teacherId: string
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type HomeworkTrackingCreateManyStudentInput = {
    id?: string
    homeworkId: string
    status?: $Enums.HomeworkStatus
    studentNote?: string | null
    teacherNote?: string | null
    fileId?: string | null
    checkedAt?: Date | string | null
  }

  export type HomeworkSubmissionCreateManyStudentInput = {
    id?: string
    fileId?: string | null
    note?: string | null
    submittedAt?: Date | string
  }

  export type PaymentCreateManyStudentInput = {
    id?: string
    amount: Decimal | DecimalJsLike | number | string
    date?: Date | string
    type: $Enums.PaymentType
    note?: string | null
    isVisibleToStudent?: boolean
    teacherId: string
  }

  export type SchoolExamCreateManyStudentInput = {
    id?: string
    title: string
    score: number
    date: Date | string
    subject: string
  }

  export type TrialExamCreateManyStudentInput = {
    id?: string
    title: string
    date: Date | string
    category: $Enums.ExamCategory
    publisher?: string | null
    totalNet?: number | null
    totalScore?: number | null
  }

  export type AttendanceCreateManyStudentInput = {
    id?: string
    lessonId: string
    status: $Enums.AttendanceStatus
    note?: string | null
  }

  export type StudentTeacherRelationUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumRelationStatusFieldUpdateOperationsInput | $Enums.RelationStatus
    isCreator?: BoolFieldUpdateOperationsInput | boolean
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    privateNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherProfileUpdateOneRequiredWithoutStudentRelationsNestedInput
  }

  export type StudentTeacherRelationUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    status?: EnumRelationStatusFieldUpdateOperationsInput | $Enums.RelationStatus
    isCreator?: BoolFieldUpdateOperationsInput | boolean
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    privateNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StudentTeacherRelationUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    status?: EnumRelationStatusFieldUpdateOperationsInput | $Enums.RelationStatus
    isCreator?: BoolFieldUpdateOperationsInput | boolean
    customName?: NullableStringFieldUpdateOperationsInput | string | null
    privateNotes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ClassroomUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    teacher?: TeacherProfileUpdateOneWithoutClassesNestedInput
    schedule?: ScheduleItemUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
    schedule?: ScheduleItemUncheckedUpdateManyWithoutClassroomNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutClassroomNestedInput
  }

  export type ClassroomUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    teacherId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleItemUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherProfileUpdateOneRequiredWithoutScheduleItemsNestedInput
    classroom?: ClassroomUpdateOneWithoutScheduleNestedInput
    lessons?: LessonUpdateManyWithoutScheduleItemNestedInput
  }

  export type ScheduleItemUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUncheckedUpdateManyWithoutScheduleItemNestedInput
  }

  export type ScheduleItemUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItem?: ScheduleItemUpdateOneWithoutLessonsNestedInput
    teacher?: TeacherProfileUpdateOneRequiredWithoutLessonsNestedInput
    classroom?: ClassroomUpdateOneWithoutLessonsNestedInput
    attendances?: AttendanceUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUpdateManyWithoutLessonNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    payments?: PaymentUpdateManyWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    attendances?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUncheckedUpdateManyWithoutLessonNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutStudentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeworkTrackingUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file?: FileUpdateOneWithoutHomeworkTrackingsNestedInput
    homework?: HomeworkUpdateOneRequiredWithoutTrackingsNestedInput
  }

  export type HomeworkTrackingUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeworkId?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HomeworkTrackingUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeworkId?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HomeworkSubmissionUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileUpdateOneWithoutHomeworkSubmissionsNestedInput
  }

  export type HomeworkSubmissionUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HomeworkSubmissionUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
    teacher?: TeacherProfileUpdateOneRequiredWithoutPaymentsNestedInput
    lessons?: LessonUpdateManyWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    lessons?: LessonUncheckedUpdateManyWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolExamUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolExamUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type SchoolExamUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    score?: FloatFieldUpdateOperationsInput | number
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    subject?: StringFieldUpdateOperationsInput | string
  }

  export type TrialExamUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumExamCategoryFieldUpdateOperationsInput | $Enums.ExamCategory
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    results?: TrialExamResultUpdateManyWithoutTrialExamNestedInput
  }

  export type TrialExamUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumExamCategoryFieldUpdateOperationsInput | $Enums.ExamCategory
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
    results?: TrialExamResultUncheckedUpdateManyWithoutTrialExamNestedInput
  }

  export type TrialExamUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EnumExamCategoryFieldUpdateOperationsInput | $Enums.ExamCategory
    publisher?: NullableStringFieldUpdateOperationsInput | string | null
    totalNet?: NullableFloatFieldUpdateOperationsInput | number | null
    totalScore?: NullableFloatFieldUpdateOperationsInput | number | null
  }

  export type AttendanceUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    lesson?: LessonUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutStudentInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type ScheduleItemCreateManyClassroomInput = {
    id?: string
    dayOfWeek: number
    startTime: string
    endTime: string
    subject?: string | null
    type?: $Enums.LessonType
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    teacherId: string
    studentId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonCreateManyClassroomInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    scheduleItemId?: string | null
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    teacherId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type StudentProfileUpdateWithoutClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    teacherRelations?: StudentTeacherRelationUpdateManyWithoutStudentNestedInput
    recurringSchedules?: ScheduleItemUpdateManyWithoutStudentNestedInput
    lessons?: LessonUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutStudentNestedInput
    recurringSchedules?: ScheduleItemUncheckedUpdateManyWithoutStudentNestedInput
    lessons?: LessonUncheckedUpdateManyWithoutStudentsNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUncheckedUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateManyWithoutClassroomsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ScheduleItemUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherProfileUpdateOneRequiredWithoutScheduleItemsNestedInput
    student?: StudentProfileUpdateOneWithoutRecurringSchedulesNestedInput
    lessons?: LessonUpdateManyWithoutScheduleItemNestedInput
  }

  export type ScheduleItemUncheckedUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lessons?: LessonUncheckedUpdateManyWithoutScheduleItemNestedInput
  }

  export type ScheduleItemUncheckedUpdateManyWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayOfWeek?: IntFieldUpdateOperationsInput | number
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    subject?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
    studentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItem?: ScheduleItemUpdateOneWithoutLessonsNestedInput
    teacher?: TeacherProfileUpdateOneRequiredWithoutLessonsNestedInput
    students?: StudentProfileUpdateManyWithoutLessonsNestedInput
    attendances?: AttendanceUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUpdateManyWithoutLessonNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    payments?: PaymentUpdateManyWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentProfileUncheckedUpdateManyWithoutLessonsNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUncheckedUpdateManyWithoutLessonNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutClassroomInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LessonCreateManyScheduleItemInput = {
    id?: string
    title: string
    startTime: Date | string
    endTime: Date | string
    type?: $Enums.LessonType
    status?: $Enums.LessonStatus
    cancelReason?: string | null
    location?: $Enums.LessonLocation
    locationUrl?: string | null
    address?: string | null
    publicNote?: string | null
    privateNote?: string | null
    price?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    isPaid?: boolean
    teacherId: string
    classroomId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LessonUpdateWithoutScheduleItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacher?: TeacherProfileUpdateOneRequiredWithoutLessonsNestedInput
    students?: StudentProfileUpdateManyWithoutLessonsNestedInput
    classroom?: ClassroomUpdateOneWithoutLessonsNestedInput
    attendances?: AttendanceUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUpdateManyWithoutLessonNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
    payments?: PaymentUpdateManyWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateWithoutScheduleItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentProfileUncheckedUpdateManyWithoutLessonsNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUncheckedUpdateManyWithoutLessonNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutLessonsNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutScheduleItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceCreateManyLessonInput = {
    id?: string
    studentId: string
    status: $Enums.AttendanceStatus
    note?: string | null
  }

  export type HomeworkCreateManyLessonInput = {
    id?: string
    title: string
    content?: string | null
    assignedDate?: Date | string
    dueDate: Date | string
  }

  export type MaterialCreateManyLessonInput = {
    id?: string
    title: string
    fileId?: string | null
    linkUrl?: string | null
    type: $Enums.FileType
    createdAt?: Date | string
  }

  export type StudentProfileUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneWithoutStudentProfileNestedInput
    teacherRelations?: StudentTeacherRelationUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUpdateManyWithoutStudentNestedInput
    homeworkTrackings?: HomeworkTrackingUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUpdateManyWithoutStudentNestedInput
    payments?: PaymentUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teacherRelations?: StudentTeacherRelationUncheckedUpdateManyWithoutStudentNestedInput
    classrooms?: ClassroomUncheckedUpdateManyWithoutStudentsNestedInput
    recurringSchedules?: ScheduleItemUncheckedUpdateManyWithoutStudentNestedInput
    homeworkTrackings?: HomeworkTrackingUncheckedUpdateManyWithoutStudentNestedInput
    submissions?: HomeworkSubmissionUncheckedUpdateManyWithoutStudentNestedInput
    payments?: PaymentUncheckedUpdateManyWithoutStudentNestedInput
    grades?: SchoolExamUncheckedUpdateManyWithoutStudentNestedInput
    trialExams?: TrialExamUncheckedUpdateManyWithoutStudentNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutStudentNestedInput
  }

  export type StudentProfileUncheckedUpdateManyWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    tempFirstName?: NullableStringFieldUpdateOperationsInput | string | null
    tempLastName?: NullableStringFieldUpdateOperationsInput | string | null
    tempPhone?: NullableStringFieldUpdateOperationsInput | string | null
    tempEmail?: NullableStringFieldUpdateOperationsInput | string | null
    tempAvatarKey?: NullableStringFieldUpdateOperationsInput | string | null
    inviteToken?: NullableStringFieldUpdateOperationsInput | string | null
    inviteTokenExpires?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isClaimed?: BoolFieldUpdateOperationsInput | boolean
    creatorTeacherId?: NullableStringFieldUpdateOperationsInput | string | null
    studentNo?: NullableStringFieldUpdateOperationsInput | string | null
    gradeLevel?: NullableStringFieldUpdateOperationsInput | string | null
    parentName?: NullableStringFieldUpdateOperationsInput | string | null
    parentPhone?: NullableStringFieldUpdateOperationsInput | string | null
    parentEmail?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
    student?: StudentProfileUpdateOneRequiredWithoutAttendancesNestedInput
  }

  export type AttendanceUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type AttendanceUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumAttendanceStatusFieldUpdateOperationsInput | $Enums.AttendanceStatus
    note?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type HomeworkUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trackings?: HomeworkTrackingUpdateManyWithoutHomeworkNestedInput
  }

  export type HomeworkUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
    trackings?: HomeworkTrackingUncheckedUpdateManyWithoutHomeworkNestedInput
  }

  export type HomeworkUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    assignedDate?: DateTimeFieldUpdateOperationsInput | Date | string
    dueDate?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    file?: FileUpdateOneWithoutMaterialsNestedInput
  }

  export type MaterialUncheckedUpdateWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyWithoutLessonInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PaymentUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
    student?: StudentProfileUpdateOneRequiredWithoutPaymentsNestedInput
    teacher?: TeacherProfileUpdateOneRequiredWithoutPaymentsNestedInput
  }

  export type PaymentUncheckedUpdateWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type PaymentUncheckedUpdateManyWithoutLessonsInput = {
    id?: StringFieldUpdateOperationsInput | string
    amount?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumPaymentTypeFieldUpdateOperationsInput | $Enums.PaymentType
    note?: NullableStringFieldUpdateOperationsInput | string | null
    isVisibleToStudent?: BoolFieldUpdateOperationsInput | boolean
    studentId?: StringFieldUpdateOperationsInput | string
    teacherId?: StringFieldUpdateOperationsInput | string
  }

  export type HomeworkTrackingCreateManyHomeworkInput = {
    id?: string
    studentId: string
    status?: $Enums.HomeworkStatus
    studentNote?: string | null
    teacherNote?: string | null
    fileId?: string | null
    checkedAt?: Date | string | null
  }

  export type HomeworkTrackingUpdateWithoutHomeworkInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    file?: FileUpdateOneWithoutHomeworkTrackingsNestedInput
    student?: StudentProfileUpdateOneRequiredWithoutHomeworkTrackingsNestedInput
  }

  export type HomeworkTrackingUncheckedUpdateWithoutHomeworkInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HomeworkTrackingUncheckedUpdateManyWithoutHomeworkInput = {
    id?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    fileId?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TrialExamResultCreateManyTrialExamInput = {
    id?: string
    lessonName: string
    correctCount: number
    incorrectCount: number
    emptyCount: number
    net: number
    mistakeTopics?: TrialExamResultCreatemistakeTopicsInput | string[]
    mistakeAnalysis?: string | null
  }

  export type TrialExamResultUpdateWithoutTrialExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonName?: StringFieldUpdateOperationsInput | string
    correctCount?: IntFieldUpdateOperationsInput | number
    incorrectCount?: IntFieldUpdateOperationsInput | number
    emptyCount?: IntFieldUpdateOperationsInput | number
    net?: FloatFieldUpdateOperationsInput | number
    mistakeTopics?: TrialExamResultUpdatemistakeTopicsInput | string[]
    mistakeAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrialExamResultUncheckedUpdateWithoutTrialExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonName?: StringFieldUpdateOperationsInput | string
    correctCount?: IntFieldUpdateOperationsInput | number
    incorrectCount?: IntFieldUpdateOperationsInput | number
    emptyCount?: IntFieldUpdateOperationsInput | number
    net?: FloatFieldUpdateOperationsInput | number
    mistakeTopics?: TrialExamResultUpdatemistakeTopicsInput | string[]
    mistakeAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type TrialExamResultUncheckedUpdateManyWithoutTrialExamInput = {
    id?: StringFieldUpdateOperationsInput | string
    lessonName?: StringFieldUpdateOperationsInput | string
    correctCount?: IntFieldUpdateOperationsInput | number
    incorrectCount?: IntFieldUpdateOperationsInput | number
    emptyCount?: IntFieldUpdateOperationsInput | number
    net?: FloatFieldUpdateOperationsInput | number
    mistakeTopics?: TrialExamResultUpdatemistakeTopicsInput | string[]
    mistakeAnalysis?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type LessonUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItem?: ScheduleItemUpdateOneWithoutLessonsNestedInput
    teacher?: TeacherProfileUpdateOneRequiredWithoutLessonsNestedInput
    students?: StudentProfileUpdateManyWithoutLessonsNestedInput
    classroom?: ClassroomUpdateOneWithoutLessonsNestedInput
    attendances?: AttendanceUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUpdateManyWithoutLessonNestedInput
    materials?: MaterialUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    students?: StudentProfileUncheckedUpdateManyWithoutLessonsNestedInput
    attendances?: AttendanceUncheckedUpdateManyWithoutLessonNestedInput
    homeworks?: HomeworkUncheckedUpdateManyWithoutLessonNestedInput
    materials?: MaterialUncheckedUpdateManyWithoutLessonNestedInput
  }

  export type LessonUncheckedUpdateManyWithoutPaymentsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    startTime?: DateTimeFieldUpdateOperationsInput | Date | string
    endTime?: DateTimeFieldUpdateOperationsInput | Date | string
    scheduleItemId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumLessonTypeFieldUpdateOperationsInput | $Enums.LessonType
    status?: EnumLessonStatusFieldUpdateOperationsInput | $Enums.LessonStatus
    cancelReason?: NullableStringFieldUpdateOperationsInput | string | null
    location?: EnumLessonLocationFieldUpdateOperationsInput | $Enums.LessonLocation
    locationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    address?: NullableStringFieldUpdateOperationsInput | string | null
    publicNote?: NullableStringFieldUpdateOperationsInput | string | null
    privateNote?: NullableStringFieldUpdateOperationsInput | string | null
    price?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    teacherId?: StringFieldUpdateOperationsInput | string
    classroomId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialCreateManyFileInput = {
    id?: string
    title: string
    linkUrl?: string | null
    type: $Enums.FileType
    lessonId: string
    createdAt?: Date | string
  }

  export type MessageCreateManyFileInput = {
    id?: string
    content?: string | null
    createdAt?: Date | string
    isRead?: boolean
    readAt?: Date | string | null
    senderId: string
    receiverId: string
  }

  export type HomeworkTrackingCreateManyFileInput = {
    id?: string
    homeworkId: string
    studentId: string
    status?: $Enums.HomeworkStatus
    studentNote?: string | null
    teacherNote?: string | null
    checkedAt?: Date | string | null
  }

  export type HomeworkSubmissionCreateManyFileInput = {
    id?: string
    note?: string | null
    submittedAt?: Date | string
    studentId: string
  }

  export type MaterialUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lesson?: LessonUpdateOneRequiredWithoutMaterialsNestedInput
  }

  export type MaterialUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MaterialUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    linkUrl?: NullableStringFieldUpdateOperationsInput | string | null
    type?: EnumFileTypeFieldUpdateOperationsInput | $Enums.FileType
    lessonId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type MessageUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    receiver?: UserUpdateOneRequiredWithoutReceivedMessagesNestedInput
    sender?: UserUpdateOneRequiredWithoutSentMessagesNestedInput
  }

  export type MessageUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type MessageUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    content?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    readAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    senderId?: StringFieldUpdateOperationsInput | string
    receiverId?: StringFieldUpdateOperationsInput | string
  }

  export type HomeworkTrackingUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    homework?: HomeworkUpdateOneRequiredWithoutTrackingsNestedInput
    student?: StudentProfileUpdateOneRequiredWithoutHomeworkTrackingsNestedInput
  }

  export type HomeworkTrackingUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeworkId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HomeworkTrackingUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    homeworkId?: StringFieldUpdateOperationsInput | string
    studentId?: StringFieldUpdateOperationsInput | string
    status?: EnumHomeworkStatusFieldUpdateOperationsInput | $Enums.HomeworkStatus
    studentNote?: NullableStringFieldUpdateOperationsInput | string | null
    teacherNote?: NullableStringFieldUpdateOperationsInput | string | null
    checkedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type HomeworkSubmissionUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    student?: StudentProfileUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type HomeworkSubmissionUncheckedUpdateWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }

  export type HomeworkSubmissionUncheckedUpdateManyWithoutFileInput = {
    id?: StringFieldUpdateOperationsInput | string
    note?: NullableStringFieldUpdateOperationsInput | string | null
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    studentId?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}