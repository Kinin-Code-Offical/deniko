"use strict";Object.defineProperty(exports, "__esModule", { value: true });exports.default = void 0;

await jitiImport("dotenv/config");
var _nodeFs = _interopRequireDefault(await jitiImport("node:fs"));
var _nodeOs = _interopRequireDefault(await jitiImport("node:os"));
var _nodePath = _interopRequireDefault(await jitiImport("node:path"));
var _config2 = await jitiImport("prisma/config");function _interopRequireDefault(e) {return e && e.__esModule ? e : { default: e };} // This file was generated by Prisma and assumes you have installed the following:
// npm install --save-dev prisma dotenv
const ensurePrismaSslFiles = () => {
  const ca = process.env.DATABASE_SSL_CA;
  const cert = process.env.DATABASE_SSL_CERT;
  const key = process.env.DATABASE_SSL_KEY;

  if (!ca && !cert && !key) return;

  const toMultiline = (value) => value?.replace(/\\n/g, "\n");
  const sslDir = _nodePath.default.join(_nodeOs.default.tmpdir(), `deniko-prisma-ssl-${process.pid}`);
  _nodeFs.default.mkdirSync(sslDir, { recursive: true });
  const createdPaths = [];

  const writeIfPresent = (value, filename) => {
    if (!value) return undefined;
    const filePath = _nodePath.default.join(sslDir, filename);
    _nodeFs.default.writeFileSync(filePath, toMultiline(value) ?? "", { encoding: "utf8" });
    createdPaths.push(filePath);
    return filePath;
  };

  const cleanup = () => {
    createdPaths.forEach((filePath) => {
      try {
        _nodeFs.default.rmSync(filePath, { force: true });
      } catch {

        /* noop */}
    });
    try {
      _nodeFs.default.rmSync(sslDir, { force: true, recursive: true });
    } catch {

      /* noop */}
  };

  const registerCleanup = () => {
    if (registerCleanup.registered)
    return;
    registerCleanup.registered = true;
    const signals = ["SIGINT", "SIGTERM", "SIGQUIT"];
    signals.forEach((signal) => {
      process.once(signal, () => {
        cleanup();
        process.exit();
      });
    });
    process.once("exit", cleanup);
  };
  registerCleanup();

  const caPath = writeIfPresent(ca, "ca.pem");
  const certPath = writeIfPresent(cert, "client.pem");
  const keyPath = writeIfPresent(key, "key.pem");

  const forUrl = (filePath) => filePath.replace(/\\/g, "/");

  const patchUrl = (raw) => {
    if (!raw) return raw ?? undefined;
    try {
      // We use string manipulation instead of URL object to preserve the original password encoding exactly.
      // Some special characters in passwords might be mishandled during URL parsing/re-serialization.
      const url = raw;
      const separator = url.includes("?") ? "&" : "?";

      const params = [];
      // Force sslmode to 'require' to skip strict hostname/CA verification
      // We append it at the end, which overrides any previous sslmode in the connection string (for libpq)
      params.push("sslmode=require");

      if (certPath) params.push(`sslcert=${forUrl(certPath)}`);
      if (keyPath) params.push(`sslkey=${forUrl(keyPath)}`);

      // On Windows, providing sslrootcert often causes "certificate verify failed" with self-signed certs in CLI
      // On Cloud Run (Linux), we want it for better security if possible.
      if (caPath && process.platform !== "win32") {
        params.push(`sslrootcert=${forUrl(caPath)}`);
      }

      return `${url}${separator}${params.join("&")}`;
    } catch {
      return raw;
    }
  };

  const patchedDatabaseUrl = patchUrl(process.env.DATABASE_URL);
  if (patchedDatabaseUrl) {
    process.env.DATABASE_URL = patchedDatabaseUrl;
  }

  const patchedDirectUrl = patchUrl(process.env.DIRECT_URL);
  if (patchedDirectUrl) {
    process.env.DIRECT_URL = patchedDirectUrl;
  }

  const lastPatchedUrl = patchedDirectUrl ?? patchedDatabaseUrl;
  if (lastPatchedUrl) {
    console.log(`[prisma.config] Final connection URL: ${lastPatchedUrl}`); // ignore-console-check
  }
};

ensurePrismaSslFiles();

const getRequiredEnv = (value, name) => {
  if (!value) {
    throw new Error(
      `[prisma.config] Missing required environment variable: ${name}`
    );
  }
  return value;
};var _default = exports.default =

(0, _config2.defineConfig)({
  schema: "prisma/schema.prisma",
  migrations: {
    path: "prisma/migrations"
  },
  datasource: {
    // Pass the patched values directly instead of relying on env() lookup
    url: getRequiredEnv(process.env.DATABASE_URL, "DATABASE_URL")
  }
}); /* v9-594f09c8ce3c1c54 */
